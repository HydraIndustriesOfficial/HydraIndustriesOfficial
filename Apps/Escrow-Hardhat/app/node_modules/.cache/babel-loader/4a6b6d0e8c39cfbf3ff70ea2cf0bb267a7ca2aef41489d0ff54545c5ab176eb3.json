{"ast":null,"code":"import _get from \"/Users/kbookout/escrow-hardhat/app/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/kbookout/escrow-hardhat/app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/kbookout/escrow-hardhat/app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/kbookout/escrow-hardhat/app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _regeneratorRuntime from \"/Users/kbookout/escrow-hardhat/app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"/Users/kbookout/escrow-hardhat/app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/kbookout/escrow-hardhat/app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { _ as __awaiter, D as DEFAULT_ALCHEMY_API_KEY, C as CustomNetworks, a as DEFAULT_NETWORK, N as Network, I as IS_BROWSER, V as VERSION, l as logWarn, d as deepCopy, E as EthersNetwork, g as getAlchemyHttpUrl, b as getAlchemyWsUrl } from './index-fd7838ce.js';\nimport { getNetwork as _getNetwork } from '@ethersproject/networks';\nimport { JsonRpcProvider } from '@ethersproject/providers';\nimport { fetchJson } from '@ethersproject/web';\nimport './api/utils';\nimport '@ethersproject/bignumber';\nimport 'axios';\nimport '@ethersproject/abstract-provider';\nimport '@ethersproject/wallet';\nimport '@ethersproject/contracts';\n\n/** Maximum size of a batch on the rpc provider. */\nvar DEFAULT_MAX_REQUEST_BATCH_SIZE = 100;\n/** Timeout interval before the pending batch is sent. */\nvar DEFAULT_REQUEST_BATCH_DELAY_MS = 10;\n/**\r\n * Internal class to enqueue requests and automatically send/process batches.\r\n *\r\n * The underlying batching mechanism is loosely based on ethers.js's\r\n * `JsonRpcBatchProvider`.\r\n *\r\n * @internal\r\n */\nvar RequestBatcher = /*#__PURE__*/function () {\n  function RequestBatcher(sendBatchFn) {\n    var maxBatchSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_MAX_REQUEST_BATCH_SIZE;\n    _classCallCheck(this, RequestBatcher);\n    this.sendBatchFn = sendBatchFn;\n    this.maxBatchSize = maxBatchSize;\n    /**\r\n     * Array of enqueued requests along with the constructed promise handlers for\r\n     * each request.\r\n     */\n    this.pendingBatch = [];\n  }\n  /**\r\n   * Enqueues the provided request. The batch is immediately sent if the maximum\r\n   * batch size is reached. Otherwise, the request is enqueued onto a batch that\r\n   * is sent after 10ms.\r\n   *\r\n   * Returns a promise that resolves with the result of the request.\r\n   */\n  _createClass(RequestBatcher, [{\n    key: \"enqueueRequest\",\n    value: function enqueueRequest(request) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _this = this;\n        var inflightRequest, promise;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              inflightRequest = {\n                request: request,\n                resolve: undefined,\n                reject: undefined\n              };\n              promise = new Promise(function (resolve, reject) {\n                inflightRequest.resolve = resolve;\n                inflightRequest.reject = reject;\n              });\n              this.pendingBatch.push(inflightRequest);\n              if (this.pendingBatch.length === this.maxBatchSize) {\n                // Send batch immediately if we are at the maximum batch size.\n                void this.sendBatchRequest();\n              } else if (!this.pendingBatchTimer) {\n                // Schedule batch for next event loop + short duration\n                this.pendingBatchTimer = setTimeout(function () {\n                  return _this.sendBatchRequest();\n                }, DEFAULT_REQUEST_BATCH_DELAY_MS);\n              }\n              return _context.abrupt(\"return\", promise);\n            case 5:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\r\n     * Sends the currently queued batches and resets the batch and timer. Processes\r\n     * the batched response results back to the original promises.\r\n     */\n  }, {\n    key: \"sendBatchRequest\",\n    value: function sendBatchRequest() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var batch, request;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              // Get the current batch and clear it, so new requests\n              // go into the next batch\n              batch = this.pendingBatch;\n              this.pendingBatch = [];\n              if (this.pendingBatchTimer) {\n                clearTimeout(this.pendingBatchTimer);\n                this.pendingBatchTimer = undefined;\n              }\n              // Get the request as an array of requests\n              request = batch.map(function (inflight) {\n                return inflight.request;\n              });\n              return _context2.abrupt(\"return\", this.sendBatchFn(request).then(function (result) {\n                // For each result, feed it to the correct Promise, depending\n                // on whether it was a success or error\n                batch.forEach(function (inflightRequest, index) {\n                  var payload = result[index];\n                  if (payload.error) {\n                    var error = new Error(payload.error.message);\n                    error.code = payload.error.code;\n                    error.data = payload.error.data;\n                    inflightRequest.reject(error);\n                  } else {\n                    inflightRequest.resolve(payload.result);\n                  }\n                });\n              }, function (error) {\n                batch.forEach(function (inflightRequest) {\n                  inflightRequest.reject(error);\n                });\n              }));\n            case 5:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n    }\n  }]);\n  return RequestBatcher;\n}();\n/**\r\n * SDK's custom implementation of ethers.js's 'AlchemyProvider'.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an instance of\r\n * {@link Alchemy} and call {@link Alchemy.config.getProvider()}.\r\n *\r\n * @public\r\n */\nvar AlchemyProvider = /*#__PURE__*/function (_JsonRpcProvider) {\n  _inherits(AlchemyProvider, _JsonRpcProvider);\n  var _super2 = _createSuper(AlchemyProvider);\n  /** @internal */\n  function AlchemyProvider(config) {\n    var _this2;\n    _classCallCheck(this, AlchemyProvider);\n    // Normalize the API Key to a string.\n    var apiKey = AlchemyProvider.getApiKey(config.apiKey);\n    // Generate our own connection info with the correct endpoint URLs.\n    var alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\n    var connection = AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, 'http');\n    // If a hardcoded url was specified in the config, use that instead of the\n    // provided apiKey or network.\n    if (config.url !== undefined) {\n      connection.url = config.url;\n    }\n    connection.throttleLimit = config.maxRetries;\n    // Normalize the Alchemy named network input to the network names used by\n    // ethers. This allows the parent super constructor in JsonRpcProvider to\n    // correctly set the network.\n    var ethersNetwork = EthersNetwork[alchemyNetwork];\n    _this2 = _super2.call(this, connection, ethersNetwork);\n    _this2.apiKey = config.apiKey;\n    _this2.maxRetries = config.maxRetries;\n    _this2.batchRequests = config.batchRequests;\n    // TODO: support individual headers when calling batch\n    var batcherConnection = Object.assign(Object.assign({}, _this2.connection), {\n      headers: Object.assign(Object.assign({}, _this2.connection.headers), {\n        'Alchemy-Ethers-Sdk-Method': 'batchSend'\n      })\n    });\n    var sendBatchFn = function sendBatchFn(requests) {\n      return fetchJson(batcherConnection, JSON.stringify(requests));\n    };\n    _this2.batcher = new RequestBatcher(sendBatchFn);\n    return _this2;\n  }\n  /**\r\n   * Overrides the `UrlJsonRpcProvider.getApiKey` method as implemented by\r\n   * ethers.js. Returns the API key for an Alchemy provider.\r\n   *\r\n   * @internal\r\n   * @override\r\n   */\n  _createClass(AlchemyProvider, [{\n    key: \"detectNetwork\",\n    value:\n    /**\r\n     * Overrides the method in ethers.js's `StaticJsonRpcProvider` class. This\r\n     * method is called when calling methods on the parent class `BaseProvider`.\r\n     *\r\n     * @override\r\n     */\n    function detectNetwork() {\n      var _this3 = this;\n      var _super = Object.create(null, {\n        detectNetwork: {\n          get: function get() {\n            return _get(_getPrototypeOf(AlchemyProvider.prototype), \"detectNetwork\", _this3);\n          }\n        }\n      });\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var network;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              network = this.network;\n              if (!(network == null)) {\n                _context3.next = 7;\n                break;\n              }\n              _context3.next = 4;\n              return _super.detectNetwork.call(this);\n            case 4:\n              network = _context3.sent;\n              if (network) {\n                _context3.next = 7;\n                break;\n              }\n              throw new Error('No network detected');\n            case 7:\n              return _context3.abrupt(\"return\", network);\n            case 8:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n    }\n  }, {\n    key: \"_startPending\",\n    value: function _startPending() {\n      logWarn('WARNING: Alchemy Provider does not support pending filters');\n    }\n    /**\r\n     * Overrides the ether's `isCommunityResource()` method. Returns true if the\r\n     * current api key is the default key.\r\n     *\r\n     * @override\r\n     */\n  }, {\n    key: \"isCommunityResource\",\n    value: function isCommunityResource() {\n      return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\n    }\n    /**\r\n     * Overrides the base {@link JsonRpcProvider.send} method to implement custom\r\n     * logic for sending requests to Alchemy.\r\n     *\r\n     * @param method The method name to use for the request.\r\n     * @param params The parameters to use for the request.\r\n     * @override\r\n     * @public\r\n     */\n    // TODO: Add headers for `perform()` override.\n  }, {\n    key: \"send\",\n    value: function send(method, params) {\n      return this._send(method, params, 'send');\n    }\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `JsonRpcProvider.send()`.\r\n     *\r\n     * This method is copied over directly in order to implement custom headers\r\n     *\r\n     * @internal\r\n     */\n  }, {\n    key: \"_send\",\n    value: function _send(method, params, methodName) {\n      var _this4 = this;\n      var forceBatch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var request = {\n        method: method,\n        params: params,\n        id: this._nextId++,\n        jsonrpc: '2.0'\n      };\n      // START MODIFIED CODE\n      var connection = Object.assign({}, this.connection);\n      connection.headers['Alchemy-Ethers-Sdk-Method'] = methodName;\n      if (this.batchRequests || forceBatch) {\n        return this.batcher.enqueueRequest(request);\n      }\n      // END MODIFIED CODE\n      this.emit('debug', {\n        action: 'request',\n        request: deepCopy(request),\n        provider: this\n      });\n      // We can expand this in the future to any call, but for now these\n      // are the biggest wins and do not require any serializing parameters.\n      var cache = ['eth_chainId', 'eth_blockNumber'].indexOf(method) >= 0;\n      if (cache && this._cache[method]) {\n        return this._cache[method];\n      }\n      var result = fetchJson(this.connection, JSON.stringify(request), getResult).then(function (result) {\n        _this4.emit('debug', {\n          action: 'response',\n          request: request,\n          response: result,\n          provider: _this4\n        });\n        return result;\n      }, function (error) {\n        _this4.emit('debug', {\n          action: 'response',\n          error: error,\n          request: request,\n          provider: _this4\n        });\n        throw error;\n      });\n      // Cache the fetch, but clear it on the next event loop\n      if (cache) {\n        this._cache[method] = result;\n        setTimeout(function () {\n          // @ts-ignore - This is done by ethers.\n          _this4._cache[method] = null;\n        }, 0);\n      }\n      return result;\n    }\n  }], [{\n    key: \"getApiKey\",\n    value: function getApiKey(apiKey) {\n      if (apiKey == null) {\n        return DEFAULT_ALCHEMY_API_KEY;\n      }\n      if (apiKey && typeof apiKey !== 'string') {\n        throw new Error(\"Invalid apiKey '\".concat(apiKey, \"' provided. apiKey must be a string.\"));\n      }\n      return apiKey;\n    }\n    /**\r\n     * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\r\n     *\r\n     * This override allows the SDK to set the provider's network to values not\r\n     * yet supported by ethers.js.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\n  }, {\n    key: \"getNetwork\",\n    value: function getNetwork(network) {\n      if (typeof network === 'string' && network in CustomNetworks) {\n        return CustomNetworks[network];\n      }\n      // Call the standard ethers.js getNetwork method for other networks.\n      return _getNetwork(network);\n    }\n    /**\r\n     * Converts the `Networkish` input to the network enum used by Alchemy.\r\n     *\r\n     * @internal\r\n     */\n  }, {\n    key: \"getAlchemyNetwork\",\n    value: function getAlchemyNetwork(network) {\n      if (network === undefined) {\n        return DEFAULT_NETWORK;\n      }\n      if (typeof network === 'number') {\n        throw new Error(\"Invalid network '\".concat(network, \"' provided. Network must be a string.\"));\n      }\n      // Guaranteed that `typeof network === 'string`.\n      var isValidNetwork = Object.values(Network).includes(network);\n      if (!isValidNetwork) {\n        throw new Error(\"Invalid network '\".concat(network, \"' provided. Network must be one of: \") + \"\".concat(Object.values(Network).join(', '), \".\"));\n      }\n      return network;\n    }\n    /**\r\n     * Returns a {@link ConnectionInfo} object compatible with ethers that contains\r\n     * the correct URLs for Alchemy.\r\n     *\r\n     * @internal\r\n     */\n  }, {\n    key: \"getAlchemyConnectionInfo\",\n    value: function getAlchemyConnectionInfo(network, apiKey, type) {\n      var url = type === 'http' ? getAlchemyHttpUrl(network, apiKey) : getAlchemyWsUrl(network, apiKey);\n      return {\n        headers: IS_BROWSER ? {\n          'Alchemy-Ethers-Sdk-Version': VERSION\n        } : {\n          'Alchemy-Ethers-Sdk-Version': VERSION,\n          'Accept-Encoding': 'gzip'\n        },\n        allowGzip: true,\n        url: url\n      };\n    }\n  }]);\n  return AlchemyProvider;\n}(JsonRpcProvider);\n/**\r\n * DO NOT MODIFY.\r\n *\r\n * Original code copied over from ether.js's\r\n * `@ethersproject/web/src.ts/index.ts`. Used to support\r\n * {@link AlchemyProvider._send}, which is also copied over.\r\n */\nfunction getResult(payload) {\n  if (payload.error) {\n    var error = new Error(payload.error.message);\n    error.code = payload.error.code;\n    error.data = payload.error.data;\n    throw error;\n  }\n  return payload.result;\n}\nexport { AlchemyProvider };","map":{"version":3,"names":["DEFAULT_MAX_REQUEST_BATCH_SIZE","DEFAULT_REQUEST_BATCH_DELAY_MS","RequestBatcher","sendBatchFn","maxBatchSize","arguments","length","undefined","_classCallCheck","pendingBatch","_createClass","key","value","enqueueRequest","request","inflightRequest","resolve","reject","promise","Promise","push","sendBatchRequest","pendingBatchTimer","setTimeout","_this","_context","abrupt","stop","_callee","batch","clearTimeout","map","inflight","_context2","then","result","forEach","index","payload","error","Error","message","code","data","_callee2","AlchemyProvider","_JsonRpcProvider","_inherits","_super2","_createSuper","config","_this2","apiKey","getApiKey","alchemyNetwork","getAlchemyNetwork","network","connection","getAlchemyConnectionInfo","url","throttleLimit","maxRetries","ethersNetwork","EthersNetwork","call","batchRequests","batcherConnection","Object","assign","headers","requests","fetchJson","JSON","stringify","batcher","detectNetwork","_this3","_context3","next","_super","sent","_callee3","_startPending","logWarn","isCommunityResource","DEFAULT_ALCHEMY_API_KEY","send","method","params","_send","methodName","_this4","forceBatch","id","_nextId","jsonrpc","emit","action","deepCopy","provider","cache","indexOf","_cache","getResult","response","concat","getNetwork","CustomNetworks","DEFAULT_NETWORK","isValidNetwork","values","Network","includes","join","type","getAlchemyHttpUrl","getAlchemyWsUrl","IS_BROWSER","VERSION","allowGzip","JsonRpcProvider"],"sources":["/Users/kbookout/escrow-hardhat/app/node_modules/alchemy-sdk/src/internal/request-batcher.ts","/Users/kbookout/escrow-hardhat/app/node_modules/alchemy-sdk/src/api/alchemy-provider.ts"],"sourcesContent":["import { JsonRpcRequest, JsonRpcResponse } from './internal-types';\n\n/** Maximum size of a batch on the rpc provider. */\nconst DEFAULT_MAX_REQUEST_BATCH_SIZE = 100;\n\n/** Timeout interval before the pending batch is sent. */\nconst DEFAULT_REQUEST_BATCH_DELAY_MS = 10;\n\n/**\n * Internal class to enqueue requests and automatically send/process batches.\n *\n * The underlying batching mechanism is loosely based on ethers.js's\n * `JsonRpcBatchProvider`.\n *\n * @internal\n */\nexport class RequestBatcher {\n  /** Timeout timer that periodically sends the pending batch. */\n  private pendingBatchTimer: NodeJS.Timer | undefined;\n\n  /**\n   * Array of enqueued requests along with the constructed promise handlers for\n   * each request.\n   */\n  private pendingBatch: Array<BatchRequest> = [];\n\n  constructor(\n    private readonly sendBatchFn: SendBatchFn,\n    private readonly maxBatchSize = DEFAULT_MAX_REQUEST_BATCH_SIZE\n  ) {}\n\n  /**\n   * Enqueues the provided request. The batch is immediately sent if the maximum\n   * batch size is reached. Otherwise, the request is enqueued onto a batch that\n   * is sent after 10ms.\n   *\n   * Returns a promise that resolves with the result of the request.\n   */\n  async enqueueRequest(request: JsonRpcRequest): Promise<any> {\n    const inflightRequest: BatchRequest = {\n      request,\n      resolve: undefined,\n      reject: undefined\n    };\n\n    const promise = new Promise((resolve, reject) => {\n      inflightRequest.resolve = resolve;\n      inflightRequest.reject = reject;\n    });\n\n    this.pendingBatch.push(inflightRequest);\n\n    if (this.pendingBatch.length === this.maxBatchSize) {\n      // Send batch immediately if we are at the maximum batch size.\n      void this.sendBatchRequest();\n    } else if (!this.pendingBatchTimer) {\n      // Schedule batch for next event loop + short duration\n      this.pendingBatchTimer = setTimeout(\n        () => this.sendBatchRequest(),\n        DEFAULT_REQUEST_BATCH_DELAY_MS\n      );\n    }\n\n    return promise;\n  }\n\n  /**\n   * Sends the currently queued batches and resets the batch and timer. Processes\n   * the batched response results back to the original promises.\n   */\n  private async sendBatchRequest(): Promise<void> {\n    // Get the current batch and clear it, so new requests\n    // go into the next batch\n    const batch = this.pendingBatch;\n    this.pendingBatch = [];\n    if (this.pendingBatchTimer) {\n      clearTimeout(this.pendingBatchTimer);\n      this.pendingBatchTimer = undefined;\n    }\n\n    // Get the request as an array of requests\n    const request = batch.map(inflight => inflight.request);\n\n    return this.sendBatchFn(request).then(\n      result => {\n        // For each result, feed it to the correct Promise, depending\n        // on whether it was a success or error\n        batch.forEach((inflightRequest, index) => {\n          const payload = result[index];\n          if (payload.error) {\n            const error = new Error(payload.error.message);\n            (error as any).code = payload.error.code;\n            (error as any).data = payload.error.data;\n            inflightRequest.reject!(error);\n          } else {\n            inflightRequest.resolve!(payload.result);\n          }\n        });\n      },\n      error => {\n        batch.forEach(inflightRequest => {\n          inflightRequest.reject!(error);\n        });\n      }\n    );\n  }\n}\n\n/** Function type to match the `fetchJson` function in ethers. */\ntype SendBatchFn = (reqs: JsonRpcRequest[]) => Promise<JsonRpcResponse[]>;\n\n/**\n * Internal interface to represent a request on a batch along with the promises to resolve it.\n */\ninterface BatchRequest {\n  request: JsonRpcRequest;\n  resolve?: (result: any) => void;\n  reject?: (error: Error) => void;\n}\n","import {\n  Network as NetworkFromEthers,\n  Networkish,\n  getNetwork as getNetworkFromEthers\n} from '@ethersproject/networks';\nimport { deepCopy } from '@ethersproject/properties';\nimport {\n  CommunityResourcable,\n  JsonRpcProvider\n} from '@ethersproject/providers';\nimport { ConnectionInfo, fetchJson } from '@ethersproject/web';\n\nimport { JsonRpcRequest, JsonRpcResponse } from '../internal/internal-types';\nimport { RequestBatcher } from '../internal/request-batcher';\nimport { Network } from '../types/types';\nimport {\n  CustomNetworks,\n  DEFAULT_ALCHEMY_API_KEY,\n  DEFAULT_NETWORK,\n  EthersNetwork,\n  getAlchemyHttpUrl,\n  getAlchemyWsUrl\n} from '../util/const';\nimport { logWarn } from '../util/logger';\nimport { IS_BROWSER } from '../util/util';\nimport { VERSION } from '../version';\nimport { AlchemyConfig } from './alchemy-config';\n\n/**\n * SDK's custom implementation of ethers.js's 'AlchemyProvider'.\n *\n * Do not call this constructor directly. Instead, instantiate an instance of\n * {@link Alchemy} and call {@link Alchemy.config.getProvider()}.\n *\n * @public\n */\nexport class AlchemyProvider\n  extends JsonRpcProvider\n  implements CommunityResourcable\n{\n  readonly apiKey: string;\n  readonly maxRetries: number;\n  readonly batchRequests: boolean;\n\n  /**\n   * VISIBLE ONLY FOR TESTING\n   *@internal\n   */\n  readonly batcher: RequestBatcher;\n\n  /** @internal */\n  constructor(config: AlchemyConfig) {\n    // Normalize the API Key to a string.\n    const apiKey = AlchemyProvider.getApiKey(config.apiKey);\n\n    // Generate our own connection info with the correct endpoint URLs.\n    const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\n    const connection = AlchemyProvider.getAlchemyConnectionInfo(\n      alchemyNetwork,\n      apiKey,\n      'http'\n    );\n\n    // If a hardcoded url was specified in the config, use that instead of the\n    // provided apiKey or network.\n    if (config.url !== undefined) {\n      connection.url = config.url;\n    }\n\n    connection.throttleLimit = config.maxRetries;\n\n    // Normalize the Alchemy named network input to the network names used by\n    // ethers. This allows the parent super constructor in JsonRpcProvider to\n    // correctly set the network.\n    const ethersNetwork = EthersNetwork[alchemyNetwork];\n    super(connection, ethersNetwork);\n\n    this.apiKey = config.apiKey;\n    this.maxRetries = config.maxRetries;\n    this.batchRequests = config.batchRequests;\n\n    // TODO: support individual headers when calling batch\n    const batcherConnection = {\n      ...this.connection,\n      headers: {\n        ...this.connection.headers,\n        'Alchemy-Ethers-Sdk-Method': 'batchSend'\n      }\n    };\n    const sendBatchFn = (\n      requests: JsonRpcRequest[]\n    ): Promise<JsonRpcResponse[]> => {\n      return fetchJson(batcherConnection, JSON.stringify(requests));\n    };\n    this.batcher = new RequestBatcher(sendBatchFn);\n  }\n\n  /**\n   * Overrides the `UrlJsonRpcProvider.getApiKey` method as implemented by\n   * ethers.js. Returns the API key for an Alchemy provider.\n   *\n   * @internal\n   * @override\n   */\n  static getApiKey(apiKey: any): string {\n    if (apiKey == null) {\n      return DEFAULT_ALCHEMY_API_KEY;\n    }\n    if (apiKey && typeof apiKey !== 'string') {\n      throw new Error(\n        `Invalid apiKey '${apiKey}' provided. apiKey must be a string.`\n      );\n    }\n    return apiKey;\n  }\n\n  /**\n   * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\n   *\n   * This override allows the SDK to set the provider's network to values not\n   * yet supported by ethers.js.\n   *\n   * @internal\n   * @override\n   */\n  static getNetwork(network: Networkish): NetworkFromEthers {\n    if (typeof network === 'string' && network in CustomNetworks) {\n      return CustomNetworks[network];\n    }\n\n    // Call the standard ethers.js getNetwork method for other networks.\n    return getNetworkFromEthers(network);\n  }\n\n  /**\n   * Converts the `Networkish` input to the network enum used by Alchemy.\n   *\n   * @internal\n   */\n  static getAlchemyNetwork(network?: Networkish): Network {\n    if (network === undefined) {\n      return DEFAULT_NETWORK;\n    }\n\n    if (typeof network === 'number') {\n      throw new Error(\n        `Invalid network '${network}' provided. Network must be a string.`\n      );\n    }\n\n    // Guaranteed that `typeof network === 'string`.\n    const isValidNetwork = Object.values(Network).includes(network as Network);\n    if (!isValidNetwork) {\n      throw new Error(\n        `Invalid network '${network}' provided. Network must be one of: ` +\n          `${Object.values(Network).join(', ')}.`\n      );\n    }\n    return network as Network;\n  }\n\n  /**\n   * Returns a {@link ConnectionInfo} object compatible with ethers that contains\n   * the correct URLs for Alchemy.\n   *\n   * @internal\n   */\n  static getAlchemyConnectionInfo(\n    network: Network,\n    apiKey: string,\n    type: 'wss' | 'http'\n  ): ConnectionInfo {\n    const url =\n      type === 'http'\n        ? getAlchemyHttpUrl(network, apiKey)\n        : getAlchemyWsUrl(network, apiKey);\n    return {\n      headers: IS_BROWSER\n        ? {\n            'Alchemy-Ethers-Sdk-Version': VERSION\n          }\n        : {\n            'Alchemy-Ethers-Sdk-Version': VERSION,\n            'Accept-Encoding': 'gzip'\n          },\n      allowGzip: true,\n      url\n    };\n  }\n\n  /**\n   * Overrides the method in ethers.js's `StaticJsonRpcProvider` class. This\n   * method is called when calling methods on the parent class `BaseProvider`.\n   *\n   * @override\n   */\n  async detectNetwork(): Promise<NetworkFromEthers> {\n    let network = this.network;\n    if (network == null) {\n      network = await super.detectNetwork();\n\n      if (!network) {\n        throw new Error('No network detected');\n      }\n    }\n    return network;\n  }\n\n  _startPending(): void {\n    logWarn('WARNING: Alchemy Provider does not support pending filters');\n  }\n\n  /**\n   * Overrides the ether's `isCommunityResource()` method. Returns true if the\n   * current api key is the default key.\n   *\n   * @override\n   */\n  isCommunityResource(): boolean {\n    return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\n  }\n\n  /**\n   * Overrides the base {@link JsonRpcProvider.send} method to implement custom\n   * logic for sending requests to Alchemy.\n   *\n   * @param method The method name to use for the request.\n   * @param params The parameters to use for the request.\n   * @override\n   * @public\n   */\n  // TODO: Add headers for `perform()` override.\n  send(method: string, params: Array<any>): Promise<any> {\n    return this._send(method, params, 'send');\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `JsonRpcProvider.send()`.\n   *\n   * This method is copied over directly in order to implement custom headers\n   *\n   * @internal\n   */\n  _send(\n    method: string,\n    params: Array<any>,\n    methodName: string,\n    forceBatch = false\n  ): Promise<any> {\n    const request = {\n      method,\n      params,\n      id: this._nextId++,\n      jsonrpc: '2.0'\n    };\n\n    // START MODIFIED CODE\n    const connection = { ...this.connection };\n    connection.headers!['Alchemy-Ethers-Sdk-Method'] = methodName;\n\n    if (this.batchRequests || forceBatch) {\n      return this.batcher.enqueueRequest(request as JsonRpcRequest);\n    }\n    // END MODIFIED CODE\n\n    this.emit('debug', {\n      action: 'request',\n      request: deepCopy(request),\n      provider: this\n    });\n\n    // We can expand this in the future to any call, but for now these\n    // are the biggest wins and do not require any serializing parameters.\n    const cache = ['eth_chainId', 'eth_blockNumber'].indexOf(method) >= 0;\n    if (cache && this._cache[method]) {\n      return this._cache[method];\n    }\n\n    const result = fetchJson(\n      this.connection,\n      JSON.stringify(request),\n      getResult\n    ).then(\n      result => {\n        this.emit('debug', {\n          action: 'response',\n          request,\n          response: result,\n          provider: this\n        });\n\n        return result;\n      },\n      error => {\n        this.emit('debug', {\n          action: 'response',\n          error,\n          request,\n          provider: this\n        });\n\n        throw error;\n      }\n    );\n\n    // Cache the fetch, but clear it on the next event loop\n    if (cache) {\n      this._cache[method] = result;\n      setTimeout(() => {\n        // @ts-ignore - This is done by ethers.\n        this._cache[method] = null;\n      }, 0);\n    }\n\n    return result;\n  }\n}\n\n/**\n * DO NOT MODIFY.\n *\n * Original code copied over from ether.js's\n * `@ethersproject/web/src.ts/index.ts`. Used to support\n * {@link AlchemyProvider._send}, which is also copied over.\n */\nfunction getResult(payload: {\n  error?: { code?: number; data?: any; message?: string };\n  result?: any;\n}): any {\n  if (payload.error) {\n    const error: any = new Error(payload.error.message);\n    error.code = payload.error.code;\n    error.data = payload.error.data;\n    throw error;\n  }\n\n  return payload.result;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}