{"ast":null,"code":"import _inherits from \"/Users/kbookout/escrow-hardhat/app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/kbookout/escrow-hardhat/app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _createForOfIteratorHelper from \"/Users/kbookout/escrow-hardhat/app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/Users/kbookout/escrow-hardhat/app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _regeneratorRuntime from \"/Users/kbookout/escrow-hardhat/app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"/Users/kbookout/escrow-hardhat/app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/kbookout/escrow-hardhat/app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"/Users/kbookout/escrow-hardhat/app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nvar _EthersNetwork, _logLevelToConsoleFn;\nimport { formatUnits, isHexString, hexStripZeros, hexValue } from './api/utils';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport axios from 'axios';\nimport { Provider } from '@ethersproject/abstract-provider';\nimport { Wallet as Wallet$1 } from '@ethersproject/wallet';\nimport { Contract as Contract$1, ContractFactory as ContractFactory$1 } from '@ethersproject/contracts';\n\n/**\r\n * The supported networks by Alchemy. Note that some functions are not available\r\n * on all networks. Please refer to the Alchemy documentation for which APIs are\r\n * available on which networks\r\n * {@link https://docs.alchemy.com/alchemy/apis/feature-support-by-chain}\r\n *\r\n * @public\r\n */\nvar Network;\n(function (Network) {\n  Network[\"ETH_MAINNET\"] = \"eth-mainnet\";\n  /** @deprecated - Will be removed in subsequent versions */\n  Network[\"ETH_ROPSTEN\"] = \"eth-ropsten\";\n  Network[\"ETH_GOERLI\"] = \"eth-goerli\";\n  /** @deprecated - Will be removed in subsequent versions */\n  Network[\"ETH_KOVAN\"] = \"eth-kovan\";\n  /** @deprecated - Will be removed in subsequent versions */\n  Network[\"ETH_RINKEBY\"] = \"eth-rinkeby\";\n  Network[\"ETH_SEPOLIA\"] = \"eth-sepolia\";\n  Network[\"OPT_MAINNET\"] = \"opt-mainnet\";\n  /** @deprecated - Will be removed in subsequent versions */\n  Network[\"OPT_KOVAN\"] = \"opt-kovan\";\n  Network[\"OPT_GOERLI\"] = \"opt-goerli\";\n  Network[\"ARB_MAINNET\"] = \"arb-mainnet\";\n  /** @deprecated - Will be removed in subsequent versions */\n  Network[\"ARB_RINKEBY\"] = \"arb-rinkeby\";\n  Network[\"ARB_GOERLI\"] = \"arb-goerli\";\n  Network[\"MATIC_MAINNET\"] = \"polygon-mainnet\";\n  Network[\"MATIC_MUMBAI\"] = \"polygon-mumbai\";\n  Network[\"ASTAR_MAINNET\"] = \"astar-mainnet\";\n  Network[\"POLYGONZKEVM_MAINNET\"] = \"polygonzkevm-mainnet\";\n  Network[\"POLYGONZKEVM_TESTNET\"] = \"polygonzkevm-testnet\";\n  Network[\"BASE_MAINNET\"] = \"base-mainnet\";\n  Network[\"BASE_GOERLI\"] = \"base-goerli\";\n})(Network || (Network = {}));\n/** Token Types for the `getTokenBalances()` endpoint. */\nvar TokenBalanceType;\n(function (TokenBalanceType) {\n  /**\r\n   * Option to fetch the top 100 tokens by 24-hour volume. This option is only\r\n   * available on Mainnet in Ethereum, Polygon, and Arbitrum.\r\n   */\n  TokenBalanceType[\"DEFAULT_TOKENS\"] = \"DEFAULT_TOKENS\";\n  /**\r\n   * Option to fetch the set of ERC-20 tokens that the address as ever held. his\r\n   * list is produced by an address's historical transfer activity and includes\r\n   * all tokens that the address has ever received.\r\n   */\n  TokenBalanceType[\"ERC20\"] = \"erc20\";\n})(TokenBalanceType || (TokenBalanceType = {}));\n/**\r\n * Categories of transfers to use with the {@link AssetTransfersParams} request\r\n * object when using {@link CoreNamespace.getAssetTransfers}.\r\n *\r\n * @public\r\n */\nvar AssetTransfersCategory;\n(function (AssetTransfersCategory) {\n  /**\r\n   * Top level ETH transactions that occur where the `fromAddress` is an\r\n   * external user-created address. External addresses have private keys and are\r\n   * accessed by users.\r\n   */\n  AssetTransfersCategory[\"EXTERNAL\"] = \"external\";\n  /**\r\n   * Top level ETH transactions that occur where the `fromAddress` is an\r\n   * internal, smart contract address. For example, a smart contract calling\r\n   * another smart contract or sending\r\n   */\n  AssetTransfersCategory[\"INTERNAL\"] = \"internal\";\n  /** ERC20 transfers. */\n  AssetTransfersCategory[\"ERC20\"] = \"erc20\";\n  /** ERC721 transfers. */\n  AssetTransfersCategory[\"ERC721\"] = \"erc721\";\n  /** ERC1155 transfers. */\n  AssetTransfersCategory[\"ERC1155\"] = \"erc1155\";\n  /** Special contracts that don't follow ERC 721/1155, (ex: CryptoKitties). */\n  AssetTransfersCategory[\"SPECIALNFT\"] = \"specialnft\";\n})(AssetTransfersCategory || (AssetTransfersCategory = {}));\n/**\r\n * Enum for the order of the {@link AssetTransfersParams} request object when\r\n * using {@link CoreNamespace.getAssetTransfers}.\r\n *\r\n * @deprecated Use {@link SortingOrder} instead. This enum will be removed in a\r\n *   future version.\r\n * @public\r\n */\nvar AssetTransfersOrder;\n(function (AssetTransfersOrder) {\n  AssetTransfersOrder[\"ASCENDING\"] = \"asc\";\n  AssetTransfersOrder[\"DESCENDING\"] = \"desc\";\n})(AssetTransfersOrder || (AssetTransfersOrder = {}));\n/**\r\n * An enum for specifying the token type on NFTs.\r\n *\r\n * @public\r\n */\nvar NftTokenType;\n(function (NftTokenType) {\n  NftTokenType[\"ERC721\"] = \"ERC721\";\n  NftTokenType[\"ERC1155\"] = \"ERC1155\";\n  NftTokenType[\"NO_SUPPORTED_NFT_STANDARD\"] = \"NO_SUPPORTED_NFT_STANDARD\";\n  NftTokenType[\"NOT_A_CONTRACT\"] = \"NOT_A_CONTRACT\";\n  NftTokenType[\"UNKNOWN\"] = \"UNKNOWN\";\n})(NftTokenType || (NftTokenType = {}));\n/** Potential reasons why an NFT contract was classified as spam. */\nvar NftSpamClassification;\n(function (NftSpamClassification) {\n  NftSpamClassification[\"Erc721TooManyOwners\"] = \"Erc721TooManyOwners\";\n  NftSpamClassification[\"Erc721TooManyTokens\"] = \"Erc721TooManyTokens\";\n  NftSpamClassification[\"Erc721DishonestTotalSupply\"] = \"Erc721DishonestTotalSupply\";\n  NftSpamClassification[\"MostlyHoneyPotOwners\"] = \"MostlyHoneyPotOwners\";\n  NftSpamClassification[\"OwnedByMostHoneyPots\"] = \"OwnedByMostHoneyPots\";\n})(NftSpamClassification || (NftSpamClassification = {}));\n/**\r\n * Enum of NFT filters that can be applied to a {@link getNftsForOwner} request.\r\n * NFTs that match one or more of these filters are excluded from the response.\r\n *\r\n * @deprecated Use {@link NftFilters} instead. This enum will be removed in a\r\n *   future version.\r\n *\r\n * @beta\r\n */\nvar NftExcludeFilters;\n(function (NftExcludeFilters) {\n  /** Exclude NFTs that have been classified as spam. */\n  NftExcludeFilters[\"SPAM\"] = \"SPAM\";\n  /** Exclude NFTs that have been airdropped to a user. */\n  NftExcludeFilters[\"AIRDROPS\"] = \"AIRDROPS\";\n})(NftExcludeFilters || (NftExcludeFilters = {}));\n/**\r\n * Enum of NFT filters that can be applied to a {@link getNftsForOwner} or a\r\n * {@link getContractsForOwner} request.\r\n *\r\n * @beta\r\n */\nvar NftFilters;\n(function (NftFilters) {\n  /** NFTs that have been classified as spam. */\n  NftFilters[\"SPAM\"] = \"SPAM\";\n  /** NFTs that have been airdropped to a user. */\n  NftFilters[\"AIRDROPS\"] = \"AIRDROPS\";\n})(NftFilters || (NftFilters = {}));\n/**\r\n * Enum of ordering that can be applied to a {@link getNftsForOwner} or a\r\n * {@link getContractsForOwner} response.\r\n *\r\n * @beta\r\n */\nvar NftOrdering;\n(function (NftOrdering) {\n  NftOrdering[\"TRANSFERTIME\"] = \"TRANSFERTIME\";\n})(NftOrdering || (NftOrdering = {}));\n/**\r\n * The type of transfer for the request. Note that using `TO` will also include\r\n * NFTs that were minted by the owner.\r\n */\nvar GetTransfersForOwnerTransferType;\n(function (GetTransfersForOwnerTransferType) {\n  GetTransfersForOwnerTransferType[\"TO\"] = \"TO\";\n  GetTransfersForOwnerTransferType[\"FROM\"] = \"FROM\";\n})(GetTransfersForOwnerTransferType || (GetTransfersForOwnerTransferType = {}));\n/**\r\n * Enum for representing the supported sorting orders of the API.\r\n *\r\n * @public\r\n */\nvar SortingOrder;\n(function (SortingOrder) {\n  SortingOrder[\"ASCENDING\"] = \"asc\";\n  SortingOrder[\"DESCENDING\"] = \"desc\";\n})(SortingOrder || (SortingOrder = {}));\n/**\r\n * Enum representing the supported NFT marketplaces by the\r\n * {@link NftNamespace.getNftSales} method.\r\n *\r\n * @public\r\n */\nvar NftSaleMarketplace;\n(function (NftSaleMarketplace) {\n  NftSaleMarketplace[\"SEAPORT\"] = \"seaport\";\n  NftSaleMarketplace[\"LOOKSRARE\"] = \"looksrare\";\n  NftSaleMarketplace[\"X2Y2\"] = \"x2y2\";\n  NftSaleMarketplace[\"WYVERN\"] = \"wyvern\";\n  NftSaleMarketplace[\"CRYPTOPUNKS\"] = \"cryptopunks\";\n  NftSaleMarketplace[\"BLUR\"] = \"blur\";\n  NftSaleMarketplace[\"UNKNOWN\"] = \"unknown\";\n})(NftSaleMarketplace || (NftSaleMarketplace = {}));\n/**\r\n * Enum for specifying the taker type for the {@link NftNamespace.getNftSales}\r\n * method.\r\n *\r\n * @public\r\n */\nvar NftSaleTakerType;\n(function (NftSaleTakerType) {\n  NftSaleTakerType[\"BUYER\"] = \"buyer\";\n  NftSaleTakerType[\"SELLER\"] = \"seller\";\n})(NftSaleTakerType || (NftSaleTakerType = {}));\n/** The current state of the NFT contract refresh process. */\nvar RefreshState;\n(function (RefreshState) {\n  /** The provided contract is not an NFT or does not contain metadata. */\n  RefreshState[\"DOES_NOT_EXIST\"] = \"does_not_exist\";\n  /** The contract has already been queued for refresh. */\n  RefreshState[\"ALREADY_QUEUED\"] = \"already_queued\";\n  /** The contract is currently being refreshed. */\n  RefreshState[\"IN_PROGRESS\"] = \"in_progress\";\n  /** The contract refresh is complete. */\n  RefreshState[\"FINISHED\"] = \"finished\";\n  /** The contract refresh has been queued and await execution. */\n  RefreshState[\"QUEUED\"] = \"queued\";\n  /** The contract was unable to be queued due to an internal error. */\n  RefreshState[\"QUEUE_FAILED\"] = \"queue_failed\";\n})(RefreshState || (RefreshState = {}));\n/** An OpenSea collection's approval status. */\nvar OpenSeaSafelistRequestStatus;\n(function (OpenSeaSafelistRequestStatus) {\n  /** Verified collection. */\n  OpenSeaSafelistRequestStatus[\"VERIFIED\"] = \"verified\";\n  /** Collections that are approved on open sea and can be found in search results. */\n  OpenSeaSafelistRequestStatus[\"APPROVED\"] = \"approved\";\n  /** Collections that requested safelisting on OpenSea. */\n  OpenSeaSafelistRequestStatus[\"REQUESTED\"] = \"requested\";\n  /** Brand new collections. */\n  OpenSeaSafelistRequestStatus[\"NOT_REQUESTED\"] = \"not_requested\";\n})(OpenSeaSafelistRequestStatus || (OpenSeaSafelistRequestStatus = {}));\n/**\r\n * Method names for Alchemy's custom Subscription API endpoints.\r\n *\r\n * This value is provided in the `method` field when creating an event filter on\r\n * the Websocket Namespace.\r\n */\nvar AlchemySubscription;\n(function (AlchemySubscription) {\n  AlchemySubscription[\"PENDING_TRANSACTIONS\"] = \"alchemy_pendingTransactions\";\n  AlchemySubscription[\"MINED_TRANSACTIONS\"] = \"alchemy_minedTransactions\";\n})(AlchemySubscription || (AlchemySubscription = {}));\n/**\r\n * Asset type returned when calling {@link TransactNamespace.simulateAssetChanges}.\r\n * Allows you to determine if the assets approved or / and transferred are\r\n * native, tokens or NFTs.\r\n */\nvar SimulateAssetType;\n(function (SimulateAssetType) {\n  /**\r\n   * Native transfers that involve the currency of the chain the simulation is\r\n   * run on (ex: ETH for Ethereum, MATIC for Polygon, ETH for Arbitrum).\r\n   */\n  SimulateAssetType[\"NATIVE\"] = \"NATIVE\";\n  /** ERC20 approval or transfers. */\n  SimulateAssetType[\"ERC20\"] = \"ERC20\";\n  /** ERC721 approval or transfers. */\n  SimulateAssetType[\"ERC721\"] = \"ERC721\";\n  /** ERC1155 approval or transfers. */\n  SimulateAssetType[\"ERC1155\"] = \"ERC1155\";\n  /**\r\n   * Special contracts that don't follow ERC 721/1155.Currently limited to\r\n   * CryptoKitties and CryptoPunks.\r\n   */\n  SimulateAssetType[\"SPECIAL_NFT\"] = \"SPECIAL_NFT\";\n})(SimulateAssetType || (SimulateAssetType = {}));\n/**\r\n * Change type returned when calling {@link TransactNamespace.simulateAssetChanges}.\r\n */\nvar SimulateChangeType;\n(function (SimulateChangeType) {\n  /**\r\n   * Represents a transaction that approved or disapproved permissions for a\r\n   * contract.\r\n   *\r\n   * APPROVE without token ID → approve all tokens\r\n   * APPROVE without amount → approve all amount\r\n   * APPROVE with zero amount → approval being cleared\r\n   */\n  SimulateChangeType[\"APPROVE\"] = \"APPROVE\";\n  /**\r\n   * Represents a transaction that transferred tokens from one address to another.\r\n   */\n  SimulateChangeType[\"TRANSFER\"] = \"TRANSFER\";\n})(SimulateChangeType || (SimulateChangeType = {}));\n/**\r\n * Authority used to decode calls and logs when using the\r\n * {@link TransactNamespace.simulateExecution} method.\r\n */\nvar DecodingAuthority;\n(function (DecodingAuthority) {\n  DecodingAuthority[\"ETHERSCAN\"] = \"ETHERSCAN\";\n})(DecodingAuthority || (DecodingAuthority = {}));\n/** The type of call in a debug call trace. */\nvar DebugCallType;\n(function (DebugCallType) {\n  DebugCallType[\"CREATE\"] = \"CREATE\";\n  DebugCallType[\"CALL\"] = \"CALL\";\n  DebugCallType[\"STATICCALL\"] = \"STATICCALL\";\n  DebugCallType[\"DELEGATECALL\"] = \"DELEGATECALL\";\n})(DebugCallType || (DebugCallType = {}));\n/**\r\n * Potential transaction job statuses for a {@link GasOptimizedTransactionResponse}\r\n *\r\n * @internal\r\n */\n// TODO(txjob): Remove internal tag once this feature is released.\nvar GasOptimizedTransactionStatus;\n(function (GasOptimizedTransactionStatus) {\n  GasOptimizedTransactionStatus[\"UNSPECIFIED\"] = \"TRANSACTION_JOB_STATUS_UNSPECIFIED\";\n  GasOptimizedTransactionStatus[\"IN_PROGRESS\"] = \"IN_PROGRESS\";\n  GasOptimizedTransactionStatus[\"COMPLETE\"] = \"COMPLETE\";\n  GasOptimizedTransactionStatus[\"ABANDONED\"] = \"ABANDONED\";\n})(GasOptimizedTransactionStatus || (GasOptimizedTransactionStatus = {}));\n/** The version of the webhook. All newly created webhooks default to V2. */\nvar WebhookVersion;\n(function (WebhookVersion) {\n  WebhookVersion[\"V1\"] = \"V1\";\n  WebhookVersion[\"V2\"] = \"V2\";\n})(WebhookVersion || (WebhookVersion = {}));\n/** The type of {@link Webhook}. */\nvar WebhookType;\n(function (WebhookType) {\n  WebhookType[\"MINED_TRANSACTION\"] = \"MINED_TRANSACTION\";\n  WebhookType[\"DROPPED_TRANSACTION\"] = \"DROPPED_TRANSACTION\";\n  WebhookType[\"ADDRESS_ACTIVITY\"] = \"ADDRESS_ACTIVITY\";\n  WebhookType[\"NFT_ACTIVITY\"] = \"NFT_ACTIVITY\";\n  WebhookType[\"NFT_METADATA_UPDATE\"] = \"NFT_METADATA_UPDATE\";\n  WebhookType[\"GRAPHQL\"] = \"GRAPHQL\";\n})(WebhookType || (WebhookType = {}));\n/**\r\n * Commitment level of the target block with using methods in the\r\n * {@link DebugNamespace}\r\n */\nvar CommitmentLevel;\n(function (CommitmentLevel) {\n  /**\r\n   * Sample next block inferred by Alchemy built on top of the latest block.\r\n   * This contains the set of transactions taken from the local mempool and\r\n   * is a proxy for blocks that have not been mined yet.\r\n   */\n  CommitmentLevel[\"PENDING\"] = \"pending\";\n  /**\r\n   * The most recent block in the canonical chain observed by Alchemy. Note that\r\n   * this block may be re-orged out of the canonical chain.\r\n   */\n  CommitmentLevel[\"LATEST\"] = \"latest\";\n  /**\r\n   * The most recent crypto-economically secure block that cannot be re-orged\r\n   * outside of manual intervention driven by community coordination. This is\r\n   * only available on {@link Network.ETH_GOERLI} and {@link Network.ETH_SEPOLIA}.\r\n   */\n  CommitmentLevel[\"SAFE\"] = \"safe\";\n  /**\r\n   * The most recent secure block that has been accepted by >2/3 of validators.\r\n   * This block is very unlikely to be re-orged. This is only available on\r\n   * {@link Network.ETH_GOERLI} and {@link Network.ETH_SEPOLIA}.\r\n   */\n  CommitmentLevel[\"FINALIZED\"] = \"finalized\";\n  /**\r\n   * The lowest numbered block available that is usually the first block created.\r\n   */\n  CommitmentLevel[\"EARLIEST\"] = \"earliest\";\n})(CommitmentLevel || (CommitmentLevel = {}));\n/**\r\n * The type of tracer to use when running debug methods in the\r\n * {@link DebugNamespace}.\r\n */\nvar DebugTracerType;\n(function (DebugTracerType) {\n  DebugTracerType[\"CALL_TRACER\"] = \"callTracer\";\n  DebugTracerType[\"PRESTATE_TRACER\"] = \"prestateTracer\";\n})(DebugTracerType || (DebugTracerType = {}));\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nfunction __awaiter$1(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\nfunction __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []),\n    i,\n    q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i;\n  function verb(n) {\n    if (g[n]) i[n] = function (v) {\n      return new Promise(function (a, b) {\n        q.push([n, v, a, b]) > 1 || resume(n, v);\n      });\n    };\n  }\n  function resume(n, v) {\n    try {\n      step(g[n](v));\n    } catch (e) {\n      settle(q[0][3], e);\n    }\n  }\n  function step(r) {\n    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n  }\n  function fulfill(value) {\n    resume(\"next\", value);\n  }\n  function reject(value) {\n    resume(\"throw\", value);\n  }\n  function settle(f, v) {\n    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n  }\n}\nfunction __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator],\n    i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i);\n  function verb(n) {\n    i[n] = o[n] && function (v) {\n      return new Promise(function (resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function (v) {\n      resolve({\n        value: v,\n        done: d\n      });\n    }, reject);\n  }\n}\nvar DEFAULT_ALCHEMY_API_KEY = 'demo';\nvar DEFAULT_NETWORK = Network.ETH_MAINNET;\nvar DEFAULT_MAX_RETRIES = 5;\nvar DEFAULT_REQUEST_TIMEOUT = 0; // 0 = no timeout\n/**\r\n * Returns the base URL for making Alchemy API requests. The `alchemy.com`\r\n * endpoints only work with non eth json-rpc requests.\r\n *\r\n * @internal\r\n */\nfunction getAlchemyHttpUrl(network, apiKey) {\n  return \"https://\".concat(network, \".g.alchemy.com/v2/\").concat(apiKey);\n}\nfunction getAlchemyNftHttpUrl(network, apiKey) {\n  return \"https://\".concat(network, \".g.alchemy.com/nft/v2/\").concat(apiKey);\n}\nfunction getAlchemyWsUrl(network, apiKey) {\n  return \"wss://\".concat(network, \".g.alchemy.com/v2/\").concat(apiKey);\n}\nfunction getAlchemyWebhookHttpUrl() {\n  return 'https://dashboard.alchemy.com/api';\n}\nvar AlchemyApiType;\n(function (AlchemyApiType) {\n  AlchemyApiType[AlchemyApiType[\"BASE\"] = 0] = \"BASE\";\n  AlchemyApiType[AlchemyApiType[\"NFT\"] = 1] = \"NFT\";\n  AlchemyApiType[AlchemyApiType[\"WEBHOOK\"] = 2] = \"WEBHOOK\";\n})(AlchemyApiType || (AlchemyApiType = {}));\n/**\r\n * Mapping of network names to their corresponding Network strings used to\r\n * create an Ethers.js Provider instance.\r\n */\nvar EthersNetwork = (_EthersNetwork = {}, _defineProperty(_EthersNetwork, Network.ETH_MAINNET, 'mainnet'), _defineProperty(_EthersNetwork, Network.ETH_ROPSTEN, 'ropsten'), _defineProperty(_EthersNetwork, Network.ETH_GOERLI, 'goerli'), _defineProperty(_EthersNetwork, Network.ETH_KOVAN, 'kovan'), _defineProperty(_EthersNetwork, Network.ETH_RINKEBY, 'rinkeby'), _defineProperty(_EthersNetwork, Network.ETH_SEPOLIA, 'sepolia'), _defineProperty(_EthersNetwork, Network.OPT_MAINNET, 'optimism'), _defineProperty(_EthersNetwork, Network.OPT_KOVAN, 'optimism-kovan'), _defineProperty(_EthersNetwork, Network.OPT_GOERLI, 'optimism-goerli'), _defineProperty(_EthersNetwork, Network.ARB_MAINNET, 'arbitrum'), _defineProperty(_EthersNetwork, Network.ARB_RINKEBY, 'arbitrum-rinkeby'), _defineProperty(_EthersNetwork, Network.ARB_GOERLI, 'arbitrum-goerli'), _defineProperty(_EthersNetwork, Network.MATIC_MAINNET, 'matic'), _defineProperty(_EthersNetwork, Network.MATIC_MUMBAI, 'maticmum'), _defineProperty(_EthersNetwork, Network.ASTAR_MAINNET, 'astar-mainnet'), _defineProperty(_EthersNetwork, Network.POLYGONZKEVM_MAINNET, 'polygonzkevm-mainnet'), _defineProperty(_EthersNetwork, Network.POLYGONZKEVM_TESTNET, 'polygonzkevm-testnet'), _defineProperty(_EthersNetwork, Network.BASE_MAINNET, 'base-mainnet'), _defineProperty(_EthersNetwork, Network.BASE_GOERLI, 'base-goerli'), _EthersNetwork);\n/**\r\n * Mapping of network names to their corresponding Ethers Network objects. These\r\n * networks are not yet supported by Ethers and are listed here to be overriden\r\n * in the provider.\r\n */\nvar CustomNetworks = {\n  'arbitrum-goerli': {\n    chainId: 421613,\n    name: 'arbitrum-goerli'\n  },\n  'astar-mainnet': {\n    chainId: 592,\n    name: 'astar-mainnet'\n  },\n  sepolia: {\n    chainId: 11155111,\n    name: 'sepolia'\n  },\n  'polygonzkevm-mainnet': {\n    chainId: 1101,\n    name: 'polygonzkevm-mainnet'\n  },\n  'polygonzkevm-testnet': {\n    chainId: 1442,\n    name: 'polygonzkevm-testnet'\n  },\n  'base-mainnet': {\n    chainId: 8453,\n    name: 'base-mainnet'\n  },\n  'base-goerli': {\n    chainId: 84531,\n    name: 'base-goerli'\n  }\n};\nfunction noop() {\n  // It's a no-op\n}\nvar ETH_NULL_VALUE = '0x';\nvar ETH_NULL_ADDRESS = '0x0000000000000000000000000000000000000000';\n\n/**\r\n * This class holds the config information for the SDK client instance and\r\n * exposes the underlying providers for more advanced use cases.\r\n *\r\n * @public\r\n */\nvar AlchemyConfig = /*#__PURE__*/function () {\n  function AlchemyConfig(config) {\n    _classCallCheck(this, AlchemyConfig);\n    this.apiKey = (config === null || config === void 0 ? void 0 : config.apiKey) || DEFAULT_ALCHEMY_API_KEY;\n    this.network = (config === null || config === void 0 ? void 0 : config.network) || DEFAULT_NETWORK;\n    this.maxRetries = (config === null || config === void 0 ? void 0 : config.maxRetries) || DEFAULT_MAX_RETRIES;\n    this.url = config === null || config === void 0 ? void 0 : config.url;\n    this.authToken = config === null || config === void 0 ? void 0 : config.authToken;\n    this.batchRequests = (config === null || config === void 0 ? void 0 : config.batchRequests) || false;\n    this.requestTimeout = (config === null || config === void 0 ? void 0 : config.requestTimeout) || DEFAULT_REQUEST_TIMEOUT;\n  }\n  /**\r\n   * Returns the URL endpoint to send the HTTP request to. If a custom URL was\r\n   * provided in the config, that URL is returned. Otherwise, the default URL is\r\n   * from the network and API key.\r\n   *\r\n   * @param apiType - The type of API to get the URL for.\r\n   * @internal\r\n   */\n  _createClass(AlchemyConfig, [{\n    key: \"_getRequestUrl\",\n    value: function _getRequestUrl(apiType) {\n      if (this.url !== undefined) {\n        return this.url;\n      } else if (apiType === AlchemyApiType.NFT) {\n        return getAlchemyNftHttpUrl(this.network, this.apiKey);\n      } else if (apiType === AlchemyApiType.WEBHOOK) {\n        return getAlchemyWebhookHttpUrl();\n      } else {\n        return getAlchemyHttpUrl(this.network, this.apiKey);\n      }\n    }\n    /**\r\n     * Returns an AlchemyProvider instance. Only one provider is created per\r\n     * Alchemy instance.\r\n     *\r\n     * The AlchemyProvider is a wrapper around ether's `AlchemyProvider` class and\r\n     * has been expanded to support Alchemy's Enhanced APIs.\r\n     *\r\n     * Most common methods on the provider are available as top-level methods on\r\n     * the {@link Alchemy} instance, but the provider is exposed here to access\r\n     * other less-common methods.\r\n     *\r\n     * @public\r\n     */\n  }, {\n    key: \"getProvider\",\n    value: function getProvider() {\n      var _this = this;\n      if (!this._baseAlchemyProvider) {\n        this._baseAlchemyProvider = function () {\n          return __awaiter$1(_this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n            var _yield$import, AlchemyProvider;\n            return _regeneratorRuntime().wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  _context.next = 2;\n                  return import('./alchemy-provider-180365c7.js');\n                case 2:\n                  _yield$import = _context.sent;\n                  AlchemyProvider = _yield$import.AlchemyProvider;\n                  return _context.abrupt(\"return\", new AlchemyProvider(this));\n                case 5:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee, this);\n          }));\n        }();\n      }\n      return this._baseAlchemyProvider;\n    }\n    /**\r\n     * Returns an AlchemyWebsocketProvider instance. Only one provider is created\r\n     * per Alchemy instance.\r\n     *\r\n     * The AlchemyWebSocketProvider is a wrapper around ether's\r\n     * `AlchemyWebSocketProvider` class and has been expanded to support Alchemy's\r\n     * Subscription APIs, automatic backfilling, and other performance improvements.\r\n     *\r\n     * Most common methods on the provider are available as top-level methods on\r\n     * the {@link Alchemy} instance, but the provider is exposed here to access\r\n     * other less-common methods.\r\n     */\n  }, {\n    key: \"getWebSocketProvider\",\n    value: function getWebSocketProvider() {\n      var _this2 = this;\n      if (!this._baseAlchemyWssProvider) {\n        this._baseAlchemyWssProvider = function () {\n          return __awaiter$1(_this2, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n            var _yield$import2, AlchemyWebSocketProvider;\n            return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n              while (1) switch (_context2.prev = _context2.next) {\n                case 0:\n                  _context2.next = 2;\n                  return import('./alchemy-websocket-provider-cd606c7f.js');\n                case 2:\n                  _yield$import2 = _context2.sent;\n                  AlchemyWebSocketProvider = _yield$import2.AlchemyWebSocketProvider;\n                  return _context2.abrupt(\"return\", new AlchemyWebSocketProvider(this));\n                case 5:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }, _callee2, this);\n          }));\n        }();\n      }\n      return this._baseAlchemyWssProvider;\n    }\n  }]);\n  return AlchemyConfig;\n}();\nvar version$1 = \"logger/5.7.0\";\nvar _permanentCensorErrors = false;\nvar _censorErrors = false;\nvar LogLevels = {\n  debug: 1,\n  \"default\": 2,\n  info: 2,\n  warning: 3,\n  error: 4,\n  off: 5\n};\nvar _logLevel = LogLevels[\"default\"];\nvar _globalLogger = null;\nfunction _checkNormalize() {\n  try {\n    var missing = [];\n    // Make sure all forms of normalization are supported\n    [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach(function (form) {\n      try {\n        if (\"test\".normalize(form) !== \"test\") {\n          throw new Error(\"bad normalize\");\n        }\n        ;\n      } catch (error) {\n        missing.push(form);\n      }\n    });\n    if (missing.length) {\n      throw new Error(\"missing \" + missing.join(\", \"));\n    }\n    if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n      throw new Error(\"broken implementation\");\n    }\n  } catch (error) {\n    return error.message;\n  }\n  return null;\n}\nvar _normalizeError = _checkNormalize();\nvar LogLevel$1;\n(function (LogLevel) {\n  LogLevel[\"DEBUG\"] = \"DEBUG\";\n  LogLevel[\"INFO\"] = \"INFO\";\n  LogLevel[\"WARNING\"] = \"WARNING\";\n  LogLevel[\"ERROR\"] = \"ERROR\";\n  LogLevel[\"OFF\"] = \"OFF\";\n})(LogLevel$1 || (LogLevel$1 = {}));\nvar ErrorCode;\n(function (ErrorCode) {\n  ///////////////////\n  // Generic Errors\n  // Unknown Error\n  ErrorCode[\"UNKNOWN_ERROR\"] = \"UNKNOWN_ERROR\";\n  // Not Implemented\n  ErrorCode[\"NOT_IMPLEMENTED\"] = \"NOT_IMPLEMENTED\";\n  // Unsupported Operation\n  //   - operation\n  ErrorCode[\"UNSUPPORTED_OPERATION\"] = \"UNSUPPORTED_OPERATION\";\n  // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n  //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n  ErrorCode[\"NETWORK_ERROR\"] = \"NETWORK_ERROR\";\n  // Some sort of bad response from the server\n  ErrorCode[\"SERVER_ERROR\"] = \"SERVER_ERROR\";\n  // Timeout\n  ErrorCode[\"TIMEOUT\"] = \"TIMEOUT\";\n  ///////////////////\n  // Operational  Errors\n  // Buffer Overrun\n  ErrorCode[\"BUFFER_OVERRUN\"] = \"BUFFER_OVERRUN\";\n  // Numeric Fault\n  //   - operation: the operation being executed\n  //   - fault: the reason this faulted\n  ErrorCode[\"NUMERIC_FAULT\"] = \"NUMERIC_FAULT\";\n  ///////////////////\n  // Argument Errors\n  // Missing new operator to an object\n  //  - name: The name of the class\n  ErrorCode[\"MISSING_NEW\"] = \"MISSING_NEW\";\n  // Invalid argument (e.g. value is incompatible with type) to a function:\n  //   - argument: The argument name that was invalid\n  //   - value: The value of the argument\n  ErrorCode[\"INVALID_ARGUMENT\"] = \"INVALID_ARGUMENT\";\n  // Missing argument to a function:\n  //   - count: The number of arguments received\n  //   - expectedCount: The number of arguments expected\n  ErrorCode[\"MISSING_ARGUMENT\"] = \"MISSING_ARGUMENT\";\n  // Too many arguments\n  //   - count: The number of arguments received\n  //   - expectedCount: The number of arguments expected\n  ErrorCode[\"UNEXPECTED_ARGUMENT\"] = \"UNEXPECTED_ARGUMENT\";\n  ///////////////////\n  // Blockchain Errors\n  // Call exception\n  //  - transaction: the transaction\n  //  - address?: the contract address\n  //  - args?: The arguments passed into the function\n  //  - method?: The Solidity method signature\n  //  - errorSignature?: The EIP848 error signature\n  //  - errorArgs?: The EIP848 error parameters\n  //  - reason: The reason (only for EIP848 \"Error(string)\")\n  ErrorCode[\"CALL_EXCEPTION\"] = \"CALL_EXCEPTION\";\n  // Insufficient funds (< value + gasLimit * gasPrice)\n  //   - transaction: the transaction attempted\n  ErrorCode[\"INSUFFICIENT_FUNDS\"] = \"INSUFFICIENT_FUNDS\";\n  // Nonce has already been used\n  //   - transaction: the transaction attempted\n  ErrorCode[\"NONCE_EXPIRED\"] = \"NONCE_EXPIRED\";\n  // The replacement fee for the transaction is too low\n  //   - transaction: the transaction attempted\n  ErrorCode[\"REPLACEMENT_UNDERPRICED\"] = \"REPLACEMENT_UNDERPRICED\";\n  // The gas limit could not be estimated\n  //   - transaction: the transaction passed to estimateGas\n  ErrorCode[\"UNPREDICTABLE_GAS_LIMIT\"] = \"UNPREDICTABLE_GAS_LIMIT\";\n  // The transaction was replaced by one with a higher gas price\n  //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n  //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n  //   - hash: original transaction hash\n  //   - replacement: the full TransactionsResponse for the replacement\n  //   - receipt: the receipt of the replacement\n  ErrorCode[\"TRANSACTION_REPLACED\"] = \"TRANSACTION_REPLACED\";\n  ///////////////////\n  // Interaction Errors\n  // The user rejected the action, such as signing a message or sending\n  // a transaction\n  ErrorCode[\"ACTION_REJECTED\"] = \"ACTION_REJECTED\";\n})(ErrorCode || (ErrorCode = {}));\nvar HEX = \"0123456789abcdef\";\nvar Logger$1 = /*#__PURE__*/function () {\n  function Logger$1(version) {\n    _classCallCheck(this, Logger$1);\n    Object.defineProperty(this, \"version\", {\n      enumerable: true,\n      value: version,\n      writable: false\n    });\n  }\n  _createClass(Logger$1, [{\n    key: \"_log\",\n    value: function _log(logLevel, args) {\n      var level = logLevel.toLowerCase();\n      if (LogLevels[level] == null) {\n        this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n      }\n      if (_logLevel > LogLevels[level]) {\n        return;\n      }\n      console.log.apply(console, args);\n    }\n  }, {\n    key: \"debug\",\n    value: function debug() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      this._log(Logger$1.levels.DEBUG, args);\n    }\n  }, {\n    key: \"info\",\n    value: function info() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      this._log(Logger$1.levels.INFO, args);\n    }\n  }, {\n    key: \"warn\",\n    value: function warn() {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      this._log(Logger$1.levels.WARNING, args);\n    }\n  }, {\n    key: \"makeError\",\n    value: function makeError(message, code, params) {\n      // Errors are being censored\n      if (_censorErrors) {\n        return this.makeError(\"censored error\", code, {});\n      }\n      if (!code) {\n        code = Logger$1.errors.UNKNOWN_ERROR;\n      }\n      if (!params) {\n        params = {};\n      }\n      var messageDetails = [];\n      Object.keys(params).forEach(function (key) {\n        var value = params[key];\n        try {\n          if (value instanceof Uint8Array) {\n            var hex = \"\";\n            for (var i = 0; i < value.length; i++) {\n              hex += HEX[value[i] >> 4];\n              hex += HEX[value[i] & 0x0f];\n            }\n            messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n          } else {\n            messageDetails.push(key + \"=\" + JSON.stringify(value));\n          }\n        } catch (error) {\n          messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n        }\n      });\n      messageDetails.push(\"code=\".concat(code));\n      messageDetails.push(\"version=\".concat(this.version));\n      var reason = message;\n      var url = \"\";\n      switch (code) {\n        case ErrorCode.NUMERIC_FAULT:\n          {\n            url = \"NUMERIC_FAULT\";\n            var fault = message;\n            switch (fault) {\n              case \"overflow\":\n              case \"underflow\":\n              case \"division-by-zero\":\n                url += \"-\" + fault;\n                break;\n              case \"negative-power\":\n              case \"negative-width\":\n                url += \"-unsupported\";\n                break;\n              case \"unbound-bitwise-result\":\n                url += \"-unbound-result\";\n                break;\n            }\n            break;\n          }\n        case ErrorCode.CALL_EXCEPTION:\n        case ErrorCode.INSUFFICIENT_FUNDS:\n        case ErrorCode.MISSING_NEW:\n        case ErrorCode.NONCE_EXPIRED:\n        case ErrorCode.REPLACEMENT_UNDERPRICED:\n        case ErrorCode.TRANSACTION_REPLACED:\n        case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n          url = code;\n          break;\n      }\n      if (url) {\n        message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n      }\n      if (messageDetails.length) {\n        message += \" (\" + messageDetails.join(\", \") + \")\";\n      }\n      // @TODO: Any??\n      var error = new Error(message);\n      error.reason = reason;\n      error.code = code;\n      Object.keys(params).forEach(function (key) {\n        error[key] = params[key];\n      });\n      return error;\n    }\n  }, {\n    key: \"throwError\",\n    value: function throwError(message, code, params) {\n      throw this.makeError(message, code, params);\n    }\n  }, {\n    key: \"throwArgumentError\",\n    value: function throwArgumentError(message, name, value) {\n      return this.throwError(message, Logger$1.errors.INVALID_ARGUMENT, {\n        argument: name,\n        value: value\n      });\n    }\n  }, {\n    key: \"assert\",\n    value: function assert(condition, message, code, params) {\n      if (!!condition) {\n        return;\n      }\n      this.throwError(message, code, params);\n    }\n  }, {\n    key: \"assertArgument\",\n    value: function assertArgument(condition, message, name, value) {\n      if (!!condition) {\n        return;\n      }\n      this.throwArgumentError(message, name, value);\n    }\n  }, {\n    key: \"checkNormalize\",\n    value: function checkNormalize(message) {\n      if (_normalizeError) {\n        this.throwError(\"platform missing String.prototype.normalize\", Logger$1.errors.UNSUPPORTED_OPERATION, {\n          operation: \"String.prototype.normalize\",\n          form: _normalizeError\n        });\n      }\n    }\n  }, {\n    key: \"checkSafeUint53\",\n    value: function checkSafeUint53(value, message) {\n      if (typeof value !== \"number\") {\n        return;\n      }\n      if (message == null) {\n        message = \"value not safe\";\n      }\n      if (value < 0 || value >= 0x1fffffffffffff) {\n        this.throwError(message, Logger$1.errors.NUMERIC_FAULT, {\n          operation: \"checkSafeInteger\",\n          fault: \"out-of-safe-range\",\n          value: value\n        });\n      }\n      if (value % 1) {\n        this.throwError(message, Logger$1.errors.NUMERIC_FAULT, {\n          operation: \"checkSafeInteger\",\n          fault: \"non-integer\",\n          value: value\n        });\n      }\n    }\n  }, {\n    key: \"checkArgumentCount\",\n    value: function checkArgumentCount(count, expectedCount, message) {\n      if (message) {\n        message = \": \" + message;\n      } else {\n        message = \"\";\n      }\n      if (count < expectedCount) {\n        this.throwError(\"missing argument\" + message, Logger$1.errors.MISSING_ARGUMENT, {\n          count: count,\n          expectedCount: expectedCount\n        });\n      }\n      if (count > expectedCount) {\n        this.throwError(\"too many arguments\" + message, Logger$1.errors.UNEXPECTED_ARGUMENT, {\n          count: count,\n          expectedCount: expectedCount\n        });\n      }\n    }\n  }, {\n    key: \"checkNew\",\n    value: function checkNew(target, kind) {\n      if (target === Object || target == null) {\n        this.throwError(\"missing new\", Logger$1.errors.MISSING_NEW, {\n          name: kind.name\n        });\n      }\n    }\n  }, {\n    key: \"checkAbstract\",\n    value: function checkAbstract(target, kind) {\n      if (target === kind) {\n        this.throwError(\"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\", Logger$1.errors.UNSUPPORTED_OPERATION, {\n          name: target.name,\n          operation: \"new\"\n        });\n      } else if (target === Object || target == null) {\n        this.throwError(\"missing new\", Logger$1.errors.MISSING_NEW, {\n          name: kind.name\n        });\n      }\n    }\n  }], [{\n    key: \"globalLogger\",\n    value: function globalLogger() {\n      if (!_globalLogger) {\n        _globalLogger = new Logger$1(version$1);\n      }\n      return _globalLogger;\n    }\n  }, {\n    key: \"setCensorship\",\n    value: function setCensorship(censorship, permanent) {\n      if (!censorship && permanent) {\n        this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger$1.errors.UNSUPPORTED_OPERATION, {\n          operation: \"setCensorship\"\n        });\n      }\n      if (_permanentCensorErrors) {\n        if (!censorship) {\n          return;\n        }\n        this.globalLogger().throwError(\"error censorship permanent\", Logger$1.errors.UNSUPPORTED_OPERATION, {\n          operation: \"setCensorship\"\n        });\n      }\n      _censorErrors = !!censorship;\n      _permanentCensorErrors = !!permanent;\n    }\n  }, {\n    key: \"setLogLevel\",\n    value: function setLogLevel(logLevel) {\n      var level = LogLevels[logLevel.toLowerCase()];\n      if (level == null) {\n        Logger$1.globalLogger().warn(\"invalid log level - \" + logLevel);\n        return;\n      }\n      _logLevel = level;\n    }\n  }, {\n    key: \"from\",\n    value: function from(version) {\n      return new Logger$1(version);\n    }\n  }]);\n  return Logger$1;\n}();\nLogger$1.errors = ErrorCode;\nLogger$1.levels = LogLevel$1;\nvar version = \"properties/5.7.0\";\nvar __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar logger = new Logger$1(version);\nfunction defineReadOnly(object, name, value) {\n  Object.defineProperty(object, name, {\n    enumerable: true,\n    value: value,\n    writable: false\n  });\n}\nfunction resolveProperties(object) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n    var promises, results;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          promises = Object.keys(object).map(function (key) {\n            var value = object[key];\n            return Promise.resolve(value).then(function (v) {\n              return {\n                key: key,\n                value: v\n              };\n            });\n          });\n          _context3.next = 3;\n          return Promise.all(promises);\n        case 3:\n          results = _context3.sent;\n          return _context3.abrupt(\"return\", results.reduce(function (accum, result) {\n            accum[result.key] = result.value;\n            return accum;\n          }, {}));\n        case 5:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n}\nvar opaque = {\n  bigint: true,\n  boolean: true,\n  \"function\": true,\n  number: true,\n  string: true\n};\nfunction _isFrozen(object) {\n  // Opaque objects are not mutable, so safe to copy by assignment\n  if (object === undefined || object === null || opaque[typeof object]) {\n    return true;\n  }\n  if (Array.isArray(object) || typeof object === \"object\") {\n    if (!Object.isFrozen(object)) {\n      return false;\n    }\n    var keys = Object.keys(object);\n    for (var i = 0; i < keys.length; i++) {\n      var value = null;\n      try {\n        value = object[keys[i]];\n      } catch (error) {\n        // If accessing a value triggers an error, it is a getter\n        // designed to do so (e.g. Result) and is therefore \"frozen\"\n        continue;\n      }\n      if (!_isFrozen(value)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return logger.throwArgumentError(\"Cannot deepCopy \".concat(typeof object), \"object\", object);\n}\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object) {\n  if (_isFrozen(object)) {\n    return object;\n  }\n  // Arrays are mutable, so we need to create a copy\n  if (Array.isArray(object)) {\n    return Object.freeze(object.map(function (item) {\n      return deepCopy(item);\n    }));\n  }\n  if (typeof object === \"object\") {\n    var result = {};\n    for (var key in object) {\n      var value = object[key];\n      if (value === undefined) {\n        continue;\n      }\n      defineReadOnly(result, key, deepCopy(value));\n    }\n    return result;\n  }\n  return logger.throwArgumentError(\"Cannot deepCopy \".concat(typeof object), \"object\", object);\n}\nfunction deepCopy(object) {\n  return _deepCopy(object);\n}\n\n/**\r\n * Converts a hex string to a decimal number.\r\n *\r\n * @param hexString - The hex string to convert.\r\n * @public\r\n */\nfunction fromHex(hexString) {\n  return BigNumber.from(hexString).toNumber();\n}\n/**\r\n * Converts a number to a hex string.\r\n *\r\n * @param num - The number to convert to hex.\r\n * @public\r\n */\nfunction toHex(num) {\n  return BigNumber.from(num).toHexString();\n}\n/**\r\n * Checks if a value is a hex string.\r\n *\r\n * @param possibleHexString - The value to check.\r\n * @public\r\n */\nfunction isHex(possibleHexString) {\n  return /^0x[0-9a-fA-F]+$/.test(possibleHexString);\n}\nfunction formatBlock(block) {\n  if (typeof block === 'string') {\n    return block;\n  } else if (Number.isInteger(block)) {\n    return toHex(block);\n  }\n  return block.toString();\n}\nfunction stringToEnum(x, enumb) {\n  return Object.values(enumb).includes(x) ? x : undefined;\n}\nfunction getNftContractFromRaw(rawNftContract) {\n  return {\n    address: rawNftContract.address,\n    name: rawNftContract.contractMetadata.name,\n    symbol: rawNftContract.contractMetadata.symbol,\n    totalSupply: rawNftContract.contractMetadata.totalSupply,\n    tokenType: parseNftTokenType(rawNftContract.contractMetadata.tokenType),\n    openSea: parseOpenSeaMetadata(rawNftContract.contractMetadata.openSea),\n    contractDeployer: rawNftContract.contractMetadata.contractDeployer,\n    deployedBlockNumber: rawNftContract.contractMetadata.deployedBlockNumber\n  };\n}\nfunction getBaseNftFromRaw(rawBaseNft, contractAddress) {\n  var _a;\n  return {\n    contract: contractAddress ? {\n      address: contractAddress\n    } : rawBaseNft.contract,\n    tokenId: BigNumber.from(rawBaseNft.id.tokenId).toString(),\n    tokenType: parseNftTokenType((_a = rawBaseNft.id.tokenMetadata) === null || _a === void 0 ? void 0 : _a.tokenType)\n  };\n}\nfunction getNftFromRaw(rawNft) {\n  var _a, _b, _c, _d, _e, _f, _g;\n  try {\n    var tokenType = parseNftTokenType((_a = rawNft.id.tokenMetadata) === null || _a === void 0 ? void 0 : _a.tokenType);\n    var spamInfo = parseSpamInfo(rawNft.spamInfo);\n    return {\n      contract: {\n        address: rawNft.contract.address,\n        name: (_b = rawNft.contractMetadata) === null || _b === void 0 ? void 0 : _b.name,\n        symbol: (_c = rawNft.contractMetadata) === null || _c === void 0 ? void 0 : _c.symbol,\n        totalSupply: (_d = rawNft.contractMetadata) === null || _d === void 0 ? void 0 : _d.totalSupply,\n        tokenType: tokenType,\n        openSea: parseOpenSeaMetadata((_e = rawNft.contractMetadata) === null || _e === void 0 ? void 0 : _e.openSea),\n        contractDeployer: (_f = rawNft.contractMetadata) === null || _f === void 0 ? void 0 : _f.contractDeployer,\n        deployedBlockNumber: (_g = rawNft.contractMetadata) === null || _g === void 0 ? void 0 : _g.deployedBlockNumber\n      },\n      tokenId: parseNftTokenId(rawNft.id.tokenId),\n      tokenType: tokenType,\n      title: rawNft.title,\n      description: parseNftDescription(rawNft.description),\n      timeLastUpdated: rawNft.timeLastUpdated,\n      metadataError: rawNft.error,\n      rawMetadata: rawNft.metadata,\n      tokenUri: parseNftTokenUri(rawNft.tokenUri),\n      media: parseNftTokenUriArray(rawNft.media),\n      spamInfo: spamInfo,\n      acquiredAt: rawNft.acquiredAt\n    };\n  } catch (e) {\n    throw new Error('Error parsing the NFT response: ' + e);\n  }\n}\nfunction getNftSalesFromRaw(rawNftSales) {\n  var _a, _b;\n  return {\n    nftSales: rawNftSales.nftSales.map(function (rawNftSale) {\n      return {\n        marketplace: parseNftSaleMarketplace(rawNftSale.marketplace),\n        contractAddress: rawNftSale.contractAddress,\n        tokenId: rawNftSale.tokenId,\n        quantity: rawNftSale.quantity,\n        buyerAddress: rawNftSale.buyerAddress,\n        sellerAddress: rawNftSale.sellerAddress,\n        taker: parseNftTaker(rawNftSale.taker),\n        sellerFee: rawNftSale === null || rawNftSale === void 0 ? void 0 : rawNftSale.sellerFee,\n        marketplaceFee: rawNftSale === null || rawNftSale === void 0 ? void 0 : rawNftSale.protocolFee,\n        protocolFee: rawNftSale === null || rawNftSale === void 0 ? void 0 : rawNftSale.protocolFee,\n        royaltyFee: rawNftSale === null || rawNftSale === void 0 ? void 0 : rawNftSale.royaltyFee,\n        blockNumber: rawNftSale === null || rawNftSale === void 0 ? void 0 : rawNftSale.blockNumber,\n        logIndex: rawNftSale.logIndex,\n        bundleIndex: rawNftSale.bundleIndex,\n        transactionHash: rawNftSale.transactionHash\n      };\n    }),\n    validAt: {\n      blockNumber: rawNftSales.validAt.blockNumber,\n      blockHash: (_a = rawNftSales.validAt.blockHash) !== null && _a !== void 0 ? _a : undefined,\n      blockTimestamp: (_b = rawNftSales.validAt.blockTimestamp) !== null && _b !== void 0 ? _b : undefined\n    },\n    pageKey: rawNftSales === null || rawNftSales === void 0 ? void 0 : rawNftSales.pageKey\n  };\n}\nfunction parseNftSaleMarketplace(marketplace) {\n  switch (marketplace) {\n    case 'looksrare':\n      return NftSaleMarketplace.LOOKSRARE;\n    case 'seaport':\n      return NftSaleMarketplace.SEAPORT;\n    case 'x2y2':\n      return NftSaleMarketplace.X2Y2;\n    case 'wyvern':\n      return NftSaleMarketplace.WYVERN;\n    case 'cryptopunks':\n      return NftSaleMarketplace.CRYPTOPUNKS;\n    case 'blur':\n      return NftSaleMarketplace.BLUR;\n    default:\n      return NftSaleMarketplace.UNKNOWN;\n  }\n}\nfunction parseNftTaker(taker) {\n  // The `.toLowerCase()` call is needed because the API returns the capitalized values\n  switch (taker.toLowerCase()) {\n    case 'buyer':\n      return NftSaleTakerType.BUYER;\n    case 'seller':\n      return NftSaleTakerType.SELLER;\n    default:\n      throw new Error(\"Unsupported NftSaleTakerType \".concat(taker));\n  }\n}\nfunction getNftRarityFromRaw(rawNftRarity) {\n  return rawNftRarity.map(function (_ref) {\n    var prevalence = _ref.prevalence,\n      trait_type = _ref.trait_type,\n      value = _ref.value;\n    return {\n      prevalence: prevalence,\n      traitType: trait_type,\n      value: value\n    };\n  });\n}\nfunction getContractsForOwnerFromRaw(rawContractsForOwner) {\n  return {\n    pageKey: rawContractsForOwner === null || rawContractsForOwner === void 0 ? void 0 : rawContractsForOwner.pageKey,\n    totalCount: rawContractsForOwner.totalCount,\n    contracts: rawContractsForOwner.contracts.map(function (contract) {\n      return {\n        address: contract.address,\n        totalSupply: contract.totalSupply,\n        isSpam: contract.isSpam,\n        media: contract.media,\n        numDistinctTokensOwned: contract.numDistinctTokensOwned,\n        tokenId: contract.tokenId,\n        totalBalance: contract.totalBalance,\n        name: contract.name,\n        title: contract.title,\n        openSea: parseOpenSeaMetadata(contract === null || contract === void 0 ? void 0 : contract.opensea),\n        symbol: contract === null || contract === void 0 ? void 0 : contract.symbol,\n        tokenType: parseNftTokenType(contract === null || contract === void 0 ? void 0 : contract.tokenType),\n        contractDeployer: contract.contractDeployer,\n        deployedBlockNumber: contract.deployedBlockNumber\n      };\n    })\n  };\n}\nfunction parseNftTokenId(tokenId) {\n  // We have to normalize the token id here since the backend sometimes\n  // returns the token ID as a hex string and sometimes as an integer.\n  return BigNumber.from(tokenId).toString();\n}\nfunction parseNftTokenType(tokenType) {\n  switch (tokenType) {\n    case 'erc721':\n    case 'ERC721':\n      return NftTokenType.ERC721;\n    case 'erc1155':\n    case 'ERC1155':\n      return NftTokenType.ERC1155;\n    case 'no_supported_nft_standard':\n    case 'NO_SUPPORTED_NFT_STANDARD':\n      return NftTokenType.NO_SUPPORTED_NFT_STANDARD;\n    case 'not_a_contract':\n    case 'NOT_A_CONTRACT':\n      return NftTokenType.NOT_A_CONTRACT;\n    default:\n      return NftTokenType.UNKNOWN;\n  }\n}\nfunction parseSpamInfo(spamInfo) {\n  if (!spamInfo) {\n    return undefined;\n  }\n  var isSpam = spamInfo.isSpam,\n    classifications = spamInfo.classifications;\n  return {\n    isSpam: isSpam === 'true',\n    classifications: classifications\n  };\n}\nfunction parseNftDescription(description) {\n  if (description === undefined) {\n    return '';\n  }\n  // TODO: Remove after backend adds JSON stringification.\n  if (!Array.isArray(description) && typeof description === 'object') {\n    return JSON.stringify(description);\n  }\n  return typeof description === 'string' ? description : description.join(' ');\n}\nfunction parseNftTokenUri(uri) {\n  if (uri && uri.raw.length === 0 && uri.gateway.length == 0) {\n    return undefined;\n  }\n  return uri;\n}\nfunction parseNftTokenUriArray(arr) {\n  if (arr === undefined) {\n    return [];\n  }\n  return arr.filter(function (uri) {\n    return parseNftTokenUri(uri) !== undefined;\n  });\n}\nfunction parseOpenSeaMetadata(openSea) {\n  if (openSea === undefined) {\n    return undefined;\n  }\n  return {\n    floorPrice: openSea.floorPrice,\n    collectionName: openSea.collectionName,\n    safelistRequestStatus: openSea.safelistRequestStatus !== undefined ? stringToEnum(openSea.safelistRequestStatus, OpenSeaSafelistRequestStatus) : undefined,\n    imageUrl: openSea.imageUrl,\n    description: openSea.description,\n    externalUrl: openSea.externalUrl,\n    twitterUsername: openSea.twitterUsername,\n    discordUrl: openSea.discordUrl,\n    lastIngestedAt: openSea.lastIngestedAt\n  };\n}\nvar IS_BROWSER = typeof window !== 'undefined' && window !== null;\n/** Recursively converts all `null` fields to `undefined. */\n// TODO: Add typing support so it doesn't return `any`.\nfunction nullsToUndefined(obj) {\n  if (obj === null) {\n    return undefined;\n  }\n  // if `obj` is an object, recursively convert all `null` fields to `undefined`.\n  if (typeof obj === 'object') {\n    for (var key in obj) {\n      obj[key] = nullsToUndefined(obj[key]);\n    }\n  }\n  return obj;\n}\n\n/**\r\n * This file contains the underlying implementations for exposed API surface in\r\n * the {@link CoreNamespace}. By moving the methods out into a separate file,\r\n * other namespaces can access these methods without depending on the entire\r\n * CoreNamespace, or override the `srcMethod` param used for logging.\r\n */\n/**\r\n * Gets the asset transfers for the provided params.\r\n */\nfunction _getAssetTransfers(config, params) {\n  var srcMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'getAssetTransfers';\n  return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n    var provider;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          _context4.next = 2;\n          return config.getProvider();\n        case 2:\n          provider = _context4.sent;\n          if (!params.fromAddress) {\n            _context4.next = 7;\n            break;\n          }\n          _context4.next = 6;\n          return provider._getAddress(params.fromAddress);\n        case 6:\n          params.fromAddress = _context4.sent;\n        case 7:\n          if (!params.toAddress) {\n            _context4.next = 11;\n            break;\n          }\n          _context4.next = 10;\n          return provider._getAddress(params.toAddress);\n        case 10:\n          params.toAddress = _context4.sent;\n        case 11:\n          return _context4.abrupt(\"return\", provider._send('alchemy_getAssetTransfers', [Object.assign(Object.assign({}, params), {\n            fromBlock: params.fromBlock != null ? formatBlock(params.fromBlock) : undefined,\n            toBlock: params.toBlock != null ? formatBlock(params.toBlock) : undefined,\n            maxCount: params.maxCount != null ? toHex(params.maxCount) : undefined\n          })], srcMethod));\n        case 12:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4);\n  }));\n}\nfunction _getTransactionReceipts(config, params) {\n  var srcMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'getTransactionReceipts';\n  return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n    var provider;\n    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n      while (1) switch (_context5.prev = _context5.next) {\n        case 0:\n          _context5.next = 2;\n          return config.getProvider();\n        case 2:\n          provider = _context5.sent;\n          return _context5.abrupt(\"return\", provider._send('alchemy_getTransactionReceipts', [params], srcMethod));\n        case 4:\n        case \"end\":\n          return _context5.stop();\n      }\n    }, _callee5);\n  }));\n}\n/**\r\n * This method is based on the ethers implementation of getLogs, but is expanded\r\n * to support specifying an address array in the filter.\r\n *\r\n * The main modifications made to support an address array are:\r\n * - Custom `getFilter()` method that supports an address array\r\n * - Use of `arrayOf()` formatter to format the logs to avoid the `Formatter` import.\r\n * - Use of `provider.send()` to avoid formatting logic in `provider.perform()`.\r\n */\nfunction _getLogs(config, filter) {\n  return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n    var provider, params, logs;\n    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n      while (1) switch (_context6.prev = _context6.next) {\n        case 0:\n          _context6.next = 2;\n          return config.getProvider();\n        case 2:\n          provider = _context6.sent;\n          _context6.next = 5;\n          return provider.getNetwork();\n        case 5:\n          _context6.next = 7;\n          return resolveProperties({\n            filter: getFilter(config, filter)\n          });\n        case 7:\n          params = _context6.sent;\n          _context6.next = 10;\n          return provider.send('eth_getLogs', [params.filter]);\n        case 10:\n          logs = _context6.sent;\n          logs.forEach(function (log) {\n            if (log.removed == null) {\n              log.removed = false;\n            }\n          });\n          return _context6.abrupt(\"return\", arrayOf(provider.formatter.filterLog.bind(provider.formatter))(logs));\n        case 13:\n        case \"end\":\n          return _context6.stop();\n      }\n    }, _callee6);\n  }));\n}\n/**\r\n * This method is based on and copied from the ethers implementation of\r\n * `JsonRpcProvider._getFilter()`, but is extended to support an address array.\r\n *\r\n * This implementation is a hacky way to get around the ethers formatter. The\r\n * formatter is used to check the types of the `filter` params, but ethers does\r\n * not allow an array in the `address` field. To preserve the ethers formatter\r\n * on the other fields, we use the formatter to check the types of those other\r\n * fields, and then manually check the `address` field last.\r\n */\nfunction getFilter(config, filter) {\n  return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n    var _this3 = this;\n    var provider, resolvedFilter, result;\n    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n      while (1) switch (_context8.prev = _context8.next) {\n        case 0:\n          _context8.next = 2;\n          return config.getProvider();\n        case 2:\n          provider = _context8.sent;\n          _context8.next = 5;\n          return filter;\n        case 5:\n          resolvedFilter = _context8.sent;\n          result = {}; // END MODIFIED CODE\n          ['blockHash', 'topics'].forEach(function (key) {\n            if (resolvedFilter[key] == null) {\n              return;\n            }\n            result[key] = resolvedFilter[key];\n          });\n          ['fromBlock', 'toBlock'].forEach(function (key) {\n            if (resolvedFilter[key] == null) {\n              return;\n            }\n            result[key] = provider._getBlockTag(resolvedFilter[key]);\n          });\n          // BEGIN MODIFIED CODE\n          // Format the `result` object using the ethers formatter without the `address`\n          // field.\n          _context8.t0 = provider.formatter;\n          _context8.next = 12;\n          return resolveProperties(result);\n        case 12:\n          _context8.t1 = _context8.sent;\n          result = _context8.t0.filter.call(_context8.t0, _context8.t1);\n          if (!Array.isArray(resolvedFilter.address)) {\n            _context8.next = 20;\n            break;\n          }\n          _context8.next = 17;\n          return Promise.all(resolvedFilter.address.map(function (address) {\n            return __awaiter$1(_this3, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n              return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n                while (1) switch (_context7.prev = _context7.next) {\n                  case 0:\n                    return _context7.abrupt(\"return\", provider._getAddress(address));\n                  case 1:\n                  case \"end\":\n                    return _context7.stop();\n                }\n              }, _callee7);\n            }));\n          }));\n        case 17:\n          result.address = _context8.sent;\n          _context8.next = 24;\n          break;\n        case 20:\n          if (!(resolvedFilter.address != null)) {\n            _context8.next = 24;\n            break;\n          }\n          _context8.next = 23;\n          return provider._getAddress(resolvedFilter.address);\n        case 23:\n          result.address = _context8.sent;\n        case 24:\n          return _context8.abrupt(\"return\", result);\n        case 25:\n        case \"end\":\n          return _context8.stop();\n      }\n    }, _callee8);\n  }));\n}\n/**\r\n * DO NOT MODIFY.\r\n *\r\n * This function is directly copied over from ethers implementation of\r\n * `Formatter.arrayOf()`. It is copied here to avoid having to import the\r\n * `Formatter` class or `FormatterFunc` type from ethers, that are not part of\r\n * the default export.\r\n *\r\n * This function returns a function that applies the formatter to an array of\r\n * values, and is used to format the logs returned by `getLogs()`.\r\n */\nfunction arrayOf(format) {\n  return function (array) {\n    if (!Array.isArray(array)) {\n      throw new Error('not an array');\n    }\n    var result = [];\n    array.forEach(function (value) {\n      result.push(format(value));\n    });\n    return result;\n  };\n}\n\n/**\r\n * The core namespace contains all commonly-used [Ethers.js\r\n * Provider](https://docs.ethers.io/v5/api/providers/api-providers/#AlchemyProvider)\r\n * methods. If you are already using Ethers.js, you should be simply able to\r\n * replace the Ethers.js Provider object with `alchemy.core` when accessing\r\n * provider methods and it should just work.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an Alchemy object\r\n * with `const alchemy = new Alchemy(config)` and then access the core namespace\r\n * via `alchemy.core`.\r\n */\nvar CoreNamespace = /*#__PURE__*/function () {\n  /** @internal */\n  function CoreNamespace(config) {\n    _classCallCheck(this, CoreNamespace);\n    this.config = config;\n  }\n  /**\r\n   * Returns the balance of a given address as of the provided block.\r\n   *\r\n   * @param addressOrName The address or name of the account to get the balance for.\r\n   * @param blockTag The optional block number or hash to get the balance for.\r\n   *   Defaults to 'latest' if unspecified.\r\n   * @public\r\n   */\n  _createClass(CoreNamespace, [{\n    key: \"getBalance\",\n    value: function getBalance(addressOrName, blockTag) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        var provider;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              _context9.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context9.sent;\n              return _context9.abrupt(\"return\", provider.getBalance(addressOrName, blockTag));\n            case 4:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this);\n      }));\n    }\n    /**\r\n     * Checks if the provided address is a smart contract.\r\n     *\r\n     * @param address The address to check type for.\r\n     * @public\r\n     */\n  }, {\n    key: \"isContractAddress\",\n    value: function isContractAddress(address) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var provider, code;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              _context10.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context10.sent;\n              _context10.next = 5;\n              return provider.getCode(address);\n            case 5:\n              code = _context10.sent;\n              return _context10.abrupt(\"return\", code !== '0x');\n            case 7:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, this);\n      }));\n    }\n    /**\r\n     * Returns the contract code of the provided address at the block. If there is\r\n     * no contract deployed, the result is `0x`.\r\n     *\r\n     * @param addressOrName The address or name of the account to get the code for.\r\n     * @param blockTag The optional block number or hash to get the code for.\r\n     *   Defaults to 'latest' if unspecified.\r\n     * @public\r\n     */\n  }, {\n    key: \"getCode\",\n    value: function getCode(addressOrName, blockTag) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        var provider;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              _context11.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context11.sent;\n              return _context11.abrupt(\"return\", provider.getCode(addressOrName, blockTag));\n            case 4:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11, this);\n      }));\n    }\n    /**\r\n     * Return the value of the provided position at the provided address, at the\r\n     * provided block in `Bytes32` format.\r\n     *\r\n     * @param addressOrName The address or name of the account to get the code for.\r\n     * @param position The position of the storage slot to get.\r\n     * @param blockTag The optional block number or hash to get the code for.\r\n     *   Defaults to 'latest' if unspecified.\r\n     * @public\r\n     */\n  }, {\n    key: \"getStorageAt\",\n    value: function getStorageAt(addressOrName, position, blockTag) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n        var provider;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              _context12.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context12.sent;\n              return _context12.abrupt(\"return\", provider.getStorageAt(addressOrName, position, blockTag));\n            case 4:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee12, this);\n      }));\n    }\n    /**\r\n     * Returns the number of transactions ever sent from the provided address, as\r\n     * of the provided block tag. This value is used as the nonce for the next\r\n     * transaction from the address sent to the network.\r\n     *\r\n     * @param addressOrName The address or name of the account to get the nonce for.\r\n     * @param blockTag The optional block number or hash to get the nonce for.\r\n     * @public\r\n     */\n  }, {\n    key: \"getTransactionCount\",\n    value: function getTransactionCount(addressOrName, blockTag) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {\n        var provider;\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) switch (_context13.prev = _context13.next) {\n            case 0:\n              _context13.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context13.sent;\n              return _context13.abrupt(\"return\", provider.getTransactionCount(addressOrName, blockTag));\n            case 4:\n            case \"end\":\n              return _context13.stop();\n          }\n        }, _callee13, this);\n      }));\n    }\n    /**\r\n     * Returns the block from the network based on the provided block number or\r\n     * hash. Transactions on the block are represented as an array of transaction\r\n     * hashes. To get the full transaction details on the block, use\r\n     * {@link getBlockWithTransactions} instead.\r\n     *\r\n     * @param blockHashOrBlockTag The block number or hash to get the block for.\r\n     * @public\r\n     */\n  }, {\n    key: \"getBlock\",\n    value: function getBlock(blockHashOrBlockTag) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {\n        var provider;\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) switch (_context14.prev = _context14.next) {\n            case 0:\n              _context14.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context14.sent;\n              return _context14.abrupt(\"return\", provider.getBlock(blockHashOrBlockTag));\n            case 4:\n            case \"end\":\n              return _context14.stop();\n          }\n        }, _callee14, this);\n      }));\n    }\n    /**\r\n     * Returns the block from the network based on the provided block number or\r\n     * hash. Transactions on the block are represented as an array of\r\n     * {@link TransactionResponse} objects.\r\n     *\r\n     * @param blockHashOrBlockTag The block number or hash to get the block for.\r\n     * @public\r\n     */\n  }, {\n    key: \"getBlockWithTransactions\",\n    value: function getBlockWithTransactions(blockHashOrBlockTag) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {\n        var provider;\n        return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n          while (1) switch (_context15.prev = _context15.next) {\n            case 0:\n              _context15.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context15.sent;\n              return _context15.abrupt(\"return\", provider.getBlockWithTransactions(blockHashOrBlockTag));\n            case 4:\n            case \"end\":\n              return _context15.stop();\n          }\n        }, _callee15, this);\n      }));\n    }\n    /**\r\n     * Returns the {@link EthersNetworkAlias} Alchemy is connected to.\r\n     *\r\n     * @public\r\n     */\n  }, {\n    key: \"getNetwork\",\n    value: function getNetwork() {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {\n        var provider;\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) switch (_context16.prev = _context16.next) {\n            case 0:\n              _context16.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context16.sent;\n              return _context16.abrupt(\"return\", provider.getNetwork());\n            case 4:\n            case \"end\":\n              return _context16.stop();\n          }\n        }, _callee16, this);\n      }));\n    }\n    /**\r\n     * Returns the block number of the most recently mined block.\r\n     *\r\n     * @public\r\n     */\n  }, {\n    key: \"getBlockNumber\",\n    value: function getBlockNumber() {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {\n        var provider;\n        return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n          while (1) switch (_context17.prev = _context17.next) {\n            case 0:\n              _context17.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context17.sent;\n              return _context17.abrupt(\"return\", provider.getBlockNumber());\n            case 4:\n            case \"end\":\n              return _context17.stop();\n          }\n        }, _callee17, this);\n      }));\n    }\n    /**\r\n     * Returns the best guess of the current gas price to use in a transaction.\r\n     *\r\n     * @public\r\n     */\n  }, {\n    key: \"getGasPrice\",\n    value: function getGasPrice() {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {\n        var provider;\n        return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n          while (1) switch (_context18.prev = _context18.next) {\n            case 0:\n              _context18.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context18.sent;\n              return _context18.abrupt(\"return\", provider.getGasPrice());\n            case 4:\n            case \"end\":\n              return _context18.stop();\n          }\n        }, _callee18, this);\n      }));\n    }\n    /**\r\n     * Returns the recommended fee data to use in a transaction.\r\n     *\r\n     * For an EIP-1559 transaction, the maxFeePerGas and maxPriorityFeePerGas\r\n     * should be used.\r\n     *\r\n     * For legacy transactions and networks which do not support EIP-1559, the\r\n     * gasPrice should be used.\r\n     *\r\n     * @public\r\n     */\n  }, {\n    key: \"getFeeData\",\n    value: function getFeeData() {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee19() {\n        var provider;\n        return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n          while (1) switch (_context19.prev = _context19.next) {\n            case 0:\n              _context19.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context19.sent;\n              return _context19.abrupt(\"return\", provider.getFeeData());\n            case 4:\n            case \"end\":\n              return _context19.stop();\n          }\n        }, _callee19, this);\n      }));\n    }\n    /**\r\n     * Returns a Promise which will stall until the network has heen established,\r\n     * ignoring errors due to the target node not being active yet.\r\n     *\r\n     * This can be used for testing or attaching scripts to wait until the node is\r\n     * up and running smoothly.\r\n     *\r\n     * @public\r\n     */\n  }, {\n    key: \"ready\",\n    value: function ready() {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee20() {\n        var provider;\n        return _regeneratorRuntime().wrap(function _callee20$(_context20) {\n          while (1) switch (_context20.prev = _context20.next) {\n            case 0:\n              _context20.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context20.sent;\n              return _context20.abrupt(\"return\", provider.ready);\n            case 4:\n            case \"end\":\n              return _context20.stop();\n          }\n        }, _callee20, this);\n      }));\n    }\n    /**\r\n     * Returns the result of executing the transaction, using call. A call does\r\n     * not require any ether, but cannot change any state. This is useful for\r\n     * calling getters on Contracts.\r\n     *\r\n     * @param transaction The transaction to execute.\r\n     * @param blockTag The optional block number or hash to get the call for.\r\n     * @public\r\n     */\n  }, {\n    key: \"call\",\n    value: function call(transaction, blockTag) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee21() {\n        var provider;\n        return _regeneratorRuntime().wrap(function _callee21$(_context21) {\n          while (1) switch (_context21.prev = _context21.next) {\n            case 0:\n              _context21.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context21.sent;\n              return _context21.abrupt(\"return\", provider.call(transaction, blockTag));\n            case 4:\n            case \"end\":\n              return _context21.stop();\n          }\n        }, _callee21, this);\n      }));\n    }\n    /**\r\n     * Returns an estimate of the amount of gas that would be required to submit\r\n     * transaction to the network.\r\n     *\r\n     * An estimate may not be accurate since there could be another transaction on\r\n     * the network that was not accounted for, but after being mined affects the\r\n     * relevant state.\r\n     *\r\n     * This is an alias for {@link TransactNamespace.estimateGas}.\r\n     *\r\n     * @param transaction The transaction to estimate gas for.\r\n     * @public\r\n     */\n  }, {\n    key: \"estimateGas\",\n    value: function estimateGas(transaction) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee22() {\n        var provider;\n        return _regeneratorRuntime().wrap(function _callee22$(_context22) {\n          while (1) switch (_context22.prev = _context22.next) {\n            case 0:\n              _context22.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context22.sent;\n              return _context22.abrupt(\"return\", provider.estimateGas(transaction));\n            case 4:\n            case \"end\":\n              return _context22.stop();\n          }\n        }, _callee22, this);\n      }));\n    }\n    /**\r\n     * Returns the transaction with hash or null if the transaction is unknown.\r\n     *\r\n     * If a transaction has not been mined, this method will search the\r\n     * transaction pool. Various backends may have more restrictive transaction\r\n     * pool access (e.g. if the gas price is too low or the transaction was only\r\n     * recently sent and not yet indexed) in which case this method may also return null.\r\n     *\r\n     * NOTE: This is an alias for {@link TransactNamespace.getTransaction}.\r\n     *\r\n     * @param transactionHash The hash of the transaction to get.\r\n     * @public\r\n     */\n  }, {\n    key: \"getTransaction\",\n    value: function getTransaction(transactionHash) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee23() {\n        var provider;\n        return _regeneratorRuntime().wrap(function _callee23$(_context23) {\n          while (1) switch (_context23.prev = _context23.next) {\n            case 0:\n              _context23.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context23.sent;\n              return _context23.abrupt(\"return\", provider.getTransaction(transactionHash));\n            case 4:\n            case \"end\":\n              return _context23.stop();\n          }\n        }, _callee23, this);\n      }));\n    }\n    /**\r\n     * Returns the transaction receipt for hash or null if the transaction has not\r\n     * been mined.\r\n     *\r\n     * To stall until the transaction has been mined, consider the\r\n     * waitForTransaction method below.\r\n     *\r\n     * @param transactionHash The hash of the transaction to get.\r\n     * @public\r\n     */\n  }, {\n    key: \"getTransactionReceipt\",\n    value: function getTransactionReceipt(transactionHash) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee24() {\n        var provider;\n        return _regeneratorRuntime().wrap(function _callee24$(_context24) {\n          while (1) switch (_context24.prev = _context24.next) {\n            case 0:\n              _context24.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context24.sent;\n              return _context24.abrupt(\"return\", provider.getTransactionReceipt(transactionHash));\n            case 4:\n            case \"end\":\n              return _context24.stop();\n          }\n        }, _callee24, this);\n      }));\n    }\n    /**\r\n     * Submits transaction to the network to be mined. The transaction must be\r\n     * signed, and be valid (i.e. the nonce is correct and the account has\r\n     * sufficient balance to pay for the transaction).\r\n     *\r\n     * NOTE: This is an alias for {@link TransactNamespace.getTransaction}.\r\n     *\r\n     * @param signedTransaction The signed transaction to send.\r\n     * @public\r\n     */\n  }, {\n    key: \"sendTransaction\",\n    value: function sendTransaction(signedTransaction) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee25() {\n        var provider;\n        return _regeneratorRuntime().wrap(function _callee25$(_context25) {\n          while (1) switch (_context25.prev = _context25.next) {\n            case 0:\n              _context25.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context25.sent;\n              return _context25.abrupt(\"return\", provider.sendTransaction(signedTransaction));\n            case 4:\n            case \"end\":\n              return _context25.stop();\n          }\n        }, _callee25, this);\n      }));\n    }\n    /**\r\n     * Returns a promise which will not resolve until specified transaction hash is mined.\r\n     *\r\n     * If {@link confirmations} is 0, this method is non-blocking and if the\r\n     * transaction has not been mined returns null. Otherwise, this method will\r\n     * block until the transaction has confirmed blocks mined on top of the block\r\n     * in which it was mined.\r\n     *\r\n     * NOTE: This is an alias for {@link TransactNamespace.getTransaction}.\r\n     *\r\n     * @param transactionHash The hash of the transaction to wait for.\r\n     * @param confirmations The number of blocks to wait for.\r\n     * @param timeout The maximum time to wait for the transaction to confirm.\r\n     * @public\r\n     */\n  }, {\n    key: \"waitForTransaction\",\n    value: function waitForTransaction(transactionHash, confirmations, timeout) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee26() {\n        var provider;\n        return _regeneratorRuntime().wrap(function _callee26$(_context26) {\n          while (1) switch (_context26.prev = _context26.next) {\n            case 0:\n              _context26.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context26.sent;\n              return _context26.abrupt(\"return\", provider.waitForTransaction(transactionHash, confirmations, timeout));\n            case 4:\n            case \"end\":\n              return _context26.stop();\n          }\n        }, _callee26, this);\n      }));\n    }\n    /**\r\n     * Returns an array of logs that match the provided filter.\r\n     *\r\n     * @param filter The filter object to use.\r\n     * @public\r\n     */\n  }, {\n    key: \"getLogs\",\n    value: function getLogs(filter) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee27() {\n        return _regeneratorRuntime().wrap(function _callee27$(_context27) {\n          while (1) switch (_context27.prev = _context27.next) {\n            case 0:\n              return _context27.abrupt(\"return\", _getLogs(this.config, filter));\n            case 1:\n            case \"end\":\n              return _context27.stop();\n          }\n        }, _callee27, this);\n      }));\n    }\n    /**\r\n     * Allows sending a raw message to the Alchemy backend.\r\n     *\r\n     * @param method The method to call.\r\n     * @param params The parameters to pass to the method.\r\n     * @public\r\n     */\n  }, {\n    key: \"send\",\n    value: function send(method, params) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee28() {\n        var provider;\n        return _regeneratorRuntime().wrap(function _callee28$(_context28) {\n          while (1) switch (_context28.prev = _context28.next) {\n            case 0:\n              _context28.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context28.sent;\n              return _context28.abrupt(\"return\", provider.send(method, params));\n            case 4:\n            case \"end\":\n              return _context28.stop();\n          }\n        }, _callee28, this);\n      }));\n    }\n    /**\r\n     * Finds the address that deployed the provided contract and block number it\r\n     * was deployed in.\r\n     *\r\n     * NOTE: This method performs a binary search across all blocks since genesis\r\n     * and can take a long time to complete. This method is a convenience method\r\n     * that will eventually be replaced by a single call to an Alchemy endpoint\r\n     * with this information cached.\r\n     *\r\n     * @param contractAddress - The contract address to find the deployer for.\r\n     * @beta\r\n     */\n  }, {\n    key: \"findContractDeployer\",\n    value: function findContractDeployer(contractAddress) {\n      var _a;\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee29() {\n        var provider, currentBlockNum, firstBlock, txReceipts, matchingReceipt;\n        return _regeneratorRuntime().wrap(function _callee29$(_context29) {\n          while (1) switch (_context29.prev = _context29.next) {\n            case 0:\n              _context29.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context29.sent;\n              _context29.next = 5;\n              return provider.getBlockNumber();\n            case 5:\n              currentBlockNum = _context29.sent;\n              _context29.next = 8;\n              return provider.getCode(contractAddress, currentBlockNum);\n            case 8:\n              _context29.t0 = _context29.sent;\n              _context29.t1 = ETH_NULL_VALUE;\n              if (!(_context29.t0 === _context29.t1)) {\n                _context29.next = 12;\n                break;\n              }\n              throw new Error(\"Contract '\".concat(contractAddress, \"' does not exist\"));\n            case 12:\n              _context29.next = 14;\n              return binarySearchFirstBlock(0, currentBlockNum + 1, contractAddress, this.config);\n            case 14:\n              firstBlock = _context29.sent;\n              _context29.next = 17;\n              return _getTransactionReceipts(this.config, {\n                blockNumber: toHex(firstBlock)\n              }, 'findContractDeployer');\n            case 17:\n              txReceipts = _context29.sent;\n              matchingReceipt = (_a = txReceipts.receipts) === null || _a === void 0 ? void 0 : _a.find(function (receipt) {\n                return receipt.contractAddress === contractAddress.toLowerCase();\n              });\n              return _context29.abrupt(\"return\", {\n                deployerAddress: matchingReceipt === null || matchingReceipt === void 0 ? void 0 : matchingReceipt.from,\n                blockNumber: firstBlock\n              });\n            case 20:\n            case \"end\":\n              return _context29.stop();\n          }\n        }, _callee29, this);\n      }));\n    }\n  }, {\n    key: \"getTokenBalances\",\n    value: function getTokenBalances(addressOrName, contractAddressesOrOptions) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee30() {\n        var provider, address, tokenType, params;\n        return _regeneratorRuntime().wrap(function _callee30$(_context30) {\n          while (1) switch (_context30.prev = _context30.next) {\n            case 0:\n              _context30.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context30.sent;\n              _context30.next = 5;\n              return provider._getAddress(addressOrName);\n            case 5:\n              address = _context30.sent;\n              if (!Array.isArray(contractAddressesOrOptions)) {\n                _context30.next = 14;\n                break;\n              }\n              if (!(contractAddressesOrOptions.length > 1500)) {\n                _context30.next = 9;\n                break;\n              }\n              throw new Error('You cannot pass in more than 1500 contract addresses to getTokenBalances()');\n            case 9:\n              if (!(contractAddressesOrOptions.length === 0)) {\n                _context30.next = 11;\n                break;\n              }\n              throw new Error('getTokenBalances() requires at least one contractAddress when using an array');\n            case 11:\n              return _context30.abrupt(\"return\", provider._send('alchemy_getTokenBalances', [address, contractAddressesOrOptions], 'getTokenBalances'));\n            case 14:\n              tokenType = contractAddressesOrOptions === undefined ? TokenBalanceType.ERC20 : contractAddressesOrOptions.type;\n              params = [address, tokenType];\n              if ((contractAddressesOrOptions === null || contractAddressesOrOptions === void 0 ? void 0 : contractAddressesOrOptions.type) === TokenBalanceType.ERC20 && contractAddressesOrOptions.pageKey) {\n                params.push({\n                  pageKey: contractAddressesOrOptions.pageKey\n                });\n              }\n              return _context30.abrupt(\"return\", provider._send('alchemy_getTokenBalances', params, 'getTokenBalances'));\n            case 18:\n            case \"end\":\n              return _context30.stop();\n          }\n        }, _callee30, this);\n      }));\n    }\n    /**\r\n     * Returns the tokens that the specified address owns, along with the amount\r\n     * of each token and the relevant metadata.\r\n     *\r\n     * @param addressOrName The owner address to get the tokens with balances for.\r\n     * @param options Additional options to pass to the request.\r\n     * @public\r\n     */\n  }, {\n    key: \"getTokensForOwner\",\n    value: function getTokensForOwner(addressOrName, options) {\n      var _a;\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee31() {\n        var provider, address, params, response, formattedBalances, metadataPromises, metadata, ownedTokens;\n        return _regeneratorRuntime().wrap(function _callee31$(_context31) {\n          while (1) switch (_context31.prev = _context31.next) {\n            case 0:\n              _context31.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context31.sent;\n              _context31.next = 5;\n              return provider._getAddress(addressOrName);\n            case 5:\n              address = _context31.sent;\n              params = [address, (_a = options === null || options === void 0 ? void 0 : options.contractAddresses) !== null && _a !== void 0 ? _a : TokenBalanceType.ERC20];\n              if (options === null || options === void 0 ? void 0 : options.pageKey) {\n                params.push({\n                  pageKey: options.pageKey\n                });\n              }\n              _context31.next = 10;\n              return provider._send('alchemy_getTokenBalances', params, 'getTokensForOwner');\n            case 10:\n              response = _context31.sent;\n              formattedBalances = response.tokenBalances.map(function (balance) {\n                return {\n                  contractAddress: balance.contractAddress,\n                  rawBalance: BigNumber.from(balance.tokenBalance).toString()\n                };\n              });\n              _context31.next = 14;\n              return Promise.allSettled(response.tokenBalances.map(function (token) {\n                return provider._send('alchemy_getTokenMetadata', [token.contractAddress], 'getTokensForOwner', /* forceBatch= */true);\n              }));\n            case 14:\n              metadataPromises = _context31.sent;\n              metadata = metadataPromises.map(function (p) {\n                return p.status === 'fulfilled' ? p.value : {\n                  name: null,\n                  symbol: null,\n                  decimals: null,\n                  logo: null\n                };\n              });\n              ownedTokens = formattedBalances.map(function (balance, index) {\n                return Object.assign(Object.assign(Object.assign({}, balance), metadata[index]), {\n                  balance: metadata[index].decimals !== null ? formatUnits(balance.rawBalance, metadata[index].decimals) : undefined\n                });\n              });\n              return _context31.abrupt(\"return\", {\n                tokens: ownedTokens.map(nullsToUndefined),\n                pageKey: response.pageKey\n              });\n            case 18:\n            case \"end\":\n              return _context31.stop();\n          }\n        }, _callee31, this);\n      }));\n    }\n    /**\r\n     * Returns metadata for a given token contract address.\r\n     *\r\n     * @param address The contract address to get metadata for.\r\n     * @public\r\n     */\n  }, {\n    key: \"getTokenMetadata\",\n    value: function getTokenMetadata(address) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee32() {\n        var provider;\n        return _regeneratorRuntime().wrap(function _callee32$(_context32) {\n          while (1) switch (_context32.prev = _context32.next) {\n            case 0:\n              _context32.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context32.sent;\n              return _context32.abrupt(\"return\", provider._send('alchemy_getTokenMetadata', [address], 'getTokenMetadata'));\n            case 4:\n            case \"end\":\n              return _context32.stop();\n          }\n        }, _callee32, this);\n      }));\n    }\n  }, {\n    key: \"getAssetTransfers\",\n    value: function getAssetTransfers(params) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee33() {\n        return _regeneratorRuntime().wrap(function _callee33$(_context33) {\n          while (1) switch (_context33.prev = _context33.next) {\n            case 0:\n              return _context33.abrupt(\"return\", _getAssetTransfers(this.config, params));\n            case 1:\n            case \"end\":\n              return _context33.stop();\n          }\n        }, _callee33, this);\n      }));\n    }\n    /**\r\n     * Gets all transaction receipts for a given block by number or block hash.\r\n     *\r\n     * @param params An object containing fields for the transaction receipt query.\r\n     * @public\r\n     */\n  }, {\n    key: \"getTransactionReceipts\",\n    value: function getTransactionReceipts(params) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee34() {\n        return _regeneratorRuntime().wrap(function _callee34$(_context34) {\n          while (1) switch (_context34.prev = _context34.next) {\n            case 0:\n              return _context34.abrupt(\"return\", _getTransactionReceipts(this.config, params));\n            case 1:\n            case \"end\":\n              return _context34.stop();\n          }\n        }, _callee34, this);\n      }));\n    }\n    /**\r\n     * Returns the underlying owner address for the provided ENS address, or `null`\r\n     * if the ENS name does not have an underlying address.\r\n     *\r\n     * @param name The ENS address name to resolve.\r\n     */\n  }, {\n    key: \"resolveName\",\n    value: function resolveName(name) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee35() {\n        var provider;\n        return _regeneratorRuntime().wrap(function _callee35$(_context35) {\n          while (1) switch (_context35.prev = _context35.next) {\n            case 0:\n              _context35.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context35.sent;\n              return _context35.abrupt(\"return\", provider.resolveName(name));\n            case 4:\n            case \"end\":\n              return _context35.stop();\n          }\n        }, _callee35, this);\n      }));\n    }\n    /**\r\n     * Performs a reverse lookup of the address in ENS using the Reverse Registrar. If the name does not exist, or the forward lookup does not match, null is returned.\r\n     *\r\n     * An ENS name requires additional configuration to setup a reverse record, so not all ENS addresses will map back to the original ENS domain.\r\n     *\r\n     * @param address The address to look up the ENS domain name for.\r\n     */\n  }, {\n    key: \"lookupAddress\",\n    value: function lookupAddress(address) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee36() {\n        var provider;\n        return _regeneratorRuntime().wrap(function _callee36$(_context36) {\n          while (1) switch (_context36.prev = _context36.next) {\n            case 0:\n              _context36.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context36.sent;\n              return _context36.abrupt(\"return\", provider.lookupAddress(address));\n            case 4:\n            case \"end\":\n              return _context36.stop();\n          }\n        }, _callee36, this);\n      }));\n    }\n  }]);\n  return CoreNamespace;\n}();\n/**\r\n * Perform a binary search between an integer range of block numbers to find the\r\n * block number where the contract was deployed.\r\n *\r\n * @internal\r\n */\nfunction binarySearchFirstBlock(start, end, address, config) {\n  return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee37() {\n    var mid, provider, code;\n    return _regeneratorRuntime().wrap(function _callee37$(_context37) {\n      while (1) switch (_context37.prev = _context37.next) {\n        case 0:\n          if (!(start >= end)) {\n            _context37.next = 2;\n            break;\n          }\n          return _context37.abrupt(\"return\", end);\n        case 2:\n          mid = Math.floor((start + end) / 2);\n          _context37.next = 5;\n          return config.getProvider();\n        case 5:\n          provider = _context37.sent;\n          _context37.next = 8;\n          return provider.getCode(address, mid);\n        case 8:\n          code = _context37.sent;\n          if (!(code === ETH_NULL_VALUE)) {\n            _context37.next = 11;\n            break;\n          }\n          return _context37.abrupt(\"return\", binarySearchFirstBlock(mid + 1, end, address, config));\n        case 11:\n          return _context37.abrupt(\"return\", binarySearchFirstBlock(start, mid, address, config));\n        case 12:\n        case \"end\":\n          return _context37.stop();\n      }\n    }, _callee37);\n  }));\n}\n\n/**\r\n * The Debug namespace contains methods to access the non-standard RPC methods\r\n * for inspecting and debugging transactions.\r\n *\r\n * For more information on the different methods and use cases please read our\r\n * [documentation](https://docs.alchemy.com/reference/debug-api-quickstart).\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an Alchemy object\r\n * with `const alchemy = new Alchemy(config)` and then access the debug namespace\r\n * via `alchemy.debug`.\r\n */\nvar DebugNamespace = /*#__PURE__*/function () {\n  /** @internal */\n  function DebugNamespace(config) {\n    _classCallCheck(this, DebugNamespace);\n    this.config = config;\n  }\n  _createClass(DebugNamespace, [{\n    key: \"traceCall\",\n    value: function traceCall(transaction, blockIdentifier, tracer) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee38() {\n        var provider, params;\n        return _regeneratorRuntime().wrap(function _callee38$(_context38) {\n          while (1) switch (_context38.prev = _context38.next) {\n            case 0:\n              _context38.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context38.sent;\n              params = [transaction, blockIdentifier, parseTracerParams(tracer)];\n              return _context38.abrupt(\"return\", provider._send('debug_traceCall', params, 'traceCall'));\n            case 5:\n            case \"end\":\n              return _context38.stop();\n          }\n        }, _callee38, this);\n      }));\n    }\n  }, {\n    key: \"traceTransaction\",\n    value: function traceTransaction(transactionHash, tracer, timeout) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee39() {\n        var provider, params;\n        return _regeneratorRuntime().wrap(function _callee39$(_context39) {\n          while (1) switch (_context39.prev = _context39.next) {\n            case 0:\n              _context39.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context39.sent;\n              params = [transactionHash, parseTracerParams(tracer, timeout)];\n              return _context39.abrupt(\"return\", provider._send('debug_traceTransaction', params, 'traceTransaction'));\n            case 5:\n            case \"end\":\n              return _context39.stop();\n          }\n        }, _callee39, this);\n      }));\n    }\n  }, {\n    key: \"traceBlock\",\n    value: function traceBlock(blockIdentifier, tracer) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee40() {\n        var provider, method, params, block;\n        return _regeneratorRuntime().wrap(function _callee40$(_context40) {\n          while (1) switch (_context40.prev = _context40.next) {\n            case 0:\n              _context40.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context40.sent;\n              if (isHexString(blockIdentifier, 32)) {\n                method = 'debug_traceBlockByHash';\n                params = [blockIdentifier, parseTracerParams(tracer)];\n              } else {\n                method = 'debug_traceBlockByNumber';\n                block = typeof blockIdentifier === 'number' ? hexStripZeros(hexValue(blockIdentifier)) : blockIdentifier;\n                params = [block, parseTracerParams(tracer)];\n              }\n              return _context40.abrupt(\"return\", provider._send(method, params, 'traceBlock'));\n            case 5:\n            case \"end\":\n              return _context40.stop();\n          }\n        }, _callee40, this);\n      }));\n    }\n  }]);\n  return DebugNamespace;\n}();\nfunction parseTracerParams(tracer, timeout) {\n  return Object.assign({\n    tracer: tracer.type\n  }, tracer.onlyTopCall !== undefined && {\n    tracerConfig: {\n      onlyTopCall: tracer.onlyTopCall,\n      timeout: timeout\n    }\n  });\n}\nfunction sanitizeTokenType(tokenType) {\n  if (tokenType === NftTokenType.ERC1155 || tokenType === NftTokenType.ERC721) {\n    return tokenType;\n  }\n  return undefined;\n}\n\n/**\r\n * The SDK has 4 log levels and a 5th option for disabling all logging. By\r\n * default, the log level is set to INFO.\r\n *\r\n * The order is a follows: DEBUG < INFO < WARN < ERROR\r\n *\r\n * All log types above the current log level will be outputted.\r\n */\nvar LogLevel;\n(function (LogLevel) {\n  LogLevel[LogLevel[\"DEBUG\"] = 0] = \"DEBUG\";\n  LogLevel[LogLevel[\"INFO\"] = 1] = \"INFO\";\n  LogLevel[LogLevel[\"WARN\"] = 2] = \"WARN\";\n  LogLevel[LogLevel[\"ERROR\"] = 3] = \"ERROR\";\n  LogLevel[LogLevel[\"SILENT\"] = 4] = \"SILENT\";\n})(LogLevel || (LogLevel = {}));\nvar logLevelStringToEnum = {\n  debug: LogLevel.DEBUG,\n  info: LogLevel.INFO,\n  warn: LogLevel.WARN,\n  error: LogLevel.ERROR,\n  silent: LogLevel.SILENT\n};\n// HACKY: Use the console method as a string rather than the function itself\n// in order to allow for mocking in tests.\nvar logLevelToConsoleFn = (_logLevelToConsoleFn = {}, _defineProperty(_logLevelToConsoleFn, LogLevel.DEBUG, 'log'), _defineProperty(_logLevelToConsoleFn, LogLevel.INFO, 'info'), _defineProperty(_logLevelToConsoleFn, LogLevel.WARN, 'warn'), _defineProperty(_logLevelToConsoleFn, LogLevel.ERROR, 'error'), _logLevelToConsoleFn);\nvar DEFAULT_LOG_LEVEL = LogLevel.INFO;\n/**\r\n * Configures the verbosity of logging. The default log level is `info`.\r\n *\r\n * @param logLevel - The verbosity of logging. Can be any of the following values:\r\n *\r\n *   - `debug`: The most verbose logging level.\r\n *   - `info`: The default logging level.\r\n *   - `warn`: A logging level for non-critical issues.\r\n *   - `error`: A logging level for critical issues.\r\n *   - `silent`: Turn off all logging.\r\n *\r\n * @public\r\n */\nfunction setLogLevel(logLevel) {\n  loggerClient.logLevel = logLevelStringToEnum[logLevel];\n}\nfunction logDebug(message) {\n  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    args[_key4 - 1] = arguments[_key4];\n  }\n  loggerClient.debug(message, args);\n}\nfunction logInfo(message) {\n  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n    args[_key5 - 1] = arguments[_key5];\n  }\n  loggerClient.info(message, args);\n}\nfunction logWarn(message) {\n  for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n    args[_key6 - 1] = arguments[_key6];\n  }\n  loggerClient.warn(message, args);\n}\nvar Logger = /*#__PURE__*/function () {\n  function Logger() {\n    _classCallCheck(this, Logger);\n    /** The log level of the given Logger instance. */\n    this._logLevel = DEFAULT_LOG_LEVEL;\n  }\n  _createClass(Logger, [{\n    key: \"logLevel\",\n    get: function get() {\n      return this._logLevel;\n    },\n    set: function set(val) {\n      if (!(val in LogLevel)) {\n        throw new TypeError(\"Invalid value \\\"\".concat(val, \"\\\" assigned to `logLevel`\"));\n      }\n      this._logLevel = val;\n    }\n  }, {\n    key: \"debug\",\n    value: function debug() {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n      this._log.apply(this, [LogLevel.DEBUG].concat(args));\n    }\n  }, {\n    key: \"info\",\n    value: function info() {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n      this._log.apply(this, [LogLevel.INFO].concat(args));\n    }\n  }, {\n    key: \"warn\",\n    value: function warn() {\n      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        args[_key9] = arguments[_key9];\n      }\n      this._log.apply(this, [LogLevel.WARN].concat(args));\n    }\n  }, {\n    key: \"error\",\n    value: function error() {\n      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        args[_key10] = arguments[_key10];\n      }\n      this._log.apply(this, [LogLevel.ERROR].concat(args));\n    }\n    /**\r\n     * Forwards log messages to their corresponding console counterparts if the\r\n     * log level allows it.\r\n     */\n  }, {\n    key: \"_log\",\n    value: function _log(logLevel) {\n      if (logLevel < this._logLevel) {\n        return;\n      }\n      var now = new Date().toISOString();\n      var method = logLevelToConsoleFn[logLevel];\n      if (method) {\n        var _console;\n        for (var _len11 = arguments.length, args = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {\n          args[_key11 - 1] = arguments[_key11];\n        }\n        (_console = console)[method].apply(_console, [\"[\".concat(now, \"] Alchemy:\")].concat(_toConsumableArray(args.map(stringify))));\n      } else {\n        throw new Error(\"Logger received an invalid logLevel (value: \".concat(logLevel, \")\"));\n      }\n    }\n  }]);\n  return Logger;\n}();\nfunction stringify(obj) {\n  if (typeof obj === 'string') {\n    return obj;\n  } else {\n    try {\n      return JSON.stringify(obj);\n    } catch (e) {\n      // Failed to convert to JSON, log the object directly.\n      return obj;\n    }\n  }\n}\n// Instantiate default logger for the SDK.\nvar loggerClient = new Logger();\n\n// This file is autogenerated by injectVersion.js. Any changes will be\n// overwritten on commit!\nvar VERSION = '2.10.0';\n\n/**\r\n * Given a REST endpoint, method, and params, sends the request with axios and\r\n * returns the response.\r\n */\n/**\r\n * Helper function to send http requests using Axis.\r\n *\r\n * @private\r\n */\nfunction sendAxiosRequest(baseUrl, restApiName, methodName, params, overrides) {\n  var _a;\n  var requestUrl = baseUrl + '/' + restApiName;\n  var config = Object.assign(Object.assign({}, overrides), {\n    headers: Object.assign(Object.assign(Object.assign({}, overrides === null || overrides === void 0 ? void 0 : overrides.headers), !IS_BROWSER && {\n      'Accept-Encoding': 'gzip'\n    }), {\n      'Alchemy-Ethers-Sdk-Version': VERSION,\n      'Alchemy-Ethers-Sdk-Method': methodName\n    }),\n    method: (_a = overrides === null || overrides === void 0 ? void 0 : overrides.method) !== null && _a !== void 0 ? _a : 'GET',\n    url: requestUrl,\n    params: params\n  });\n  return axios(config);\n}\nvar DEFAULT_BACKOFF_INITIAL_DELAY_MS = 1000;\nvar DEFAULT_BACKOFF_MULTIPLIER = 1.5;\nvar DEFAULT_BACKOFF_MAX_DELAY_MS = 30 * 1000;\nvar DEFAULT_BACKOFF_MAX_ATTEMPTS = 5;\n/**\r\n * Helper class for implementing exponential backoff and max retry attempts.\r\n *\r\n * @private\r\n * @internal\r\n */\nvar ExponentialBackoff = /*#__PURE__*/function () {\n  function ExponentialBackoff() {\n    var maxAttempts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_BACKOFF_MAX_ATTEMPTS;\n    _classCallCheck(this, ExponentialBackoff);\n    this.maxAttempts = maxAttempts;\n    this.initialDelayMs = DEFAULT_BACKOFF_INITIAL_DELAY_MS;\n    this.backoffMultiplier = DEFAULT_BACKOFF_MULTIPLIER;\n    this.maxDelayMs = DEFAULT_BACKOFF_MAX_DELAY_MS;\n    this.numAttempts = 0;\n    this.currentDelayMs = 0;\n    this.isInBackoff = false;\n  }\n  /**\r\n   * Returns a promise that resolves after the the backoff delay. The delay is\r\n   * increased for each attempt. The promise is rejected if the maximum number\r\n   * of attempts is exceeded.\r\n   */\n  // TODO: beautify this into an async iterator.\n  _createClass(ExponentialBackoff, [{\n    key: \"backoff\",\n    value: function backoff() {\n      var _this4 = this;\n      if (this.numAttempts >= this.maxAttempts) {\n        return Promise.reject(new Error(\"Exceeded maximum number of attempts: \".concat(this.maxAttempts)));\n      }\n      if (this.isInBackoff) {\n        return Promise.reject(new Error('A backoff operation is already in progress'));\n      }\n      var backoffDelayWithJitterMs = this.withJitterMs(this.currentDelayMs);\n      if (backoffDelayWithJitterMs > 0) {\n        logDebug('ExponentialBackoff.backoff', \"Backing off for \".concat(backoffDelayWithJitterMs, \"ms\"));\n      }\n      // Calculate the next delay.\n      this.currentDelayMs *= this.backoffMultiplier;\n      this.currentDelayMs = Math.max(this.currentDelayMs, this.initialDelayMs);\n      this.currentDelayMs = Math.min(this.currentDelayMs, this.maxDelayMs);\n      this.numAttempts += 1;\n      return new Promise(function (resolve) {\n        _this4.isInBackoff = true;\n        setTimeout(function () {\n          _this4.isInBackoff = false;\n          resolve();\n        }, backoffDelayWithJitterMs);\n      });\n    }\n    /**\r\n     * Applies +/- 50% jitter to the backoff delay, up to the max delay cap.\r\n     *\r\n     * @private\r\n     * @param delayMs\r\n     */\n  }, {\n    key: \"withJitterMs\",\n    value: function withJitterMs(delayMs) {\n      return Math.min(delayMs + (Math.random() - 0.5) * delayMs, this.maxDelayMs);\n    }\n  }]);\n  return ExponentialBackoff;\n}();\n/**\r\n * A wrapper function to make http requests and retry if the request fails.\r\n *\r\n * @internal\r\n */\n// TODO: Wrap Axios error in AlchemyError.\nfunction requestHttpWithBackoff(config, apiType, restApiName, methodName, params, overrides) {\n  return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee41() {\n    var lastError, backoff, attempt, response;\n    return _regeneratorRuntime().wrap(function _callee41$(_context41) {\n      while (1) switch (_context41.prev = _context41.next) {\n        case 0:\n          lastError = undefined;\n          backoff = new ExponentialBackoff(config.maxRetries);\n          attempt = 0;\n        case 3:\n          if (!(attempt < config.maxRetries + 1)) {\n            _context41.next = 36;\n            break;\n          }\n          _context41.prev = 4;\n          if (lastError !== undefined) {\n            logInfo('requestHttp', \"Retrying after error: \".concat(lastError.message));\n          }\n          _context41.prev = 6;\n          _context41.next = 9;\n          return backoff.backoff();\n        case 9:\n          _context41.next = 14;\n          break;\n        case 11:\n          _context41.prev = 11;\n          _context41.t0 = _context41[\"catch\"](6);\n          return _context41.abrupt(\"break\", 36);\n        case 14:\n          _context41.next = 16;\n          return sendAxiosRequest(config._getRequestUrl(apiType), restApiName, methodName, params, Object.assign(Object.assign({}, overrides), {\n            timeout: config.requestTimeout\n          }));\n        case 16:\n          response = _context41.sent;\n          if (!(response.status === 200)) {\n            _context41.next = 22;\n            break;\n          }\n          logDebug(restApiName, \"Successful request: \".concat(restApiName));\n          return _context41.abrupt(\"return\", response.data);\n        case 22:\n          logInfo(restApiName, \"Request failed: \".concat(restApiName, \", \").concat(response.status, \", \").concat(response.data));\n          lastError = new Error(response.status + ': ' + response.data);\n        case 24:\n          _context41.next = 33;\n          break;\n        case 26:\n          _context41.prev = 26;\n          _context41.t1 = _context41[\"catch\"](4);\n          if (!(!axios.isAxiosError(_context41.t1) || _context41.t1.response === undefined)) {\n            _context41.next = 30;\n            break;\n          }\n          throw _context41.t1;\n        case 30:\n          // TODO: Standardize all errors into AlchemyError\n          lastError = new Error(_context41.t1.response.status + ': ' + _context41.t1.response.data);\n          if (isRetryableHttpError(_context41.t1, apiType)) {\n            _context41.next = 33;\n            break;\n          }\n          return _context41.abrupt(\"break\", 36);\n        case 33:\n          attempt++;\n          _context41.next = 3;\n          break;\n        case 36:\n          return _context41.abrupt(\"return\", Promise.reject(lastError));\n        case 37:\n        case \"end\":\n          return _context41.stop();\n      }\n    }, _callee41, null, [[4, 26], [6, 11]]);\n  }));\n}\nfunction isRetryableHttpError(err, apiType) {\n  // TODO: remove 500s after webhooks are more stable.\n  var retryableCodes = apiType === AlchemyApiType.WEBHOOK ? [429, 500] : [429];\n  return err.response !== undefined && retryableCodes.includes(err.response.status);\n}\n/**\r\n * Fetches all pages in a paginated endpoint, given a `pageKey` field that\r\n * represents the property name containing the next page token.\r\n *\r\n * @internal\r\n */\nfunction paginateEndpoint(config, apiType, restApiName, methodName, reqPageKey, resPageKey, params) {\n  return __asyncGenerator(this, arguments, /*#__PURE__*/_regeneratorRuntime().mark(function paginateEndpoint_1() {\n    var hasNext, requestParams, response;\n    return _regeneratorRuntime().wrap(function paginateEndpoint_1$(_context42) {\n      while (1) switch (_context42.prev = _context42.next) {\n        case 0:\n          hasNext = true;\n          requestParams = Object.assign({}, params);\n        case 2:\n          if (!hasNext) {\n            _context42.next = 13;\n            break;\n          }\n          _context42.next = 5;\n          return __await(requestHttpWithBackoff(config, apiType, restApiName, methodName, requestParams));\n        case 5:\n          response = _context42.sent;\n          _context42.next = 8;\n          return __await(response);\n        case 8:\n          _context42.next = 10;\n          return _context42.sent;\n        case 10:\n          if (response[resPageKey] !== undefined) {\n            requestParams[reqPageKey] = response[resPageKey];\n          } else {\n            hasNext = false;\n          }\n          _context42.next = 2;\n          break;\n        case 13:\n        case \"end\":\n          return _context42.stop();\n      }\n    }, paginateEndpoint_1);\n  }));\n}\n\n/**\r\n * This file contains the underlying implementations for exposed API surface in\r\n * the {@link NftNamespace}. By moving the methods out into a separate file,\r\n * other namespaces can access these methods without depending on the entire\r\n * NftNamespace.\r\n */\n/**\r\n * Get the NFT metadata for the provided contract address.\r\n */\nfunction _getNftMetadata(config, contractAddress, tokenId, options) {\n  var srcMethod = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'getNftMetadata';\n  return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee42() {\n    var response;\n    return _regeneratorRuntime().wrap(function _callee42$(_context43) {\n      while (1) switch (_context43.prev = _context43.next) {\n        case 0:\n          _context43.next = 2;\n          return requestHttpWithBackoff(config, AlchemyApiType.NFT, 'getNFTMetadata', srcMethod, {\n            contractAddress: contractAddress,\n            tokenId: BigNumber.from(tokenId).toString(),\n            tokenType: sanitizeTokenType(options === null || options === void 0 ? void 0 : options.tokenType),\n            tokenUriTimeoutInMs: options === null || options === void 0 ? void 0 : options.tokenUriTimeoutInMs,\n            refreshCache: options === null || options === void 0 ? void 0 : options.refreshCache\n          });\n        case 2:\n          response = _context43.sent;\n          return _context43.abrupt(\"return\", getNftFromRaw(response));\n        case 4:\n        case \"end\":\n          return _context43.stop();\n      }\n    }, _callee42);\n  }));\n}\nfunction _getNftMetadataBatch(config, tokens, options) {\n  return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee43() {\n    var data, response;\n    return _regeneratorRuntime().wrap(function _callee43$(_context44) {\n      while (1) switch (_context44.prev = _context44.next) {\n        case 0:\n          data = {\n            tokens: tokens,\n            tokenUriTimeoutInMs: options === null || options === void 0 ? void 0 : options.tokenUriTimeoutInMs,\n            refreshCache: options === null || options === void 0 ? void 0 : options.refreshCache\n          };\n          _context44.next = 3;\n          return requestHttpWithBackoff(config, AlchemyApiType.NFT, 'getNFTMetadataBatch', 'getNftMetadataBatch', {}, {\n            method: 'POST',\n            data: data\n          });\n        case 3:\n          response = _context44.sent;\n          return _context44.abrupt(\"return\", response.map(getNftFromRaw));\n        case 5:\n        case \"end\":\n          return _context44.stop();\n      }\n    }, _callee43);\n  }));\n}\nfunction _getContractMetadata(config, contractAddress) {\n  var srcMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'getContractMetadata';\n  return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee44() {\n    var response;\n    return _regeneratorRuntime().wrap(function _callee44$(_context45) {\n      while (1) switch (_context45.prev = _context45.next) {\n        case 0:\n          _context45.next = 2;\n          return requestHttpWithBackoff(config, AlchemyApiType.NFT, 'getContractMetadata', srcMethod, {\n            contractAddress: contractAddress\n          });\n        case 2:\n          response = _context45.sent;\n          return _context45.abrupt(\"return\", getNftContractFromRaw(response));\n        case 4:\n        case \"end\":\n          return _context45.stop();\n      }\n    }, _callee44);\n  }));\n}\nfunction _getContractMetadataBatch(config, contractAddresses) {\n  return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee45() {\n    var response;\n    return _regeneratorRuntime().wrap(function _callee45$(_context46) {\n      while (1) switch (_context46.prev = _context46.next) {\n        case 0:\n          _context46.next = 2;\n          return requestHttpWithBackoff(config, AlchemyApiType.NFT, 'getContractMetadataBatch', 'getContractMetadataBatch', {}, {\n            method: 'POST',\n            data: {\n              contractAddresses: contractAddresses\n            }\n          });\n        case 2:\n          response = _context46.sent;\n          return _context46.abrupt(\"return\", response.map(getNftContractFromRaw));\n        case 4:\n        case \"end\":\n          return _context46.stop();\n      }\n    }, _callee45);\n  }));\n}\nfunction _getNftsForOwnerIterator(config, owner, options) {\n  var srcMethod = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'getNftsForOwnerIterator';\n  return __asyncGenerator(this, arguments, /*#__PURE__*/_regeneratorRuntime().mark(function getNftsForOwnerIterator_1() {\n    var e_1, _a, withMetadata, _b, _c, response, _iterator, _step, ownedNft;\n    return _regeneratorRuntime().wrap(function getNftsForOwnerIterator_1$(_context47) {\n      while (1) switch (_context47.prev = _context47.next) {\n        case 0:\n          withMetadata = omitMetadataToWithMetadata(options === null || options === void 0 ? void 0 : options.omitMetadata);\n          _context47.prev = 1;\n          _b = __asyncValues(paginateEndpoint(config, AlchemyApiType.NFT, 'getNFTs', srcMethod, 'pageKey', 'pageKey', {\n            contractAddresses: options === null || options === void 0 ? void 0 : options.contractAddresses,\n            pageKey: options === null || options === void 0 ? void 0 : options.pageKey,\n            filters: options === null || options === void 0 ? void 0 : options.excludeFilters,\n            owner: owner,\n            withMetadata: withMetadata\n          }));\n        case 3:\n          _context47.next = 5;\n          return __await(_b.next());\n        case 5:\n          _c = _context47.sent;\n          if (_c.done) {\n            _context47.next = 29;\n            break;\n          }\n          response = _c.value;\n          _iterator = _createForOfIteratorHelper(response.ownedNfts);\n          _context47.prev = 9;\n          _iterator.s();\n        case 11:\n          if ((_step = _iterator.n()).done) {\n            _context47.next = 19;\n            break;\n          }\n          ownedNft = _step.value;\n          _context47.next = 15;\n          return __await(Object.assign(Object.assign({}, nftFromGetNftResponse(ownedNft)), {\n            balance: parseInt(ownedNft.balance)\n          }));\n        case 15:\n          _context47.next = 17;\n          return _context47.sent;\n        case 17:\n          _context47.next = 11;\n          break;\n        case 19:\n          _context47.next = 24;\n          break;\n        case 21:\n          _context47.prev = 21;\n          _context47.t0 = _context47[\"catch\"](9);\n          _iterator.e(_context47.t0);\n        case 24:\n          _context47.prev = 24;\n          _iterator.f();\n          return _context47.finish(24);\n        case 27:\n          _context47.next = 3;\n          break;\n        case 29:\n          _context47.next = 34;\n          break;\n        case 31:\n          _context47.prev = 31;\n          _context47.t1 = _context47[\"catch\"](1);\n          e_1 = {\n            error: _context47.t1\n          };\n        case 34:\n          _context47.prev = 34;\n          _context47.prev = 35;\n          if (!(_c && !_c.done && (_a = _b.return))) {\n            _context47.next = 39;\n            break;\n          }\n          _context47.next = 39;\n          return __await(_a.call(_b));\n        case 39:\n          _context47.prev = 39;\n          if (!e_1) {\n            _context47.next = 42;\n            break;\n          }\n          throw e_1.error;\n        case 42:\n          return _context47.finish(39);\n        case 43:\n          return _context47.finish(34);\n        case 44:\n        case \"end\":\n          return _context47.stop();\n      }\n    }, getNftsForOwnerIterator_1, null, [[1, 31, 34, 44], [9, 21, 24, 27], [35,, 39, 43]]);\n  }));\n}\nfunction _getNftsForOwner(config, owner, options) {\n  var srcMethod = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'getNftsForOwner';\n  return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee46() {\n    var withMetadata, response;\n    return _regeneratorRuntime().wrap(function _callee46$(_context48) {\n      while (1) switch (_context48.prev = _context48.next) {\n        case 0:\n          withMetadata = omitMetadataToWithMetadata(options === null || options === void 0 ? void 0 : options.omitMetadata);\n          _context48.next = 3;\n          return requestHttpWithBackoff(config, AlchemyApiType.NFT, 'getNFTs', srcMethod, {\n            contractAddresses: options === null || options === void 0 ? void 0 : options.contractAddresses,\n            pageKey: options === null || options === void 0 ? void 0 : options.pageKey,\n            filters: options === null || options === void 0 ? void 0 : options.excludeFilters,\n            excludeFilters: options === null || options === void 0 ? void 0 : options.excludeFilters,\n            includeFilters: options === null || options === void 0 ? void 0 : options.includeFilters,\n            owner: owner,\n            pageSize: options === null || options === void 0 ? void 0 : options.pageSize,\n            withMetadata: withMetadata,\n            tokenUriTimeoutInMs: options === null || options === void 0 ? void 0 : options.tokenUriTimeoutInMs,\n            orderBy: options === null || options === void 0 ? void 0 : options.orderBy\n          });\n        case 3:\n          response = _context48.sent;\n          return _context48.abrupt(\"return\", {\n            ownedNfts: response.ownedNfts.map(function (res) {\n              return Object.assign(Object.assign({}, nftFromGetNftResponse(res)), {\n                balance: parseInt(res.balance)\n              });\n            }),\n            pageKey: response.pageKey,\n            totalCount: response.totalCount,\n            blockHash: response.blockHash\n          });\n        case 5:\n        case \"end\":\n          return _context48.stop();\n      }\n    }, _callee46);\n  }));\n}\nfunction _getNftsForContract(config, contractAddress, options) {\n  var srcMethod = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'getNftsForContract';\n  var _a;\n  return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee47() {\n    var withMetadata, response;\n    return _regeneratorRuntime().wrap(function _callee47$(_context49) {\n      while (1) switch (_context49.prev = _context49.next) {\n        case 0:\n          withMetadata = omitMetadataToWithMetadata(options === null || options === void 0 ? void 0 : options.omitMetadata);\n          _context49.next = 3;\n          return requestHttpWithBackoff(config, AlchemyApiType.NFT, 'getNFTsForCollection', srcMethod, {\n            contractAddress: contractAddress,\n            startToken: options === null || options === void 0 ? void 0 : options.pageKey,\n            withMetadata: withMetadata,\n            limit: (_a = options === null || options === void 0 ? void 0 : options.pageSize) !== null && _a !== void 0 ? _a : undefined,\n            tokenUriTimeoutInMs: options === null || options === void 0 ? void 0 : options.tokenUriTimeoutInMs\n          });\n        case 3:\n          response = _context49.sent;\n          return _context49.abrupt(\"return\", {\n            nfts: response.nfts.map(function (res) {\n              return nftFromGetNftContractResponse(res, contractAddress);\n            }),\n            pageKey: response.nextToken\n          });\n        case 5:\n        case \"end\":\n          return _context49.stop();\n      }\n    }, _callee47);\n  }));\n}\nfunction _getNftsForContractIterator(config, contractAddress, options) {\n  var srcMethod = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'getNftsForContractIterator';\n  return __asyncGenerator(this, arguments, /*#__PURE__*/_regeneratorRuntime().mark(function getNftsForContractIterator_1() {\n    var e_2, _a, withMetadata, _b, _c, response, _iterator2, _step2, nft;\n    return _regeneratorRuntime().wrap(function getNftsForContractIterator_1$(_context50) {\n      while (1) switch (_context50.prev = _context50.next) {\n        case 0:\n          withMetadata = omitMetadataToWithMetadata(options === null || options === void 0 ? void 0 : options.omitMetadata);\n          _context50.prev = 1;\n          _b = __asyncValues(paginateEndpoint(config, AlchemyApiType.NFT, 'getNFTsForCollection', srcMethod, 'startToken', 'nextToken', {\n            contractAddress: contractAddress,\n            startToken: options === null || options === void 0 ? void 0 : options.pageKey,\n            withMetadata: withMetadata\n          }));\n        case 3:\n          _context50.next = 5;\n          return __await(_b.next());\n        case 5:\n          _c = _context50.sent;\n          if (_c.done) {\n            _context50.next = 29;\n            break;\n          }\n          response = _c.value;\n          _iterator2 = _createForOfIteratorHelper(response.nfts);\n          _context50.prev = 9;\n          _iterator2.s();\n        case 11:\n          if ((_step2 = _iterator2.n()).done) {\n            _context50.next = 19;\n            break;\n          }\n          nft = _step2.value;\n          _context50.next = 15;\n          return __await(nftFromGetNftContractResponse(nft, contractAddress));\n        case 15:\n          _context50.next = 17;\n          return _context50.sent;\n        case 17:\n          _context50.next = 11;\n          break;\n        case 19:\n          _context50.next = 24;\n          break;\n        case 21:\n          _context50.prev = 21;\n          _context50.t0 = _context50[\"catch\"](9);\n          _iterator2.e(_context50.t0);\n        case 24:\n          _context50.prev = 24;\n          _iterator2.f();\n          return _context50.finish(24);\n        case 27:\n          _context50.next = 3;\n          break;\n        case 29:\n          _context50.next = 34;\n          break;\n        case 31:\n          _context50.prev = 31;\n          _context50.t1 = _context50[\"catch\"](1);\n          e_2 = {\n            error: _context50.t1\n          };\n        case 34:\n          _context50.prev = 34;\n          _context50.prev = 35;\n          if (!(_c && !_c.done && (_a = _b.return))) {\n            _context50.next = 39;\n            break;\n          }\n          _context50.next = 39;\n          return __await(_a.call(_b));\n        case 39:\n          _context50.prev = 39;\n          if (!e_2) {\n            _context50.next = 42;\n            break;\n          }\n          throw e_2.error;\n        case 42:\n          return _context50.finish(39);\n        case 43:\n          return _context50.finish(34);\n        case 44:\n        case \"end\":\n          return _context50.stop();\n      }\n    }, getNftsForContractIterator_1, null, [[1, 31, 34, 44], [9, 21, 24, 27], [35,, 39, 43]]);\n  }));\n}\nfunction _getOwnersForContract(config, contractAddress, options) {\n  var srcMethod = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'getOwnersForContract';\n  return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee48() {\n    var response;\n    return _regeneratorRuntime().wrap(function _callee48$(_context51) {\n      while (1) switch (_context51.prev = _context51.next) {\n        case 0:\n          _context51.next = 2;\n          return requestHttpWithBackoff(config, AlchemyApiType.NFT, 'getOwnersForCollection', srcMethod, Object.assign(Object.assign({}, options), {\n            contractAddress: contractAddress\n          }));\n        case 2:\n          response = _context51.sent;\n          return _context51.abrupt(\"return\", Object.assign({\n            owners: response.ownerAddresses,\n            totalCount: response.totalCount\n          }, response.pageKey !== undefined && {\n            pageKey: response.pageKey\n          }));\n        case 4:\n        case \"end\":\n          return _context51.stop();\n      }\n    }, _callee48);\n  }));\n}\nfunction _getContractsForOwner(config, owner, options) {\n  var srcMethod = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'getContractsForOwner';\n  return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee49() {\n    var response;\n    return _regeneratorRuntime().wrap(function _callee49$(_context52) {\n      while (1) switch (_context52.prev = _context52.next) {\n        case 0:\n          _context52.next = 2;\n          return requestHttpWithBackoff(config, AlchemyApiType.NFT, 'getContractsForOwner', srcMethod, {\n            owner: owner,\n            excludeFilters: options === null || options === void 0 ? void 0 : options.excludeFilters,\n            includeFilters: options === null || options === void 0 ? void 0 : options.includeFilters,\n            pageKey: options === null || options === void 0 ? void 0 : options.pageKey,\n            pageSize: options === null || options === void 0 ? void 0 : options.pageSize,\n            orderBy: options === null || options === void 0 ? void 0 : options.orderBy\n          });\n        case 2:\n          response = _context52.sent;\n          return _context52.abrupt(\"return\", getContractsForOwnerFromRaw(response));\n        case 4:\n        case \"end\":\n          return _context52.stop();\n      }\n    }, _callee49);\n  }));\n}\nfunction _getOwnersForNft(config, contractAddress, tokenId, options) {\n  var srcMethod = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'getOwnersForNft';\n  return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee50() {\n    return _regeneratorRuntime().wrap(function _callee50$(_context53) {\n      while (1) switch (_context53.prev = _context53.next) {\n        case 0:\n          return _context53.abrupt(\"return\", requestHttpWithBackoff(config, AlchemyApiType.NFT, 'getOwnersForToken', srcMethod, Object.assign({\n            contractAddress: contractAddress,\n            tokenId: BigNumber.from(tokenId).toString()\n          }, options)));\n        case 1:\n        case \"end\":\n          return _context53.stop();\n      }\n    }, _callee50);\n  }));\n}\nfunction _getMintedNfts(config, owner, options) {\n  return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee51() {\n    var provider, ownerAddress, category, params, response;\n    return _regeneratorRuntime().wrap(function _callee51$(_context54) {\n      while (1) switch (_context54.prev = _context54.next) {\n        case 0:\n          _context54.next = 2;\n          return config.getProvider();\n        case 2:\n          provider = _context54.sent;\n          _context54.next = 5;\n          return provider._getAddress(owner);\n        case 5:\n          ownerAddress = _context54.sent;\n          category = nftTokenTypeToCategory(options === null || options === void 0 ? void 0 : options.tokenType);\n          params = {\n            fromBlock: '0x0',\n            fromAddress: ETH_NULL_ADDRESS,\n            toAddress: ownerAddress,\n            excludeZeroValue: true,\n            contractAddresses: options === null || options === void 0 ? void 0 : options.contractAddresses,\n            category: category,\n            maxCount: 100,\n            pageKey: options === null || options === void 0 ? void 0 : options.pageKey\n          };\n          _context54.next = 10;\n          return _getAssetTransfers(config, params, 'getMintedNfts');\n        case 10:\n          response = _context54.sent;\n          return _context54.abrupt(\"return\", getNftsForTransfers(config, response));\n        case 12:\n        case \"end\":\n          return _context54.stop();\n      }\n    }, _callee51);\n  }));\n}\nfunction _getTransfersForOwner(config, owner, transferType, options) {\n  return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee52() {\n    var provider, ownerAddress, category, params, transfersResponse;\n    return _regeneratorRuntime().wrap(function _callee52$(_context55) {\n      while (1) switch (_context55.prev = _context55.next) {\n        case 0:\n          _context55.next = 2;\n          return config.getProvider();\n        case 2:\n          provider = _context55.sent;\n          _context55.next = 5;\n          return provider._getAddress(owner);\n        case 5:\n          ownerAddress = _context55.sent;\n          category = nftTokenTypeToCategory(options === null || options === void 0 ? void 0 : options.tokenType);\n          params = {\n            fromBlock: '0x0',\n            excludeZeroValue: true,\n            contractAddresses: options === null || options === void 0 ? void 0 : options.contractAddresses,\n            category: category,\n            maxCount: 100,\n            pageKey: options === null || options === void 0 ? void 0 : options.pageKey\n          };\n          if (transferType === GetTransfersForOwnerTransferType.TO) {\n            params.toAddress = ownerAddress;\n          } else {\n            params.fromAddress = ownerAddress;\n          }\n          _context55.next = 11;\n          return _getAssetTransfers(config, params, 'getTransfersForOwner');\n        case 11:\n          transfersResponse = _context55.sent;\n          return _context55.abrupt(\"return\", getNftsForTransfers(config, transfersResponse));\n        case 13:\n        case \"end\":\n          return _context55.stop();\n      }\n    }, _callee52);\n  }));\n}\nfunction _getTransfersForContract(config, contract, options) {\n  return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee53() {\n    var category, provider, fromBlock, toBlock, params, transfersResponse;\n    return _regeneratorRuntime().wrap(function _callee53$(_context56) {\n      while (1) switch (_context56.prev = _context56.next) {\n        case 0:\n          category = [AssetTransfersCategory.ERC721, AssetTransfersCategory.ERC1155, AssetTransfersCategory.SPECIALNFT];\n          _context56.next = 3;\n          return config.getProvider();\n        case 3:\n          provider = _context56.sent;\n          if (!(options === null || options === void 0 ? void 0 : options.fromBlock)) {\n            _context56.next = 12;\n            break;\n          }\n          _context56.t1 = provider.formatter;\n          _context56.next = 8;\n          return provider._getBlockTag(options.fromBlock);\n        case 8:\n          _context56.t2 = _context56.sent;\n          _context56.t0 = _context56.t1.blockTag.call(_context56.t1, _context56.t2);\n          _context56.next = 13;\n          break;\n        case 12:\n          _context56.t0 = '0x0';\n        case 13:\n          fromBlock = _context56.t0;\n          if (!(options === null || options === void 0 ? void 0 : options.toBlock)) {\n            _context56.next = 22;\n            break;\n          }\n          _context56.t4 = provider.formatter;\n          _context56.next = 18;\n          return provider._getBlockTag(options.toBlock);\n        case 18:\n          _context56.t5 = _context56.sent;\n          _context56.t3 = _context56.t4.blockTag.call(_context56.t4, _context56.t5);\n          _context56.next = 23;\n          break;\n        case 22:\n          _context56.t3 = undefined;\n        case 23:\n          toBlock = _context56.t3;\n          params = {\n            fromBlock: fromBlock,\n            toBlock: toBlock,\n            excludeZeroValue: true,\n            contractAddresses: [contract],\n            order: options === null || options === void 0 ? void 0 : options.order,\n            category: category,\n            maxCount: 100,\n            pageKey: options === null || options === void 0 ? void 0 : options.pageKey\n          };\n          _context56.next = 27;\n          return _getAssetTransfers(config, params, 'getTransfersForContract');\n        case 27:\n          transfersResponse = _context56.sent;\n          return _context56.abrupt(\"return\", getNftsForTransfers(config, transfersResponse));\n        case 29:\n        case \"end\":\n          return _context56.stop();\n      }\n    }, _callee53);\n  }));\n}\nfunction nftTokenTypeToCategory(tokenType) {\n  switch (tokenType) {\n    case NftTokenType.ERC721:\n      return [AssetTransfersCategory.ERC721];\n    case NftTokenType.ERC1155:\n      return [AssetTransfersCategory.ERC1155];\n    default:\n      return [AssetTransfersCategory.ERC721, AssetTransfersCategory.ERC1155, AssetTransfersCategory.SPECIALNFT];\n  }\n}\nfunction parse1155Transfer(transfer) {\n  return transfer.erc1155Metadata.map(function (metadata) {\n    return {\n      contractAddress: transfer.rawContract.address,\n      tokenId: metadata.tokenId,\n      tokenType: NftTokenType.ERC1155\n    };\n  });\n}\nfunction _checkNftOwnership(config, owner, contractAddresses) {\n  var srcMethod = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'checkNftOwnership';\n  return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee54() {\n    var response;\n    return _regeneratorRuntime().wrap(function _callee54$(_context57) {\n      while (1) switch (_context57.prev = _context57.next) {\n        case 0:\n          if (!(contractAddresses.length === 0)) {\n            _context57.next = 2;\n            break;\n          }\n          throw new Error('Must provide at least one contract address');\n        case 2:\n          _context57.next = 4;\n          return _getNftsForOwner(config, owner, {\n            contractAddresses: contractAddresses,\n            omitMetadata: true\n          }, srcMethod);\n        case 4:\n          response = _context57.sent;\n          return _context57.abrupt(\"return\", response.ownedNfts.length > 0);\n        case 6:\n        case \"end\":\n          return _context57.stop();\n      }\n    }, _callee54);\n  }));\n}\nfunction _verifyNftOwnership(config, owner, contractAddresses) {\n  var srcMethod = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'verifyNftOwnership';\n  return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee55() {\n    var response, _response, result, _iterator3, _step3, nft;\n    return _regeneratorRuntime().wrap(function _callee55$(_context58) {\n      while (1) switch (_context58.prev = _context58.next) {\n        case 0:\n          if (!(typeof contractAddresses === 'string')) {\n            _context58.next = 7;\n            break;\n          }\n          _context58.next = 3;\n          return _getNftsForOwner(config, owner, {\n            contractAddresses: [contractAddresses],\n            omitMetadata: true\n          }, srcMethod);\n        case 3:\n          response = _context58.sent;\n          return _context58.abrupt(\"return\", response.ownedNfts.length > 0);\n        case 7:\n          if (!(contractAddresses.length === 0)) {\n            _context58.next = 9;\n            break;\n          }\n          throw new Error('Must provide at least one contract address');\n        case 9:\n          _context58.next = 11;\n          return _getNftsForOwner(config, owner, {\n            contractAddresses: contractAddresses,\n            omitMetadata: true\n          }, srcMethod);\n        case 11:\n          _response = _context58.sent;\n          // Create map where all input contract addresses are set to false, then flip\n          // owned nfts to true.\n          result = contractAddresses.reduce(function (acc, curr) {\n            acc[curr] = false;\n            return acc;\n          }, {});\n          _iterator3 = _createForOfIteratorHelper(_response.ownedNfts);\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              nft = _step3.value;\n              result[nft.contract.address] = true;\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n          return _context58.abrupt(\"return\", result);\n        case 16:\n        case \"end\":\n          return _context58.stop();\n      }\n    }, _callee55);\n  }));\n}\nfunction _isSpamContract(config, contractAddress) {\n  var srcMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'isSpamContract';\n  return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee56() {\n    return _regeneratorRuntime().wrap(function _callee56$(_context59) {\n      while (1) switch (_context59.prev = _context59.next) {\n        case 0:\n          return _context59.abrupt(\"return\", requestHttpWithBackoff(config, AlchemyApiType.NFT, 'isSpamContract', srcMethod, {\n            contractAddress: contractAddress\n          }));\n        case 1:\n        case \"end\":\n          return _context59.stop();\n      }\n    }, _callee56);\n  }));\n}\nfunction _getSpamContracts(config) {\n  var srcMethod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'getSpamContracts';\n  return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee57() {\n    return _regeneratorRuntime().wrap(function _callee57$(_context60) {\n      while (1) switch (_context60.prev = _context60.next) {\n        case 0:\n          return _context60.abrupt(\"return\", requestHttpWithBackoff(config, AlchemyApiType.NFT, 'getSpamContracts', srcMethod, undefined));\n        case 1:\n        case \"end\":\n          return _context60.stop();\n      }\n    }, _callee57);\n  }));\n}\nfunction _getFloorPrice(config, contractAddress) {\n  var srcMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'getFloorPrice';\n  return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee58() {\n    return _regeneratorRuntime().wrap(function _callee58$(_context61) {\n      while (1) switch (_context61.prev = _context61.next) {\n        case 0:\n          return _context61.abrupt(\"return\", requestHttpWithBackoff(config, AlchemyApiType.NFT, 'getFloorPrice', srcMethod, {\n            contractAddress: contractAddress\n          }));\n        case 1:\n        case \"end\":\n          return _context61.stop();\n      }\n    }, _callee58);\n  }));\n}\nfunction _getNftSales(config) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var srcMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'getNftSales';\n  return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee59() {\n    var params, response;\n    return _regeneratorRuntime().wrap(function _callee59$(_context62) {\n      while (1) switch (_context62.prev = _context62.next) {\n        case 0:\n          // Avoid ts compiler complaining about the contractAddress field.\n          params = Object.assign({}, options);\n          _context62.next = 3;\n          return requestHttpWithBackoff(config, AlchemyApiType.NFT, 'getNFTSales', srcMethod, {\n            fromBlock: params === null || params === void 0 ? void 0 : params.fromBlock,\n            toBlock: params === null || params === void 0 ? void 0 : params.toBlock,\n            order: params === null || params === void 0 ? void 0 : params.order,\n            marketplace: params === null || params === void 0 ? void 0 : params.marketplace,\n            contractAddress: params === null || params === void 0 ? void 0 : params.contractAddress,\n            tokenId: (params === null || params === void 0 ? void 0 : params.tokenId) ? BigNumber.from(params === null || params === void 0 ? void 0 : params.tokenId).toString() : undefined,\n            sellerAddress: params === null || params === void 0 ? void 0 : params.sellerAddress,\n            buyerAddress: params === null || params === void 0 ? void 0 : params.buyerAddress,\n            taker: params === null || params === void 0 ? void 0 : params.taker,\n            limit: params === null || params === void 0 ? void 0 : params.limit,\n            pageKey: params === null || params === void 0 ? void 0 : params.pageKey\n          });\n        case 3:\n          response = _context62.sent;\n          return _context62.abrupt(\"return\", getNftSalesFromRaw(response));\n        case 5:\n        case \"end\":\n          return _context62.stop();\n      }\n    }, _callee59);\n  }));\n}\nfunction _computeRarity(config, contractAddress, tokenId, refreshCache) {\n  var srcMethod = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'computeRarity';\n  return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee60() {\n    var response;\n    return _regeneratorRuntime().wrap(function _callee60$(_context63) {\n      while (1) switch (_context63.prev = _context63.next) {\n        case 0:\n          _context63.next = 2;\n          return requestHttpWithBackoff(config, AlchemyApiType.NFT, 'computeRarity', srcMethod, {\n            contractAddress: contractAddress,\n            tokenId: BigNumber.from(tokenId).toString(),\n            refreshCache: refreshCache\n          });\n        case 2:\n          response = _context63.sent;\n          return _context63.abrupt(\"return\", getNftRarityFromRaw(response));\n        case 4:\n        case \"end\":\n          return _context63.stop();\n      }\n    }, _callee60);\n  }));\n}\nfunction _searchContractMetadata(config, query) {\n  var srcMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'searchContractMetadata';\n  return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee61() {\n    var response;\n    return _regeneratorRuntime().wrap(function _callee61$(_context64) {\n      while (1) switch (_context64.prev = _context64.next) {\n        case 0:\n          _context64.next = 2;\n          return requestHttpWithBackoff(config, AlchemyApiType.NFT, 'searchContractMetadata', srcMethod, {\n            query: query\n          });\n        case 2:\n          response = _context64.sent;\n          return _context64.abrupt(\"return\", response.map(getNftContractFromRaw));\n        case 4:\n        case \"end\":\n          return _context64.stop();\n      }\n    }, _callee61);\n  }));\n}\nfunction _summarizeNftAttributes(config, contractAddress, refreshCache) {\n  var srcMethod = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'summarizeNftAttributes';\n  return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee62() {\n    return _regeneratorRuntime().wrap(function _callee62$(_context65) {\n      while (1) switch (_context65.prev = _context65.next) {\n        case 0:\n          return _context65.abrupt(\"return\", requestHttpWithBackoff(config, AlchemyApiType.NFT, 'summarizeNftAttributes', srcMethod, {\n            contractAddress: contractAddress,\n            refreshCache: refreshCache\n          }));\n        case 1:\n        case \"end\":\n          return _context65.stop();\n      }\n    }, _callee62);\n  }));\n}\nfunction _refreshNftMetadata(config, contractAddress, tokenId) {\n  var srcMethod = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'refreshNftMetadata';\n  return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee63() {\n    var tokenIdString, first, second;\n    return _regeneratorRuntime().wrap(function _callee63$(_context66) {\n      while (1) switch (_context66.prev = _context66.next) {\n        case 0:\n          tokenIdString = BigNumber.from(tokenId).toString();\n          _context66.next = 3;\n          return _getNftMetadata(config, contractAddress, tokenIdString, undefined, srcMethod);\n        case 3:\n          first = _context66.sent;\n          _context66.next = 6;\n          return refresh(config, contractAddress, tokenIdString, srcMethod);\n        case 6:\n          second = _context66.sent;\n          return _context66.abrupt(\"return\", first.timeLastUpdated !== second.timeLastUpdated);\n        case 8:\n        case \"end\":\n          return _context66.stop();\n      }\n    }, _callee63);\n  }));\n}\nfunction _refreshContract(config, contractAddress) {\n  var srcMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'refreshContract';\n  return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee64() {\n    var response;\n    return _regeneratorRuntime().wrap(function _callee64$(_context67) {\n      while (1) switch (_context67.prev = _context67.next) {\n        case 0:\n          _context67.next = 2;\n          return requestHttpWithBackoff(config, AlchemyApiType.NFT, 'reingestContract', srcMethod, {\n            contractAddress: contractAddress\n          });\n        case 2:\n          response = _context67.sent;\n          return _context67.abrupt(\"return\", {\n            contractAddress: response.contractAddress,\n            refreshState: parseReingestionState(response.reingestionState),\n            progress: response.progress\n          });\n        case 4:\n        case \"end\":\n          return _context67.stop();\n      }\n    }, _callee64);\n  }));\n}\nfunction refresh(config, contractAddress, tokenId, srcMethod) {\n  return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee65() {\n    var response;\n    return _regeneratorRuntime().wrap(function _callee65$(_context68) {\n      while (1) switch (_context68.prev = _context68.next) {\n        case 0:\n          _context68.next = 2;\n          return requestHttpWithBackoff(config, AlchemyApiType.NFT, 'getNFTMetadata', srcMethod, {\n            contractAddress: contractAddress,\n            tokenId: BigNumber.from(tokenId).toString(),\n            refreshCache: true\n          });\n        case 2:\n          response = _context68.sent;\n          return _context68.abrupt(\"return\", getNftFromRaw(response));\n        case 4:\n        case \"end\":\n          return _context68.stop();\n      }\n    }, _callee65);\n  }));\n}\n/**\r\n * Helper method to convert a NFT response received from Alchemy backend to an\r\n * SDK NFT type.\r\n *\r\n * @internal\r\n */\nfunction nftFromGetNftResponse(ownedNft) {\n  if (isNftWithMetadata(ownedNft)) {\n    return getNftFromRaw(ownedNft);\n  } else {\n    return getBaseNftFromRaw(ownedNft);\n  }\n}\n/**\r\n * Helper method to convert a NFT response received from Alchemy backend to an\r\n * SDK NFT type.\r\n *\r\n * @internal\r\n */\nfunction nftFromGetNftContractResponse(ownedNft, contractAddress) {\n  if (isNftWithMetadata(ownedNft)) {\n    return getNftFromRaw(ownedNft);\n  } else {\n    return getBaseNftFromRaw(ownedNft, contractAddress);\n  }\n}\n/** @internal */\n// TODO: more comprehensive type check\nfunction isNftWithMetadata(response) {\n  return response.title !== undefined;\n}\n/**\r\n * Given an AssetTransfersResponse, fetches the NFTs associated with the\r\n * transfers and collates them with transfer metadata.\r\n *\r\n * VISIBLE FOR TESTING\r\n */\nfunction getNftsForTransfers(config, response) {\n  return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee66() {\n    var metadataTransfers, batchSize, requestBatches, i, responseBatches, nfts, nftsByTokenId, transferredNfts;\n    return _regeneratorRuntime().wrap(function _callee66$(_context69) {\n      while (1) switch (_context69.prev = _context69.next) {\n        case 0:\n          metadataTransfers = response.transfers.filter(function (transfer) {\n            return transfer.rawContract.address !== null;\n          })\n          // Use flatMap to flatten 1155 transfers that contain multiple NFTs.\n          .flatMap(function (transfer) {\n            var _a;\n            var tokens = getTokensFromTransfer(transfer);\n            var metadata = {\n              from: transfer.from,\n              to: (_a = transfer.to) !== null && _a !== void 0 ? _a : undefined,\n              transactionHash: transfer.hash,\n              blockNumber: transfer.blockNum\n            };\n            return tokens.map(function (token) {\n              return {\n                metadata: metadata,\n                token: token\n              };\n            });\n          });\n          if (!(metadataTransfers.length === 0)) {\n            _context69.next = 3;\n            break;\n          }\n          return _context69.abrupt(\"return\", {\n            nfts: []\n          });\n        case 3:\n          // If we have more than 100 elements after unrolling 1155 transfers, split\n          // transfers into batches of 100 to stay under endpoint batch size limit.\n          batchSize = 100;\n          requestBatches = [];\n          for (i = 0; i < metadataTransfers.length; i += batchSize) {\n            requestBatches.push(metadataTransfers.slice(i, i + batchSize));\n          }\n          _context69.next = 8;\n          return Promise.all(requestBatches.map(function (batch) {\n            return _getNftMetadataBatch(config, batch.map(function (transfer) {\n              return transfer.token;\n            }));\n          }));\n        case 8:\n          responseBatches = _context69.sent;\n          nfts = responseBatches.flat(); // The same NFT can be transferred multiple times in the same transfers response.\n          // We want to return one NFT for each transfer, so we create a mapping for\n          // each NFT to pair with the transfer metadata.\n          nftsByTokenId = new Map();\n          nfts.forEach(function (nft) {\n            var key = \"\".concat(nft.contract.address, \"-\").concat(BigNumber.from(nft.tokenId).toString());\n            nftsByTokenId.set(key, nft);\n          });\n          transferredNfts = metadataTransfers.map(function (t) {\n            var key = \"\".concat(t.token.contractAddress, \"-\").concat(BigNumber.from(t.token.tokenId).toString());\n            return Object.assign(Object.assign({}, nftsByTokenId.get(key)), t.metadata);\n          });\n          return _context69.abrupt(\"return\", {\n            nfts: transferredNfts,\n            pageKey: response.pageKey\n          });\n        case 14:\n        case \"end\":\n          return _context69.stop();\n      }\n    }, _callee66);\n  }));\n}\n/**\r\n * Returns the underlying NFT tokens from a transfer as the params for a\r\n * `getNftMetadataBatch` call. Handles the 1155 case where multiple NFTs can be\r\n * transferred in a single transaction.\r\n */\nfunction getTokensFromTransfer(transfer) {\n  // ERC1155 NFTs can contain multiple tokens in a single transfer, which\n  // requires special logic.\n  if (transfer.category === AssetTransfersCategory.ERC1155) {\n    return parse1155Transfer(transfer);\n  } else {\n    return [{\n      contractAddress: transfer.rawContract.address,\n      tokenId: transfer.tokenId,\n      tokenType: transfer.category === AssetTransfersCategory.ERC721 ? NftTokenType.ERC721 : undefined\n    }];\n  }\n}\n/**\r\n * Flips the `omitMetadata` SDK parameter type to the `withMetadata` parameter\r\n * required by the Alchemy API. If `omitMetadata` is undefined, the SDK defaults\r\n * to including metadata.\r\n *\r\n * @internal\r\n */\nfunction omitMetadataToWithMetadata(omitMetadata) {\n  return omitMetadata === undefined ? true : !omitMetadata;\n}\nfunction parseReingestionState(reingestionState) {\n  switch (reingestionState) {\n    case 'does_not_exist':\n      return RefreshState.DOES_NOT_EXIST;\n    case 'already_queued':\n      return RefreshState.ALREADY_QUEUED;\n    case 'in_progress':\n      return RefreshState.IN_PROGRESS;\n    case 'finished':\n      return RefreshState.FINISHED;\n    case 'queued':\n      return RefreshState.QUEUED;\n    case 'queue_failed':\n      return RefreshState.QUEUE_FAILED;\n    default:\n      throw new Error('Unknown reingestion state: ' + reingestionState);\n  }\n}\n\n/**\r\n * The NFT namespace contains all the functionality related to NFTs.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an Alchemy object\r\n * with `const alchemy = new Alchemy(config)` and then access the core namespace\r\n * via `alchemy.nft`.\r\n */\nvar NftNamespace = /*#__PURE__*/function () {\n  /** @internal */\n  function NftNamespace(config) {\n    _classCallCheck(this, NftNamespace);\n    this.config = config;\n  }\n  _createClass(NftNamespace, [{\n    key: \"getNftMetadata\",\n    value: function getNftMetadata(contractAddress, tokenId, optionsOrTokenType, tokenUriTimeoutInMs) {\n      var options;\n      if (typeof optionsOrTokenType === 'object') {\n        options = {\n          tokenType: optionsOrTokenType.tokenType,\n          tokenUriTimeoutInMs: optionsOrTokenType.tokenUriTimeoutInMs,\n          refreshCache: optionsOrTokenType.refreshCache\n        };\n      } else {\n        options = {\n          tokenType: optionsOrTokenType,\n          tokenUriTimeoutInMs: tokenUriTimeoutInMs\n        };\n      }\n      return _getNftMetadata(this.config, contractAddress, tokenId, options);\n    }\n    /**\r\n     * Gets the NFT metadata for multiple NFT tokens.\r\n     *\r\n     * @param tokens An array of NFT tokens to fetch metadata for.\r\n     * @param options Configuration options for making the request.\r\n     */\n  }, {\n    key: \"getNftMetadataBatch\",\n    value: function getNftMetadataBatch(tokens, options) {\n      return _getNftMetadataBatch(this.config, tokens, options);\n    }\n    /**\r\n     * Get the NFT contract metadata associated with the provided parameters.\r\n     *\r\n     * @param contractAddress - The contract address of the NFT.\r\n     * @public\r\n     */\n  }, {\n    key: \"getContractMetadata\",\n    value: function getContractMetadata(contractAddress) {\n      return _getContractMetadata(this.config, contractAddress);\n    }\n    /**\r\n     * Get the NFT contract metadata for multiple NFT contracts in a single request.\r\n     *\r\n     * @param contractAddresses - An array of contract addresses to fetch metadata for.\r\n     */\n  }, {\n    key: \"getContractMetadataBatch\",\n    value: function getContractMetadataBatch(contractAddresses) {\n      return _getContractMetadataBatch(this.config, contractAddresses);\n    }\n  }, {\n    key: \"getNftsForOwnerIterator\",\n    value: function getNftsForOwnerIterator(owner, options) {\n      return _getNftsForOwnerIterator(this.config, owner, options);\n    }\n  }, {\n    key: \"getNftsForOwner\",\n    value: function getNftsForOwner(owner, options) {\n      return _getNftsForOwner(this.config, owner, options);\n    }\n  }, {\n    key: \"getNftsForContract\",\n    value: function getNftsForContract(contractAddress, options) {\n      return _getNftsForContract(this.config, contractAddress, options);\n    }\n  }, {\n    key: \"getNftsForContractIterator\",\n    value: function getNftsForContractIterator(contractAddress, options) {\n      return _getNftsForContractIterator(this.config, contractAddress, options);\n    }\n  }, {\n    key: \"getOwnersForContract\",\n    value: function getOwnersForContract(contractAddress, options) {\n      return _getOwnersForContract(this.config, contractAddress, options);\n    }\n    /**\r\n     * Gets all the owners for a given NFT contract address and token ID.\r\n     *\r\n     * @param contractAddress - The NFT contract address.\r\n     * @param tokenId - Token id of the NFT.\r\n     * @param options - Optional parameters to use for the request.\r\n     * @beta\r\n     */\n  }, {\n    key: \"getOwnersForNft\",\n    value: function getOwnersForNft(contractAddress, tokenId, options) {\n      return _getOwnersForNft(this.config, contractAddress, tokenId, options);\n    }\n    /**\r\n     * Gets all NFT contracts held by the specified owner address.\r\n     *\r\n     * @param owner - Address for NFT owner (can be in ENS format!).\r\n     * @param options - The optional parameters to use for the request.\r\n     * @public\r\n     */\n  }, {\n    key: \"getContractsForOwner\",\n    value: function getContractsForOwner(owner, options) {\n      return _getContractsForOwner(this.config, owner, options);\n    }\n    /**\r\n     * Gets all NFT transfers for a given owner's address.\r\n     *\r\n     * @param owner The owner to get transfers for.\r\n     * @param category Whether to get transfers to or from the owner address.\r\n     * @param options Additional options for the request.\r\n     */\n  }, {\n    key: \"getTransfersForOwner\",\n    value: function getTransfersForOwner(owner, category, options) {\n      return _getTransfersForOwner(this.config, owner, category, options);\n    }\n    /**\r\n     * Gets all NFT transfers for a given NFT contract address.\r\n     *\r\n     * Defaults to all transfers for the contract. To get transfers for a specific\r\n     * block range, use {@link GetTransfersForContractOptions}.\r\n     *\r\n     * @param contract The NFT contract to get transfers for.\r\n     * @param options Additional options for the request.\r\n     */\n  }, {\n    key: \"getTransfersForContract\",\n    value: function getTransfersForContract(contract, options) {\n      return _getTransfersForContract(this.config, contract, options);\n    }\n    /**\r\n     * Get all the NFTs minted by a specified owner address.\r\n     *\r\n     * @param owner - Address for the NFT owner (can be in ENS format).\r\n     * @param options - The optional parameters to use for the request.\r\n     */\n  }, {\n    key: \"getMintedNfts\",\n    value: function getMintedNfts(owner, options) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee67() {\n        return _regeneratorRuntime().wrap(function _callee67$(_context70) {\n          while (1) switch (_context70.prev = _context70.next) {\n            case 0:\n              return _context70.abrupt(\"return\", _getMintedNfts(this.config, owner, options));\n            case 1:\n            case \"end\":\n              return _context70.stop();\n          }\n        }, _callee67, this);\n      }));\n    }\n    /**\r\n     * DEPRECATED - Checks that the provided owner address owns one of more of the\r\n     * provided NFTs.\r\n     *\r\n     * @deprecated - Use {@link verifyNftOwnership} instead. This method will be\r\n     *   removed in a future release.\r\n     * @param owner - The owner address to check.\r\n     * @param contractAddresses - An array of NFT contract addresses to check ownership for.\r\n     */\n  }, {\n    key: \"checkNftOwnership\",\n    value: function checkNftOwnership(owner, contractAddresses) {\n      return _checkNftOwnership(this.config, owner, contractAddresses);\n    }\n  }, {\n    key: \"verifyNftOwnership\",\n    value: function verifyNftOwnership(owner, contractAddress) {\n      return _verifyNftOwnership(this.config, owner, contractAddress);\n    }\n    /**\r\n     * Returns whether a contract is marked as spam or not by Alchemy. For more\r\n     * information on how we classify spam, go to our NFT API FAQ at\r\n     * https://docs.alchemy.com/alchemy/enhanced-apis/nft-api/nft-api-faq#nft-spam-classification.\r\n     *\r\n     * @param contractAddress - The contract address to check.\r\n     * @beta\r\n     */\n  }, {\n    key: \"isSpamContract\",\n    value: function isSpamContract(contractAddress) {\n      return _isSpamContract(this.config, contractAddress);\n    }\n    /**\r\n     * Returns a list of all spam contracts marked by Alchemy. For details on how\r\n     * Alchemy marks spam contracts, go to\r\n     * https://docs.alchemy.com/alchemy/enhanced-apis/nft-api/nft-api-faq#nft-spam-classification.\r\n     *\r\n     * @beta\r\n     */\n  }, {\n    key: \"getSpamContracts\",\n    value: function getSpamContracts() {\n      return _getSpamContracts(this.config);\n    }\n    /**\r\n     * Returns the floor prices of a NFT contract by marketplace.\r\n     *\r\n     * @param contractAddress - The contract address for the NFT collection.\r\n     * @beta\r\n     */\n  }, {\n    key: \"getFloorPrice\",\n    value: function getFloorPrice(contractAddress) {\n      return _getFloorPrice(this.config, contractAddress);\n    }\n  }, {\n    key: \"getNftSales\",\n    value: function getNftSales(options) {\n      return _getNftSales(this.config, options);\n    }\n    /**\r\n     * Get the rarity of each attribute of an NFT.\r\n     *\r\n     * @param contractAddress - Contract address for the NFT collection.\r\n     * @param tokenId - Token id of the NFT.\r\n     * @param refreshCache - If true, bypass cache and recompute rarity snapshot.\r\n     */\n  }, {\n    key: \"computeRarity\",\n    value: function computeRarity(contractAddress, tokenId, refreshCache) {\n      return _computeRarity(this.config, contractAddress, tokenId, refreshCache);\n    }\n    /**\r\n     * Search for a keyword across metadata of all ERC-721 and ERC-1155 smart contracts.\r\n     *\r\n     * @param query - The search string that you want to search for in contract metadata.\r\n     */\n  }, {\n    key: \"searchContractMetadata\",\n    value: function searchContractMetadata(query) {\n      return _searchContractMetadata(this.config, query);\n    }\n    /**\r\n     * Get a summary of attribute prevalence for an NFT collection.\r\n     *\r\n     * @param contractAddress - Contract address for the NFT collection.\r\n     * @param refreshCache - If true, bypass cache and recompute rarity snapshot.\r\n     */\n  }, {\n    key: \"summarizeNftAttributes\",\n    value: function summarizeNftAttributes(contractAddress, refreshCache) {\n      return _summarizeNftAttributes(this.config, contractAddress, refreshCache);\n    }\n    /**\r\n     * Refreshes the cached metadata for a provided NFT contract address and token\r\n     * id. Returns a boolean value indicating whether the metadata was refreshed.\r\n     *\r\n     * This method is useful when you want to refresh the metadata for a NFT that\r\n     * has been updated since the last time it was fetched. Note that the backend\r\n     * only allows one refresh per token every 15 minutes, globally for all users.\r\n     * The last refresh time for an NFT can be accessed on the\r\n     * {@link Nft.timeLastUpdated} field.\r\n     *\r\n     * To trigger a refresh for all NFTs in a contract, use {@link refreshContract} instead.\r\n     *\r\n     * @param contractAddress - The contract address of the NFT.\r\n     * @param tokenId - The token id of the NFT.\r\n     */\n  }, {\n    key: \"refreshNftMetadata\",\n    value: function refreshNftMetadata(contractAddress, tokenId) {\n      return _refreshNftMetadata(this.config, contractAddress, tokenId);\n    }\n    /**\r\n     * Triggers a metadata refresh all NFTs in the provided contract address. This\r\n     * method is useful after an NFT collection is revealed.\r\n     *\r\n     * Refreshes are queued on the Alchemy backend and may take time to fully\r\n     * process. To refresh the metadata for a specific token, use the\r\n     * {@link refreshNftMetadata} method instead.\r\n     *\r\n     * @param contractAddress - The contract address of the NFT collection.\r\n     * @beta\r\n     */\n  }, {\n    key: \"refreshContract\",\n    value: function refreshContract(contractAddress) {\n      return _refreshContract(this.config, contractAddress);\n    }\n  }]);\n  return NftNamespace;\n}();\n/**\r\n * The Notify namespace contains methods used for creating, reading, updating,\r\n * and deleting webhooks in the Notify API.\r\n *\r\n * To use the methods in the API, you must provide your team's auth token in the\r\n * {@link AlchemySettings.authToken} field when configuring\r\n * {@link AlchemySettings}. The auth token can be found in the Alchemy Dashboard\r\n * on the Notify tab.\r\n *\r\n * Note that not all networks are supported in the Notify API. Please consult\r\n * the documentation for which networks are supported.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an Alchemy object\r\n * with `const alchemy = new Alchemy(config)` and then access the notify\r\n * namespace via `alchemy.notify`.\r\n */\nvar NotifyNamespace = /*#__PURE__*/function () {\n  /** @internal */\n  function NotifyNamespace(config) {\n    _classCallCheck(this, NotifyNamespace);\n    this.config = config;\n  }\n  /**\r\n   * Get all webhooks on your team.\r\n   *\r\n   * The team is determined by the `authToken` provided into the {@link AlchemySettings}\r\n   * object when creating a new {@link Alchemy} instance.\r\n   *\r\n   * This method returns a response object containing all the webhooks\r\n   */\n  _createClass(NotifyNamespace, [{\n    key: \"getAllWebhooks\",\n    value: function getAllWebhooks() {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee68() {\n        var response;\n        return _regeneratorRuntime().wrap(function _callee68$(_context71) {\n          while (1) switch (_context71.prev = _context71.next) {\n            case 0:\n              this.verifyConfig();\n              _context71.next = 3;\n              return this.sendWebhookRequest('team-webhooks', 'getAllWebhooks', {});\n            case 3:\n              response = _context71.sent;\n              return _context71.abrupt(\"return\", {\n                webhooks: parseRawWebhookResponse(response),\n                totalCount: response.data.length\n              });\n            case 5:\n            case \"end\":\n              return _context71.stop();\n          }\n        }, _callee68, this);\n      }));\n    }\n  }, {\n    key: \"getAddresses\",\n    value: function getAddresses(webhookOrId, options) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee69() {\n        var webhookId, response;\n        return _regeneratorRuntime().wrap(function _callee69$(_context72) {\n          while (1) switch (_context72.prev = _context72.next) {\n            case 0:\n              this.verifyConfig();\n              webhookId = typeof webhookOrId === 'string' ? webhookOrId : webhookOrId.id;\n              _context72.next = 4;\n              return this.sendWebhookRequest('webhook-addresses', 'getAddresses', {\n                webhook_id: webhookId,\n                limit: options === null || options === void 0 ? void 0 : options.limit,\n                after: options === null || options === void 0 ? void 0 : options.pageKey\n              });\n            case 4:\n              response = _context72.sent;\n              return _context72.abrupt(\"return\", parseRawAddressActivityResponse(response));\n            case 6:\n            case \"end\":\n              return _context72.stop();\n          }\n        }, _callee69, this);\n      }));\n    }\n  }, {\n    key: \"getGraphqlQuery\",\n    value: function getGraphqlQuery(webhookOrId) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee70() {\n        var webhookId, response;\n        return _regeneratorRuntime().wrap(function _callee70$(_context73) {\n          while (1) switch (_context73.prev = _context73.next) {\n            case 0:\n              this.verifyConfig();\n              webhookId = typeof webhookOrId === 'string' ? webhookOrId : webhookOrId.id;\n              _context73.next = 4;\n              return this.sendWebhookRequest('dashboard-webhook-graphql-query', 'getGraphqlQuery', {\n                webhook_id: webhookId\n              });\n            case 4:\n              response = _context73.sent;\n              return _context73.abrupt(\"return\", parseRawCustomGraphqlWebhookResponse(response));\n            case 6:\n            case \"end\":\n              return _context73.stop();\n          }\n        }, _callee70, this);\n      }));\n    }\n  }, {\n    key: \"getNftFilters\",\n    value: function getNftFilters(webhookOrId, options) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee71() {\n        var webhookId, response;\n        return _regeneratorRuntime().wrap(function _callee71$(_context74) {\n          while (1) switch (_context74.prev = _context74.next) {\n            case 0:\n              this.verifyConfig();\n              webhookId = typeof webhookOrId === 'string' ? webhookOrId : webhookOrId.id;\n              _context74.next = 4;\n              return this.sendWebhookRequest('webhook-nft-filters', 'getNftFilters', {\n                webhook_id: webhookId,\n                limit: options === null || options === void 0 ? void 0 : options.limit,\n                after: options === null || options === void 0 ? void 0 : options.pageKey\n              });\n            case 4:\n              response = _context74.sent;\n              return _context74.abrupt(\"return\", parseRawNftFiltersResponse(response));\n            case 6:\n            case \"end\":\n              return _context74.stop();\n          }\n        }, _callee71, this);\n      }));\n    }\n  }, {\n    key: \"updateWebhook\",\n    value: function updateWebhook(webhookOrId, update) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee72() {\n        var webhookId, restApiName, methodName, method, data;\n        return _regeneratorRuntime().wrap(function _callee72$(_context75) {\n          while (1) switch (_context75.prev = _context75.next) {\n            case 0:\n              webhookId = typeof webhookOrId === 'string' ? webhookOrId : webhookOrId.id;\n              if (!('isActive' in update)) {\n                _context75.next = 8;\n                break;\n              }\n              restApiName = 'update-webhook';\n              methodName = 'updateWebhook';\n              method = 'PUT';\n              data = {\n                webhook_id: webhookId,\n                is_active: update.isActive\n              };\n              _context75.next = 48;\n              break;\n            case 8:\n              if (!('addFilters' in update || 'removeFilters' in update)) {\n                _context75.next = 15;\n                break;\n              }\n              restApiName = 'update-webhook-nft-filters';\n              methodName = 'updateWebhookNftFilters';\n              method = 'PATCH';\n              data = {\n                webhook_id: webhookId,\n                nft_filters_to_add: update.addFilters ? update.addFilters.map(nftFilterToParam) : [],\n                nft_filters_to_remove: update.removeFilters ? update.removeFilters.map(nftFilterToParam) : []\n              };\n              _context75.next = 48;\n              break;\n            case 15:\n              if (!('addMetadataFilters' in update || 'removeMetadataFilters' in update)) {\n                _context75.next = 22;\n                break;\n              }\n              restApiName = 'update-webhook-nft-metadata-filters';\n              methodName = 'updateWebhookNftMetadataFilters';\n              method = 'PATCH';\n              data = {\n                webhook_id: webhookId,\n                nft_metadata_filters_to_add: update.addMetadataFilters ? update.addMetadataFilters.map(nftFilterToParam) : [],\n                nft_metadata_filters_to_remove: update.removeMetadataFilters ? update.removeMetadataFilters.map(nftFilterToParam) : []\n              };\n              _context75.next = 48;\n              break;\n            case 22:\n              if (!('addAddresses' in update || 'removeAddresses' in update)) {\n                _context75.next = 36;\n                break;\n              }\n              restApiName = 'update-webhook-addresses';\n              methodName = 'webhook:updateWebhookAddresses';\n              method = 'PATCH';\n              _context75.t0 = webhookId;\n              _context75.next = 29;\n              return this.resolveAddresses(update.addAddresses);\n            case 29:\n              _context75.t1 = _context75.sent;\n              _context75.next = 32;\n              return this.resolveAddresses(update.removeAddresses);\n            case 32:\n              _context75.t2 = _context75.sent;\n              data = {\n                webhook_id: _context75.t0,\n                addresses_to_add: _context75.t1,\n                addresses_to_remove: _context75.t2\n              };\n              _context75.next = 48;\n              break;\n            case 36:\n              if (!('newAddresses' in update)) {\n                _context75.next = 47;\n                break;\n              }\n              restApiName = 'update-webhook-addresses';\n              methodName = 'webhook:updateWebhookAddress';\n              method = 'PUT';\n              _context75.t3 = webhookId;\n              _context75.next = 43;\n              return this.resolveAddresses(update.newAddresses);\n            case 43:\n              _context75.t4 = _context75.sent;\n              data = {\n                webhook_id: _context75.t3,\n                addresses: _context75.t4\n              };\n              _context75.next = 48;\n              break;\n            case 47:\n              throw new Error('Invalid `update` param passed into `updateWebhook`');\n            case 48:\n              _context75.next = 50;\n              return this.sendWebhookRequest(restApiName, methodName, {}, {\n                method: method,\n                data: data\n              });\n            case 50:\n            case \"end\":\n              return _context75.stop();\n          }\n        }, _callee72, this);\n      }));\n    }\n  }, {\n    key: \"createWebhook\",\n    value: function createWebhook(url, type, params) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee73() {\n        var appId, network, nftFilterObj, addresses, graphqlQuery, filters, data, response;\n        return _regeneratorRuntime().wrap(function _callee73$(_context76) {\n          while (1) switch (_context76.prev = _context76.next) {\n            case 0:\n              if (!(type === WebhookType.MINED_TRANSACTION || type === WebhookType.DROPPED_TRANSACTION)) {\n                _context76.next = 4;\n                break;\n              }\n              if ('appId' in params) {\n                _context76.next = 3;\n                break;\n              }\n              throw new Error('Transaction Webhooks require an app id.');\n            case 3:\n              appId = params.appId;\n            case 4:\n              network = NETWORK_TO_WEBHOOK_NETWORK.get(this.config.network);\n              if (!(type === WebhookType.NFT_ACTIVITY || type === WebhookType.NFT_METADATA_UPDATE)) {\n                _context76.next = 13;\n                break;\n              }\n              if (!(!('filters' in params) || params.filters.length === 0)) {\n                _context76.next = 8;\n                break;\n              }\n              throw new Error('Nft Activity Webhooks require a non-empty array input.');\n            case 8:\n              network = params.network ? NETWORK_TO_WEBHOOK_NETWORK.get(params.network) : network;\n              filters = params.filters.map(function (filter) {\n                return filter.tokenId ? {\n                  contract_address: filter.contractAddress,\n                  token_id: BigNumber.from(filter.tokenId).toString()\n                } : {\n                  contract_address: filter.contractAddress\n                };\n              });\n              nftFilterObj = type === WebhookType.NFT_ACTIVITY ? {\n                nft_filters: filters\n              } : {\n                nft_metadata_filters: filters\n              };\n              _context76.next = 27;\n              break;\n            case 13:\n              if (!(type === WebhookType.ADDRESS_ACTIVITY)) {\n                _context76.next = 22;\n                break;\n              }\n              if (!(params === undefined || !('addresses' in params) || params.addresses.length === 0)) {\n                _context76.next = 16;\n                break;\n              }\n              throw new Error('Address Activity Webhooks require a non-empty array input.');\n            case 16:\n              network = params.network ? NETWORK_TO_WEBHOOK_NETWORK.get(params.network) : network;\n              _context76.next = 19;\n              return this.resolveAddresses(params.addresses);\n            case 19:\n              addresses = _context76.sent;\n              _context76.next = 27;\n              break;\n            case 22:\n              if (!(type == WebhookType.GRAPHQL)) {\n                _context76.next = 27;\n                break;\n              }\n              if (!(params === undefined || !('graphqlQuery' in params) || params.graphqlQuery.length === 0)) {\n                _context76.next = 25;\n                break;\n              }\n              throw new Error('Custom Webhooks require a non-empty graphql query.');\n            case 25:\n              network = params.network ? NETWORK_TO_WEBHOOK_NETWORK.get(params.network) : network;\n              graphqlQuery = params.graphqlQuery;\n            case 27:\n              data = Object.assign(Object.assign(Object.assign(Object.assign({\n                network: network,\n                webhook_type: type,\n                webhook_url: url\n              }, appId && {\n                app_id: appId\n              }), nftFilterObj), addresses && {\n                addresses: addresses\n              }), graphqlQuery && {\n                graphql_query: graphqlQuery\n              });\n              _context76.next = 30;\n              return this.sendWebhookRequest('create-webhook', 'createWebhook', {}, {\n                method: 'POST',\n                data: data\n              });\n            case 30:\n              response = _context76.sent;\n              return _context76.abrupt(\"return\", parseRawWebhook(response.data));\n            case 32:\n            case \"end\":\n              return _context76.stop();\n          }\n        }, _callee73, this);\n      }));\n    }\n  }, {\n    key: \"deleteWebhook\",\n    value: function deleteWebhook(webhookOrId) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee74() {\n        var webhookId, response;\n        return _regeneratorRuntime().wrap(function _callee74$(_context77) {\n          while (1) switch (_context77.prev = _context77.next) {\n            case 0:\n              this.verifyConfig();\n              webhookId = typeof webhookOrId === 'string' ? webhookOrId : webhookOrId.id;\n              _context77.next = 4;\n              return this.sendWebhookRequest('delete-webhook', 'deleteWebhook', {\n                webhook_id: webhookId\n              }, {\n                method: 'DELETE'\n              });\n            case 4:\n              response = _context77.sent;\n              if (!('message' in response)) {\n                _context77.next = 7;\n                break;\n              }\n              throw new Error(\"Webhook not found. Failed to delete webhook: \".concat(webhookId));\n            case 7:\n            case \"end\":\n              return _context77.stop();\n          }\n        }, _callee74, this);\n      }));\n    }\n  }, {\n    key: \"verifyConfig\",\n    value: function verifyConfig() {\n      if (this.config.authToken === undefined) {\n        throw new Error('Using the Notify API requires setting the Alchemy Auth Token in ' + 'the settings object when initializing Alchemy.');\n      }\n    }\n  }, {\n    key: \"sendWebhookRequest\",\n    value: function sendWebhookRequest(restApiName, methodName, params, overrides) {\n      return requestHttpWithBackoff(this.config, AlchemyApiType.WEBHOOK, restApiName, methodName, params, Object.assign(Object.assign({}, overrides), {\n        headers: Object.assign({\n          'X-Alchemy-Token': this.config.authToken\n        }, overrides === null || overrides === void 0 ? void 0 : overrides.headers)\n      }));\n    }\n    /** Resolves ENS addresses to the raw address.\r\n     * @internal */\n  }, {\n    key: \"resolveAddresses\",\n    value: function resolveAddresses(addresses) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee75() {\n        var resolvedAddresses, provider, _iterator4, _step4, address, rawAddress;\n        return _regeneratorRuntime().wrap(function _callee75$(_context78) {\n          while (1) switch (_context78.prev = _context78.next) {\n            case 0:\n              if (!(addresses === undefined)) {\n                _context78.next = 2;\n                break;\n              }\n              return _context78.abrupt(\"return\", []);\n            case 2:\n              resolvedAddresses = [];\n              _context78.next = 5;\n              return this.config.getProvider();\n            case 5:\n              provider = _context78.sent;\n              _iterator4 = _createForOfIteratorHelper(addresses);\n              _context78.prev = 7;\n              _iterator4.s();\n            case 9:\n              if ((_step4 = _iterator4.n()).done) {\n                _context78.next = 19;\n                break;\n              }\n              address = _step4.value;\n              _context78.next = 13;\n              return provider.resolveName(address);\n            case 13:\n              rawAddress = _context78.sent;\n              if (!(rawAddress === null)) {\n                _context78.next = 16;\n                break;\n              }\n              throw new Error(\"Unable to resolve the ENS address: \".concat(address));\n            case 16:\n              resolvedAddresses.push(rawAddress);\n            case 17:\n              _context78.next = 9;\n              break;\n            case 19:\n              _context78.next = 24;\n              break;\n            case 21:\n              _context78.prev = 21;\n              _context78.t0 = _context78[\"catch\"](7);\n              _iterator4.e(_context78.t0);\n            case 24:\n              _context78.prev = 24;\n              _iterator4.f();\n              return _context78.finish(24);\n            case 27:\n              return _context78.abrupt(\"return\", resolvedAddresses);\n            case 28:\n            case \"end\":\n              return _context78.stop();\n          }\n        }, _callee75, this, [[7, 21, 24, 27]]);\n      }));\n    }\n  }]);\n  return NotifyNamespace;\n}();\n/**\r\n * Mapping of webhook network representations to the SDK's network representation.\r\n *\r\n * @internal\r\n */\nvar WEBHOOK_NETWORK_TO_NETWORK = {\n  ETH_MAINNET: Network.ETH_MAINNET,\n  ETH_GOERLI: Network.ETH_GOERLI,\n  ETH_SEPOLIA: Network.ETH_SEPOLIA,\n  ETH_ROPSTEN: Network.ETH_ROPSTEN,\n  ETH_RINKEBY: Network.ETH_RINKEBY,\n  ETH_KOVAN: Network.ETH_KOVAN,\n  MATIC_MAINNET: Network.MATIC_MAINNET,\n  MATIC_MUMBAI: Network.MATIC_MUMBAI,\n  ARB_MAINNET: Network.ARB_MAINNET,\n  ARB_GOERLI: Network.ARB_GOERLI,\n  ARB_RINKEBY: Network.ARB_RINKEBY,\n  OPT_MAINNET: Network.OPT_MAINNET,\n  OPT_GOERLI: Network.OPT_GOERLI,\n  OPT_KOVAN: Network.OPT_KOVAN\n};\n/** Mapping of the SDK's network representation the webhook API's network representation. */\nvar NETWORK_TO_WEBHOOK_NETWORK = Object.keys(Network).reduce(function (map, key) {\n  if (key in WEBHOOK_NETWORK_TO_NETWORK) {\n    map.set(WEBHOOK_NETWORK_TO_NETWORK[key], key);\n  }\n  return map;\n}, new Map());\nfunction parseRawWebhookResponse(response) {\n  return response.data.map(parseRawWebhook);\n}\nfunction parseRawWebhook(rawWebhook) {\n  return Object.assign({\n    id: rawWebhook.id,\n    network: WEBHOOK_NETWORK_TO_NETWORK[rawWebhook.network],\n    type: rawWebhook.webhook_type,\n    url: rawWebhook.webhook_url,\n    isActive: rawWebhook.is_active,\n    timeCreated: new Date(rawWebhook.time_created).toISOString(),\n    signingKey: rawWebhook.signing_key,\n    version: rawWebhook.version\n  }, rawWebhook.app_id !== undefined && {\n    appId: rawWebhook.app_id\n  });\n}\nfunction parseRawAddressActivityResponse(response) {\n  return {\n    addresses: response.data,\n    totalCount: response.pagination.total_count,\n    pageKey: response.pagination.cursors.after\n  };\n}\nfunction parseRawCustomGraphqlWebhookResponse(response) {\n  return {\n    graphqlQuery: response.data.graphql_query\n  };\n}\nfunction parseRawNftFiltersResponse(response) {\n  return {\n    filters: response.data.map(function (f) {\n      return f.token_id ? {\n        contractAddress: f.contract_address,\n        tokenId: BigNumber.from(f.token_id).toString()\n      } : {\n        contractAddress: f.contract_address\n      };\n    }),\n    totalCount: response.pagination.total_count,\n    pageKey: response.pagination.cursors.after\n  };\n}\nfunction nftFilterToParam(filter) {\n  return filter.tokenId ? {\n    contract_address: filter.contractAddress,\n    token_id: BigNumber.from(filter.tokenId).toString()\n  } : {\n    contract_address: filter.contractAddress\n  };\n}\n\n/**\r\n * Multiples to increment fee per gas when using\r\n * {@link TransactNamespace.sendGasOptimizedTransaction}.\r\n *\r\n * @internal\r\n */\nvar GAS_OPTIMIZED_TX_FEE_MULTIPLES = [0.9, 1, 1.1, 1.2, 1.3];\n/**\r\n * The Transact namespace contains methods used for sending transactions and\r\n * checking on the state of submitted transactions.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an Alchemy object\r\n * with `const alchemy = new Alchemy(config)` and then access the transact\r\n * namespace via `alchemy.transact`.\r\n */\nvar TransactNamespace = /*#__PURE__*/function () {\n  /** @internal */\n  function TransactNamespace(config) {\n    _classCallCheck(this, TransactNamespace);\n    this.config = config;\n  }\n  /**\r\n   * Used to send a single transaction to Flashbots. Flashbots will attempt to\r\n   * send the transaction to miners for the next 25 blocks.\r\n   *\r\n   * Returns the transaction hash of the submitted transaction.\r\n   *\r\n   * @param signedTransaction The raw, signed transaction as a hash.\r\n   * @param maxBlockNumber Optional highest block number in which the\r\n   *   transaction should be included.\r\n   * @param options Options to configure the request.\r\n   */\n  _createClass(TransactNamespace, [{\n    key: \"sendPrivateTransaction\",\n    value: function sendPrivateTransaction(signedTransaction, maxBlockNumber, options) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee76() {\n        var provider, hexBlockNumber;\n        return _regeneratorRuntime().wrap(function _callee76$(_context79) {\n          while (1) switch (_context79.prev = _context79.next) {\n            case 0:\n              _context79.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context79.sent;\n              hexBlockNumber = maxBlockNumber ? toHex(maxBlockNumber) : undefined;\n              return _context79.abrupt(\"return\", provider._send('eth_sendPrivateTransaction', [{\n                tx: signedTransaction,\n                maxBlockNumber: hexBlockNumber,\n                preferences: options\n              }], 'sendPrivateTransaction'));\n            case 5:\n            case \"end\":\n              return _context79.stop();\n          }\n        }, _callee76, this);\n      }));\n    }\n    /**\r\n     * Stops the provided private transaction from being submitted for future\r\n     * blocks. A transaction can only be cancelled if the request is signed by the\r\n     * same key as the {@link sendPrivateTransaction} call submitting the\r\n     * transaction in first place.\r\n     *\r\n     * Please note that fast mode transactions cannot be cancelled using this method.\r\n     *\r\n     * Returns a boolean indicating whether the cancellation was successful.\r\n     *\r\n     * @param transactionHash Transaction hash of private tx to be cancelled\r\n     */\n  }, {\n    key: \"cancelPrivateTransaction\",\n    value: function cancelPrivateTransaction(transactionHash) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee77() {\n        var provider;\n        return _regeneratorRuntime().wrap(function _callee77$(_context80) {\n          while (1) switch (_context80.prev = _context80.next) {\n            case 0:\n              _context80.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context80.sent;\n              return _context80.abrupt(\"return\", provider._send('eth_cancelPrivateTransaction', [{\n                txHash: transactionHash\n              }], 'cancelPrivateTransaction'));\n            case 4:\n            case \"end\":\n              return _context80.stop();\n          }\n        }, _callee77, this);\n      }));\n    }\n    /**\r\n     * Simulates the asset changes resulting from a list of transactions simulated\r\n     * in sequence.\r\n     *\r\n     * Returns a list of asset changes for each transaction during simulation.\r\n     *\r\n     * @param transactions Transactions list of max 3 transactions to simulate.\r\n     * @param blockIdentifier Optional block identifier to simulate the\r\n     * transaction in.\r\n     */\n  }, {\n    key: \"simulateAssetChangesBundle\",\n    value: function simulateAssetChangesBundle(transactions, blockIdentifier) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee78() {\n        var provider, params, res;\n        return _regeneratorRuntime().wrap(function _callee78$(_context81) {\n          while (1) switch (_context81.prev = _context81.next) {\n            case 0:\n              _context81.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context81.sent;\n              params = blockIdentifier !== undefined ? [transactions, blockIdentifier] : [transactions];\n              _context81.next = 6;\n              return provider._send('alchemy_simulateAssetChangesBundle', params, 'simulateAssetChangesBundle');\n            case 6:\n              res = _context81.sent;\n              return _context81.abrupt(\"return\", nullsToUndefined(res));\n            case 8:\n            case \"end\":\n              return _context81.stop();\n          }\n        }, _callee78, this);\n      }));\n    }\n    /**\r\n     * Simulates the asset changes resulting from a single transaction.\r\n     *\r\n     * Returns list of asset changes that occurred during the transaction\r\n     * simulation. Note that this method does not run the transaction on the\r\n     * blockchain.\r\n     *\r\n     * @param transaction The transaction to simulate.\r\n     * @param blockIdentifier Optional block identifier to simulate the\r\n     * transaction in.\r\n     */\n  }, {\n    key: \"simulateAssetChanges\",\n    value: function simulateAssetChanges(transaction, blockIdentifier) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee79() {\n        var provider, params, res;\n        return _regeneratorRuntime().wrap(function _callee79$(_context82) {\n          while (1) switch (_context82.prev = _context82.next) {\n            case 0:\n              _context82.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context82.sent;\n              params = blockIdentifier !== undefined ? [transaction, blockIdentifier] : [transaction];\n              _context82.next = 6;\n              return provider._send('alchemy_simulateAssetChanges', params, 'simulateAssetChanges');\n            case 6:\n              res = _context82.sent;\n              return _context82.abrupt(\"return\", nullsToUndefined(res));\n            case 8:\n            case \"end\":\n              return _context82.stop();\n          }\n        }, _callee79, this);\n      }));\n    }\n    /**\r\n     * Simulates a list of transactions in sequence and returns list of decoded\r\n     * traces and logs that occurred for each transaction during simulation.\r\n     *\r\n     * Note that this method does not run any transactions on the blockchain.\r\n     *\r\n     * @param transactions Transactions list of max 3 transactions to simulate.\r\n     * @param blockIdentifier Optional block identifier to simulate the\r\n     * transaction in.\r\n     */\n  }, {\n    key: \"simulateExecutionBundle\",\n    value: function simulateExecutionBundle(transactions, blockIdentifier) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee80() {\n        var provider, params, res;\n        return _regeneratorRuntime().wrap(function _callee80$(_context83) {\n          while (1) switch (_context83.prev = _context83.next) {\n            case 0:\n              _context83.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context83.sent;\n              params = blockIdentifier !== undefined ? [transactions, blockIdentifier] : [transactions];\n              res = provider._send('alchemy_simulateExecutionBundle', params, 'simulateExecutionBundle');\n              return _context83.abrupt(\"return\", nullsToUndefined(res));\n            case 6:\n            case \"end\":\n              return _context83.stop();\n          }\n        }, _callee80, this);\n      }));\n    }\n    /**\r\n     * Simulates a single transaction and the resulting and returns list of\r\n     * decoded traces and logs that occurred during the transaction simulation.\r\n     *\r\n     * Note that this method does not run the transaction on the blockchain.\r\n     *\r\n     * @param transaction The transaction to simulate.\r\n     * @param blockIdentifier Optional block identifier to simulate the\r\n     * transaction in.\r\n     */\n  }, {\n    key: \"simulateExecution\",\n    value: function simulateExecution(transaction, blockIdentifier) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee81() {\n        var provider, params, res;\n        return _regeneratorRuntime().wrap(function _callee81$(_context84) {\n          while (1) switch (_context84.prev = _context84.next) {\n            case 0:\n              _context84.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context84.sent;\n              params = blockIdentifier !== undefined ? [transaction, blockIdentifier] : [transaction];\n              res = provider._send('alchemy_simulateExecution', params, 'simulateExecution');\n              return _context84.abrupt(\"return\", nullsToUndefined(res));\n            case 6:\n            case \"end\":\n              return _context84.stop();\n          }\n        }, _callee81, this);\n      }));\n    }\n    /**\r\n     * Returns the transaction with hash or null if the transaction is unknown.\r\n     *\r\n     * If a transaction has not been mined, this method will search the\r\n     * transaction pool. Various backends may have more restrictive transaction\r\n     * pool access (e.g. if the gas price is too low or the transaction was only\r\n     * recently sent and not yet indexed) in which case this method may also return null.\r\n     *\r\n     * NOTE: This is an alias for {@link CoreNamespace.getTransaction}.\r\n     *\r\n     * @param transactionHash The hash of the transaction to get.\r\n     * @public\r\n     */\n  }, {\n    key: \"getTransaction\",\n    value: function getTransaction(transactionHash) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee82() {\n        var provider;\n        return _regeneratorRuntime().wrap(function _callee82$(_context85) {\n          while (1) switch (_context85.prev = _context85.next) {\n            case 0:\n              _context85.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context85.sent;\n              return _context85.abrupt(\"return\", provider.getTransaction(transactionHash));\n            case 4:\n            case \"end\":\n              return _context85.stop();\n          }\n        }, _callee82, this);\n      }));\n    }\n    /**\r\n     * Submits transaction to the network to be mined. The transaction must be\r\n     * signed, and be valid (i.e. the nonce is correct and the account has\r\n     * sufficient balance to pay for the transaction).\r\n     *\r\n     * NOTE: This is an alias for {@link CoreNamespace.sendTransaction}.\r\n     *\r\n     * @param signedTransaction The signed transaction to send.\r\n     * @public\r\n     */\n  }, {\n    key: \"sendTransaction\",\n    value: function sendTransaction(signedTransaction) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee83() {\n        var provider;\n        return _regeneratorRuntime().wrap(function _callee83$(_context86) {\n          while (1) switch (_context86.prev = _context86.next) {\n            case 0:\n              _context86.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context86.sent;\n              return _context86.abrupt(\"return\", provider.sendTransaction(signedTransaction));\n            case 4:\n            case \"end\":\n              return _context86.stop();\n          }\n        }, _callee83, this);\n      }));\n    }\n    /**\r\n     * Returns an estimate of the amount of gas that would be required to submit\r\n     * transaction to the network.\r\n     *\r\n     * An estimate may not be accurate since there could be another transaction on\r\n     * the network that was not accounted for, but after being mined affects the\r\n     * relevant state.\r\n     *\r\n     * This is an alias for {@link CoreNamespace.estimateGas}.\r\n     *\r\n     * @param transaction The transaction to estimate gas for.\r\n     * @public\r\n     */\n  }, {\n    key: \"estimateGas\",\n    value: function estimateGas(transaction) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee84() {\n        var provider;\n        return _regeneratorRuntime().wrap(function _callee84$(_context87) {\n          while (1) switch (_context87.prev = _context87.next) {\n            case 0:\n              _context87.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context87.sent;\n              return _context87.abrupt(\"return\", provider.estimateGas(transaction));\n            case 4:\n            case \"end\":\n              return _context87.stop();\n          }\n        }, _callee84, this);\n      }));\n    }\n    /**\r\n     * Returns a fee per gas (in wei) that is an estimate of how much you can pay\r\n     * as a priority fee, or \"tip\", to get a transaction included in the current block.\r\n     *\r\n     * This number is generally used to set the `maxPriorityFeePerGas` field in a\r\n     * transaction request.\r\n     *\r\n     * @public\r\n     */\n  }, {\n    key: \"getMaxPriorityFeePerGas\",\n    value: function getMaxPriorityFeePerGas() {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee85() {\n        var provider, feeHex;\n        return _regeneratorRuntime().wrap(function _callee85$(_context88) {\n          while (1) switch (_context88.prev = _context88.next) {\n            case 0:\n              _context88.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context88.sent;\n              _context88.next = 5;\n              return provider._send('eth_maxPriorityFeePerGas', [], 'getMaxPriorityFeePerGas');\n            case 5:\n              feeHex = _context88.sent;\n              return _context88.abrupt(\"return\", fromHex(feeHex));\n            case 7:\n            case \"end\":\n              return _context88.stop();\n          }\n        }, _callee85, this);\n      }));\n    }\n    /**\r\n     * Returns a promise which will not resolve until specified transaction hash is mined.\r\n     *\r\n     * If {@link confirmations} is 0, this method is non-blocking and if the\r\n     * transaction has not been mined returns null. Otherwise, this method will\r\n     * block until the transaction has confirmed blocks mined on top of the block\r\n     * in which it was mined.\r\n     *\r\n     * NOTE: This is an alias for {@link CoreNamespace.waitForTransaction}.\r\n     *\r\n     * @param transactionHash The hash of the transaction to wait for.\r\n     * @param confirmations The number of blocks to wait for.\r\n     * @param timeout The maximum time to wait for the transaction to confirm.\r\n     * @public\r\n     */\n  }, {\n    key: \"waitForTransaction\",\n    value: function waitForTransaction(transactionHash, confirmations, timeout) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee86() {\n        var provider;\n        return _regeneratorRuntime().wrap(function _callee86$(_context89) {\n          while (1) switch (_context89.prev = _context89.next) {\n            case 0:\n              _context89.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context89.sent;\n              return _context89.abrupt(\"return\", provider.waitForTransaction(transactionHash, confirmations, timeout));\n            case 4:\n            case \"end\":\n              return _context89.stop();\n          }\n        }, _callee86, this);\n      }));\n    }\n  }, {\n    key: \"sendGasOptimizedTransaction\",\n    value: function sendGasOptimizedTransaction(transactionOrSignedTxs, wallet) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee87() {\n        var gasLimit, priorityFee, baseFee, provider, currentBlock, gasSpreadTransactions, signedTransactions;\n        return _regeneratorRuntime().wrap(function _callee87$(_context90) {\n          while (1) switch (_context90.prev = _context90.next) {\n            case 0:\n              if (!Array.isArray(transactionOrSignedTxs)) {\n                _context90.next = 2;\n                break;\n              }\n              return _context90.abrupt(\"return\", this._sendGasOptimizedTransaction(transactionOrSignedTxs, 'sendGasOptimizedTransactionPreSigned'));\n            case 2:\n              _context90.next = 4;\n              return this.config.getProvider();\n            case 4:\n              provider = _context90.sent;\n              _context90.prev = 5;\n              _context90.next = 8;\n              return this.estimateGas(transactionOrSignedTxs);\n            case 8:\n              gasLimit = _context90.sent;\n              _context90.next = 11;\n              return this.getMaxPriorityFeePerGas();\n            case 11:\n              priorityFee = _context90.sent;\n              _context90.next = 14;\n              return provider.getBlock('latest');\n            case 14:\n              currentBlock = _context90.sent;\n              baseFee = currentBlock.baseFeePerGas.toNumber();\n              _context90.next = 21;\n              break;\n            case 18:\n              _context90.prev = 18;\n              _context90.t0 = _context90[\"catch\"](5);\n              throw new Error(\"Failed to estimate gas for transaction: \".concat(_context90.t0));\n            case 21:\n              gasSpreadTransactions = generateGasSpreadTransactions(transactionOrSignedTxs, gasLimit.toNumber(), baseFee, priorityFee);\n              _context90.next = 24;\n              return Promise.all(gasSpreadTransactions.map(function (tx) {\n                return wallet.signTransaction(tx);\n              }));\n            case 24:\n              signedTransactions = _context90.sent;\n              return _context90.abrupt(\"return\", this._sendGasOptimizedTransaction(signedTransactions, 'sendGasOptimizedTransactionGenerated'));\n            case 26:\n            case \"end\":\n              return _context90.stop();\n          }\n        }, _callee87, this, [[5, 18]]);\n      }));\n    }\n    /**\r\n     * Returns the state of the transaction job returned by the\r\n     * {@link sendGasOptimizedTransaction}.\r\n     *\r\n     * @param trackingId The tracking id from the response of the sent gas optimized transaction.\r\n     * @internal\r\n     */\n    // TODO(txjob): Remove internal tag once this feature is released.\n  }, {\n    key: \"getGasOptimizedTransactionStatus\",\n    value: function getGasOptimizedTransactionStatus(trackingId) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee88() {\n        var provider;\n        return _regeneratorRuntime().wrap(function _callee88$(_context91) {\n          while (1) switch (_context91.prev = _context91.next) {\n            case 0:\n              _context91.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context91.sent;\n              return _context91.abrupt(\"return\", provider._send('alchemy_getGasOptimizedTransactionStatus', [trackingId], 'getGasOptimizedTransactionStatus'));\n            case 4:\n            case \"end\":\n              return _context91.stop();\n          }\n        }, _callee88, this);\n      }));\n    }\n    /** @internal */\n  }, {\n    key: \"_sendGasOptimizedTransaction\",\n    value: function _sendGasOptimizedTransaction(signedTransactions, methodName) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee89() {\n        var provider;\n        return _regeneratorRuntime().wrap(function _callee89$(_context92) {\n          while (1) switch (_context92.prev = _context92.next) {\n            case 0:\n              _context92.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context92.sent;\n              return _context92.abrupt(\"return\", provider._send('alchemy_sendGasOptimizedTransaction', [{\n                rawTransactions: signedTransactions\n              }], methodName));\n            case 4:\n            case \"end\":\n              return _context92.stop();\n          }\n        }, _callee89, this);\n      }));\n    }\n  }]);\n  return TransactNamespace;\n}();\n/**\r\n * Helper method to generate the raw transaction with the given gas limit and\r\n * priority fee across a spread of different gas prices.\r\n *\r\n * @internal\r\n */\n// Visible for testing\nfunction generateGasSpreadTransactions(transaction, gasLimit, baseFee, priorityFee) {\n  return GAS_OPTIMIZED_TX_FEE_MULTIPLES.map(function (feeMultiplier) {\n    return Object.assign(Object.assign({}, transaction), {\n      gasLimit: gasLimit,\n      maxFeePerGas: Math.round(baseFee * feeMultiplier + priorityFee * feeMultiplier),\n      maxPriorityFeePerGas: Math.round(feeMultiplier * priorityFee)\n    });\n  });\n}\n\n/** This file contains internal types used by the SDK and are not exposed to the end user. */\n/**\r\n * Prefix for `alchemy_pendingTransactions` subscriptions when serializing to\r\n * ethers events.\r\n *\r\n * This tag is used internally by ethers to track different event filters.\r\n */\nvar ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE = 'alchemy-pending-transactions';\n/**\r\n * Prefix for `alchemy_minedTransactions` subscriptions when serializing to ethers events.\r\n *\r\n * This tag is used internally by ethers to track different event filters.\r\n */\nvar ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE = 'alchemy-mined-transactions';\n/**\r\n * Array containing all the custom event tags used internally by ethers to track\r\n * event filters.\r\n */\nvar ALCHEMY_EVENT_TYPES = [ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE, ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE];\n\n/**\r\n * DO NOT MODIFY.\r\n *\r\n * Event class copied directly over from ethers.js's `BaseProvider` class.\r\n *\r\n * This class is used to represent events and their corresponding listeners. The\r\n * SDK needs to extend this class in order to support Alchemy's custom\r\n * Subscription API types. The original class is not exported by ethers. Minimal\r\n * changes have been made in order to get TS to compile.\r\n */\nvar Event = /*#__PURE__*/function () {\n  function Event(tag, listener, once) {\n    _classCallCheck(this, Event);\n    this.listener = listener;\n    this.tag = tag;\n    this.once = once;\n    this._lastBlockNumber = -2;\n    this._inflight = false;\n  }\n  _createClass(Event, [{\n    key: \"event\",\n    get: function get() {\n      switch (this.type) {\n        case 'tx':\n          return this.hash;\n        case 'filter':\n          return this.filter;\n        default:\n          return this.tag;\n      }\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this.tag.split(':')[0];\n    }\n  }, {\n    key: \"hash\",\n    get: function get() {\n      var comps = this.tag.split(':');\n      if (comps[0] !== 'tx') {\n        throw new Error('Not a transaction event');\n      }\n      return comps[1];\n    }\n  }, {\n    key: \"filter\",\n    get: function get() {\n      var comps = this.tag.split(':');\n      if (comps[0] !== 'filter') {\n        throw new Error('Not a transaction event');\n      }\n      var address = comps[1];\n      var topics = deserializeTopics(comps[2]);\n      var filter = {};\n      if (topics.length > 0) {\n        filter.topics = topics;\n      }\n      if (address && address !== '*') {\n        filter.address = address;\n      }\n      return filter;\n    }\n  }, {\n    key: \"pollable\",\n    value: function pollable() {\n      var PollableEvents = ['block', 'network', 'pending', 'poll'];\n      return this.tag.indexOf(':') >= 0 || PollableEvents.indexOf(this.tag) >= 0;\n    }\n  }]);\n  return Event;\n}();\n/**\r\n * Wrapper class around the ethers `Event` class in order to add support for\r\n * Alchemy's custom subscriptions types.\r\n *\r\n * The serialization and deserialization mechanism requires the order of the\r\n * fields to be the same across different {@link ALCHEMY_EVENT_TYPES}. Before\r\n * using a getter on a new event filter, make sure that the position of the\r\n * field in serialization is correct.\r\n *\r\n * The getters on this class deserialize the event tag generated by\r\n * {@link getAlchemyEventTag} into the original fields passed into the event.\r\n */\nvar EthersEvent = /*#__PURE__*/function (_Event) {\n  _inherits(EthersEvent, _Event);\n  var _super = _createSuper(EthersEvent);\n  function EthersEvent() {\n    _classCallCheck(this, EthersEvent);\n    return _super.apply(this, arguments);\n  }\n  _createClass(EthersEvent, [{\n    key: \"fromAddress\",\n    get:\n    /**\r\n     * Converts the event tag into the original `fromAddress` field in\r\n     * {@link AlchemyPendingTransactionsEventFilter}.\r\n     */\n    function get() {\n      var comps = this.tag.split(':');\n      if (comps[0] !== ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n        return undefined;\n      }\n      if (comps[1] && comps[1] !== '*') {\n        return deserializeAddressField(comps[1]);\n      } else {\n        return undefined;\n      }\n    }\n    /**\r\n     * Converts the event tag into the original `toAddress` field in\r\n     * {@link AlchemyPendingTransactionsEventFilter}.\r\n     */\n  }, {\n    key: \"toAddress\",\n    get: function get() {\n      var comps = this.tag.split(':');\n      if (comps[0] !== ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n        return undefined;\n      }\n      if (comps[2] && comps[2] !== '*') {\n        return deserializeAddressField(comps[2]);\n      } else {\n        return undefined;\n      }\n    }\n    /**\r\n     * Converts the event tag into the original `hashesOnly` field in\r\n     * {@link AlchemyPendingTransactionsEventFilter} and {@link AlchemyMinedTransactionsEventFilter}.\r\n     */\n  }, {\n    key: \"hashesOnly\",\n    get: function get() {\n      var comps = this.tag.split(':');\n      if (!ALCHEMY_EVENT_TYPES.includes(comps[0])) {\n        return undefined;\n      }\n      if (comps[3] && comps[3] !== '*') {\n        return comps[3] === 'true';\n      } else {\n        return undefined;\n      }\n    }\n  }, {\n    key: \"includeRemoved\",\n    get: function get() {\n      var comps = this.tag.split(':');\n      if (comps[0] !== ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {\n        return undefined;\n      }\n      if (comps[2] && comps[2] !== '*') {\n        return comps[2] === 'true';\n      } else {\n        return undefined;\n      }\n    }\n  }, {\n    key: \"addresses\",\n    get: function get() {\n      var comps = this.tag.split(':');\n      if (comps[0] !== ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {\n        return undefined;\n      }\n      if (comps[1] && comps[1] !== '*') {\n        return deserializeAddressesField(comps[1]);\n      } else {\n        return undefined;\n      }\n    }\n  }]);\n  return EthersEvent;\n}(Event);\nfunction isAlchemyEvent(event) {\n  return typeof event === 'object' && 'method' in event;\n}\n/**\r\n * Creates a string representation of an `alchemy_pendingTransaction`\r\n * subscription filter that is compatible with the ethers implementation of\r\n * `getEventTag()`. The method is not an exported function in ethers, which is\r\n * why the SDK has its own implementation.\r\n *\r\n * The event tag is then deserialized by the SDK's {@link EthersEvent} getters.\r\n *\r\n * @example\r\n *   ```js\r\n *   // Returns 'alchemy-pending-transactions:0xABC:0xDEF|0xGHI:true'\r\n *   const eventTag =  getAlchemyEventTag(\r\n *   {\r\n *     \"method\": \"alchemy_pendingTransactions\",\r\n *     \"fromAddress\": \"0xABC\",\r\n *     \"toAddress\": [\"0xDEF\", \"0xGHI\"],\r\n *     \"hashesOnly: true\r\n *   });\r\n *   ```;\r\n *\r\n * @param event\r\n * @internal\r\n */\nfunction getAlchemyEventTag(event) {\n  if (!isAlchemyEvent(event)) {\n    throw new Error('Event tag requires AlchemyEventType');\n  }\n  if (event.method === AlchemySubscription.PENDING_TRANSACTIONS) {\n    return serializePendingTransactionsEvent(event);\n  } else if (event.method === AlchemySubscription.MINED_TRANSACTIONS) {\n    return serializeMinedTransactionsEvent(event);\n  } else {\n    throw new Error(\"Unrecognized AlchemyFilterEvent: \".concat(event));\n  }\n}\nfunction verifyAlchemyEventName(eventName) {\n  if (!Object.values(AlchemySubscription).includes(eventName.method)) {\n    throw new Error(\"Invalid method name \".concat(eventName.method, \". Accepted method names: \").concat(Object.values(AlchemySubscription)));\n  }\n}\n/**\r\n * Serializes the provided {@link AlchemyPendingTransactionsEventFilter} into an ethers\r\n * compatible event tag.\r\n *\r\n * For the example event:\r\n * ```\r\n *  {\r\n *     \"method\": \"alchemy_pendingTransactions\",\r\n *     \"fromAddress\": \"0xABC\",\r\n *     \"toAddress\": [\"0xDEF\", \"0xGHI\"],\r\n *     \"hashesOnly: true\r\n *   }\r\n * ```\r\n *\r\n * The resulting serialization is:\r\n * `alchemy_pendingTransactions:0xABC:0xDEF|0xGHI:true`\r\n *\r\n * If a field is omitted, it is replaced with a `*`.\r\n */\nfunction serializePendingTransactionsEvent(event) {\n  var fromAddress = serializeAddressField(event.fromAddress);\n  var toAddress = serializeAddressField(event.toAddress);\n  var hashesOnly = serializeBooleanField(event.hashesOnly);\n  return ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE + ':' + fromAddress + ':' + toAddress + ':' + hashesOnly;\n}\n/**\r\n * Serializes the provided {@link AlchemyPendingTransactionsEventFilter} into an ethers\r\n * compatible event tag.\r\n *\r\n * For the example event:\r\n * ```\r\n *  {\r\n *     \"method\": \"alchemy_minedTransactions\",\r\n *     \"addresses\": [\r\n *       {\r\n *         from: \"0xABC\"\r\n *       },\r\n *       {\r\n *         to: \"0xDEF\",\r\n *         from: \"0x123\"\r\n *       }\r\n *     ]\r\n *     \"includeRemoved\": false\r\n *     \"hashesOnly: true\r\n *   }\r\n * ```\r\n *\r\n * The resulting serialization is:\r\n * `alchemy_minedTransactions:*,0xABC|0xDEF,0x123:false:true`\r\n *\r\n * If a field is omitted, it is replaced with a `*`.\r\n *\r\n * The `addresses` array is split by the '|' character, and each to/from address\r\n * pair is separated by a ',' character.\r\n *\r\n */\nfunction serializeMinedTransactionsEvent(event) {\n  var addresses = serializeAddressesField(event.addresses);\n  var includeRemoved = serializeBooleanField(event.includeRemoved);\n  var hashesOnly = serializeBooleanField(event.hashesOnly);\n  return ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE + ':' + addresses + ':' + includeRemoved + ':' + hashesOnly;\n}\nfunction serializeAddressesField(addresses) {\n  if (addresses === undefined) {\n    return '*';\n  }\n  return addresses.map(function (filter) {\n    return serializeAddressField(filter.to) + ',' + serializeAddressField(filter.from);\n  }).join('|');\n}\nfunction serializeAddressField(field) {\n  if (field === undefined) {\n    return '*';\n  } else if (Array.isArray(field)) {\n    return field.join('|');\n  } else {\n    return field;\n  }\n}\nfunction serializeBooleanField(field) {\n  if (field === undefined) {\n    return '*';\n  } else {\n    return field.toString();\n  }\n}\nfunction deserializeTopics(data) {\n  if (data === '') {\n    return [];\n  }\n  return data.split(/&/g).map(function (topic) {\n    if (topic === '') {\n      return [];\n    }\n    var comps = topic.split('|').map(function (topic) {\n      return topic === 'null' ? null : topic;\n    });\n    return comps.length === 1 ? comps[0] : comps;\n  });\n}\nfunction deserializeAddressField(data) {\n  if (data === '') {\n    return undefined;\n  }\n  var addresses = data.split('|');\n  return addresses.length === 1 ? addresses[0] : addresses;\n}\nfunction deserializeAddressesField(data) {\n  if (data === '') {\n    return undefined;\n  }\n  // Perform a cast here since TS doesn't know we're guaranteed a non-empty\n  // array from deserializing.\n  return data.split('|').map(function (addressStr) {\n    return addressStr.split(',');\n  }).map(function (addressPair) {\n    return Object.assign(Object.assign({}, addressPair[0] !== '*' && {\n      to: addressPair[0]\n    }), addressPair[1] !== '*' && {\n      from: addressPair[1]\n    });\n  });\n}\n\n/**\r\n * The Websocket namespace contains all subscription related functions that\r\n * allow you to subscribe to events and receive updates as they occur. The\r\n * underlying WebSocket provider has additional logic to handle reconnections\r\n * and automatically backfills missed events.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an Alchemy object\r\n * with `const alchemy = new Alchemy(config)` and then access the core namespace\r\n * via `alchemy.ws`.\r\n */\nvar WebSocketNamespace = /*#__PURE__*/function () {\n  /** @internal */\n  function WebSocketNamespace(config) {\n    _classCallCheck(this, WebSocketNamespace);\n    this.config = config;\n  }\n  /**\r\n   * Adds a listener to be triggered for each {@link eventName} event. Also\r\n   * includes Alchemy's Subscription API events. See {@link AlchemyEventType} for\r\n   * how to use them.\r\n   *\r\n   * @param eventName The event to listen for.\r\n   * @param listener The listener to call when the event is triggered.\r\n   * @public\r\n   */\n  _createClass(WebSocketNamespace, [{\n    key: \"on\",\n    value: function on(eventName, listener) {\n      var _this5 = this;\n      void function () {\n        return __awaiter$1(_this5, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee90() {\n          var provider, processedEvent;\n          return _regeneratorRuntime().wrap(function _callee90$(_context93) {\n            while (1) switch (_context93.prev = _context93.next) {\n              case 0:\n                _context93.next = 2;\n                return this.config.getWebSocketProvider();\n              case 2:\n                provider = _context93.sent;\n                _context93.next = 5;\n                return this._resolveEnsAlchemyEvent(eventName);\n              case 5:\n                processedEvent = _context93.sent;\n                provider.on(processedEvent, listener);\n              case 7:\n              case \"end\":\n                return _context93.stop();\n            }\n          }, _callee90, this);\n        }));\n      }();\n      return this;\n    }\n    /**\r\n     * Adds a listener to be triggered for only the next {@link eventName} event,\r\n     * after which it will be removed. Also includes Alchemy's Subscription API\r\n     * events. See {@link AlchemyEventType} for how to use them.\r\n     *\r\n     * @param eventName The event to listen for.\r\n     * @param listener The listener to call when the event is triggered.\r\n     * @public\r\n     */\n  }, {\n    key: \"once\",\n    value: function once(eventName, listener) {\n      var _this6 = this;\n      void function () {\n        return __awaiter$1(_this6, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee91() {\n          var provider, processedEvent;\n          return _regeneratorRuntime().wrap(function _callee91$(_context94) {\n            while (1) switch (_context94.prev = _context94.next) {\n              case 0:\n                _context94.next = 2;\n                return this.config.getWebSocketProvider();\n              case 2:\n                provider = _context94.sent;\n                _context94.next = 5;\n                return this._resolveEnsAlchemyEvent(eventName);\n              case 5:\n                processedEvent = _context94.sent;\n                provider.once(processedEvent, listener);\n              case 7:\n              case \"end\":\n                return _context94.stop();\n            }\n          }, _callee91, this);\n        }));\n      }();\n      return this;\n    }\n    /**\r\n     * Removes the provided {@link listener} for the {@link eventName} event. If no\r\n     * listener is provided, all listeners for the event will be removed.\r\n     *\r\n     * @param eventName The event to unlisten to.\r\n     * @param listener The listener to remove.\r\n     * @public\r\n     */\n  }, {\n    key: \"off\",\n    value: function off(eventName, listener) {\n      var _this7 = this;\n      void function () {\n        return __awaiter$1(_this7, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee92() {\n          var provider, processedEvent;\n          return _regeneratorRuntime().wrap(function _callee92$(_context95) {\n            while (1) switch (_context95.prev = _context95.next) {\n              case 0:\n                _context95.next = 2;\n                return this.config.getWebSocketProvider();\n              case 2:\n                provider = _context95.sent;\n                _context95.next = 5;\n                return this._resolveEnsAlchemyEvent(eventName);\n              case 5:\n                processedEvent = _context95.sent;\n                return _context95.abrupt(\"return\", provider.off(processedEvent, listener));\n              case 7:\n              case \"end\":\n                return _context95.stop();\n            }\n          }, _callee92, this);\n        }));\n      }();\n      return this;\n    }\n    /**\r\n     * Remove all listeners for the provided {@link eventName} event. If no event\r\n     * is provided, all events and their listeners are removed.\r\n     *\r\n     * @param eventName The event to remove all listeners for.\r\n     * @public\r\n     */\n  }, {\n    key: \"removeAllListeners\",\n    value: function removeAllListeners(eventName) {\n      var _this8 = this;\n      void function () {\n        return __awaiter$1(_this8, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee93() {\n          var provider, processedEvent;\n          return _regeneratorRuntime().wrap(function _callee93$(_context96) {\n            while (1) switch (_context96.prev = _context96.next) {\n              case 0:\n                _context96.next = 2;\n                return this.config.getWebSocketProvider();\n              case 2:\n                provider = _context96.sent;\n                if (!eventName) {\n                  _context96.next = 9;\n                  break;\n                }\n                _context96.next = 6;\n                return this._resolveEnsAlchemyEvent(eventName);\n              case 6:\n                _context96.t0 = _context96.sent;\n                _context96.next = 10;\n                break;\n              case 9:\n                _context96.t0 = undefined;\n              case 10:\n                processedEvent = _context96.t0;\n                provider.removeAllListeners(processedEvent);\n              case 12:\n              case \"end\":\n                return _context96.stop();\n            }\n          }, _callee93, this);\n        }));\n      }();\n      return this;\n    }\n    /**\r\n     * Returns the number of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, the total number of listeners for all events is returned.\r\n     *\r\n     * @param eventName The event to get the number of listeners for.\r\n     * @public\r\n     */\n  }, {\n    key: \"listenerCount\",\n    value: function listenerCount(eventName) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee94() {\n        var provider, processedEvent;\n        return _regeneratorRuntime().wrap(function _callee94$(_context97) {\n          while (1) switch (_context97.prev = _context97.next) {\n            case 0:\n              _context97.next = 2;\n              return this.config.getWebSocketProvider();\n            case 2:\n              provider = _context97.sent;\n              if (!eventName) {\n                _context97.next = 9;\n                break;\n              }\n              _context97.next = 6;\n              return this._resolveEnsAlchemyEvent(eventName);\n            case 6:\n              _context97.t0 = _context97.sent;\n              _context97.next = 10;\n              break;\n            case 9:\n              _context97.t0 = undefined;\n            case 10:\n              processedEvent = _context97.t0;\n              return _context97.abrupt(\"return\", provider.listenerCount(processedEvent));\n            case 12:\n            case \"end\":\n              return _context97.stop();\n          }\n        }, _callee94, this);\n      }));\n    }\n    /**\r\n     * Returns an array of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, all listeners will be included.\r\n     *\r\n     * @param eventName The event to get the listeners for.\r\n     */\n  }, {\n    key: \"listeners\",\n    value: function listeners(eventName) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee95() {\n        var provider, processedEvent;\n        return _regeneratorRuntime().wrap(function _callee95$(_context98) {\n          while (1) switch (_context98.prev = _context98.next) {\n            case 0:\n              _context98.next = 2;\n              return this.config.getWebSocketProvider();\n            case 2:\n              provider = _context98.sent;\n              if (!eventName) {\n                _context98.next = 9;\n                break;\n              }\n              _context98.next = 6;\n              return this._resolveEnsAlchemyEvent(eventName);\n            case 6:\n              _context98.t0 = _context98.sent;\n              _context98.next = 10;\n              break;\n            case 9:\n              _context98.t0 = undefined;\n            case 10:\n              processedEvent = _context98.t0;\n              return _context98.abrupt(\"return\", provider.listeners(processedEvent));\n            case 12:\n            case \"end\":\n              return _context98.stop();\n          }\n        }, _callee95, this);\n      }));\n    }\n    /**\r\n     * Converts ENS addresses in an Alchemy Event to the underlying resolved\r\n     * address.\r\n     *\r\n     * VISIBLE ONLY FOR TESTING.\r\n     *\r\n     * @internal\r\n     */\n  }, {\n    key: \"_resolveEnsAlchemyEvent\",\n    value: function _resolveEnsAlchemyEvent(eventName) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee96() {\n        var _this9 = this;\n        var processedAddresses, _iterator5, _step5, address;\n        return _regeneratorRuntime().wrap(function _callee96$(_context99) {\n          while (1) switch (_context99.prev = _context99.next) {\n            case 0:\n              if (isAlchemyEvent(eventName)) {\n                _context99.next = 2;\n                break;\n              }\n              return _context99.abrupt(\"return\", eventName);\n            case 2:\n              if (!(eventName.method === AlchemySubscription.MINED_TRANSACTIONS && eventName.addresses)) {\n                _context99.next = 31;\n                break;\n              }\n              processedAddresses = [];\n              _iterator5 = _createForOfIteratorHelper(eventName.addresses);\n              _context99.prev = 5;\n              _iterator5.s();\n            case 7:\n              if ((_step5 = _iterator5.n()).done) {\n                _context99.next = 20;\n                break;\n              }\n              address = _step5.value;\n              if (!address.to) {\n                _context99.next = 13;\n                break;\n              }\n              _context99.next = 12;\n              return this._resolveNameOrError(address.to);\n            case 12:\n              address.to = _context99.sent;\n            case 13:\n              if (!address.from) {\n                _context99.next = 17;\n                break;\n              }\n              _context99.next = 16;\n              return this._resolveNameOrError(address.from);\n            case 16:\n              address.from = _context99.sent;\n            case 17:\n              processedAddresses.push(address);\n            case 18:\n              _context99.next = 7;\n              break;\n            case 20:\n              _context99.next = 25;\n              break;\n            case 22:\n              _context99.prev = 22;\n              _context99.t0 = _context99[\"catch\"](5);\n              _iterator5.e(_context99.t0);\n            case 25:\n              _context99.prev = 25;\n              _iterator5.f();\n              return _context99.finish(25);\n            case 28:\n              eventName.addresses = processedAddresses;\n              _context99.next = 52;\n              break;\n            case 31:\n              if (!(eventName.method === AlchemySubscription.PENDING_TRANSACTIONS)) {\n                _context99.next = 52;\n                break;\n              }\n              if (!eventName.fromAddress) {\n                _context99.next = 42;\n                break;\n              }\n              if (!(typeof eventName.fromAddress === 'string')) {\n                _context99.next = 39;\n                break;\n              }\n              _context99.next = 36;\n              return this._resolveNameOrError(eventName.fromAddress);\n            case 36:\n              eventName.fromAddress = _context99.sent;\n              _context99.next = 42;\n              break;\n            case 39:\n              _context99.next = 41;\n              return Promise.all(eventName.fromAddress.map(function (address) {\n                return _this9._resolveNameOrError(address);\n              }));\n            case 41:\n              eventName.fromAddress = _context99.sent;\n            case 42:\n              if (!eventName.toAddress) {\n                _context99.next = 52;\n                break;\n              }\n              if (!(typeof eventName.toAddress === 'string')) {\n                _context99.next = 49;\n                break;\n              }\n              _context99.next = 46;\n              return this._resolveNameOrError(eventName.toAddress);\n            case 46:\n              eventName.toAddress = _context99.sent;\n              _context99.next = 52;\n              break;\n            case 49:\n              _context99.next = 51;\n              return Promise.all(eventName.toAddress.map(function (address) {\n                return _this9._resolveNameOrError(address);\n              }));\n            case 51:\n              eventName.toAddress = _context99.sent;\n            case 52:\n              return _context99.abrupt(\"return\", eventName);\n            case 53:\n            case \"end\":\n              return _context99.stop();\n          }\n        }, _callee96, this, [[5, 22, 25, 28]]);\n      }));\n    }\n    /**\r\n     * Converts the provided ENS address or throws an error. This improves code\r\n     * readability and type safety in other methods.\r\n     *\r\n     * VISIBLE ONLY FOR TESTING.\r\n     *\r\n     * @internal\r\n     */\n  }, {\n    key: \"_resolveNameOrError\",\n    value: function _resolveNameOrError(name) {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee97() {\n        var provider, resolved;\n        return _regeneratorRuntime().wrap(function _callee97$(_context100) {\n          while (1) switch (_context100.prev = _context100.next) {\n            case 0:\n              _context100.next = 2;\n              return this.config.getProvider();\n            case 2:\n              provider = _context100.sent;\n              _context100.next = 5;\n              return provider.resolveName(name);\n            case 5:\n              resolved = _context100.sent;\n              if (!(resolved === null)) {\n                _context100.next = 8;\n                break;\n              }\n              throw new Error(\"Unable to resolve the ENS address: \".concat(name));\n            case 8:\n              return _context100.abrupt(\"return\", resolved);\n            case 9:\n            case \"end\":\n              return _context100.stop();\n          }\n        }, _callee97, this);\n      }));\n    }\n  }]);\n  return WebSocketNamespace;\n}();\n/**\r\n * The Alchemy SDK client. This class is the main entry point into Alchemy's\r\n * APIs and separates functionality into different namespaces.\r\n *\r\n * Each SDK instance is associated with a specific network and API key. To use a\r\n * different network or API key, create a new instance of {@link Alchemy}.\r\n *\r\n * @public\r\n */\nvar Alchemy = /*#__PURE__*/_createClass(\n/**\r\n * @param {string} [settings.apiKey] - The API key to use for Alchemy\r\n * @param {Network} [settings.network] - The network to use for Alchemy\r\n * @param {number} [settings.maxRetries] - The maximum number of retries to attempt\r\n * @param {number} [settings.requestTimeout] - The timeout after which request should fail\r\n * @public\r\n */\nfunction Alchemy(settings) {\n  _classCallCheck(this, Alchemy);\n  this.config = new AlchemyConfig(settings);\n  this.core = new CoreNamespace(this.config);\n  this.nft = new NftNamespace(this.config);\n  this.ws = new WebSocketNamespace(this.config);\n  this.transact = new TransactNamespace(this.config);\n  this.notify = new NotifyNamespace(this.config);\n  this.debug = new DebugNamespace(this.config);\n});\n/**\r\n * The Wallet class inherits Signer and can sign transactions and messages using\r\n * a private key as a standard Externally Owned Account (EOA).\r\n *\r\n * SDK's custom implementation of Ethers.js's 'Wallet'.\r\n *\r\n * Primary difference from Ethers.js 'Wallet' is that you can pass in either a\r\n * Provider or an Alchemy object. This implementation will intelligently detect\r\n * the format and set the provider accordingly.\r\n *\r\n * @public\r\n * @override\r\n */\nvar Wallet = /*#__PURE__*/function (_Wallet$) {\n  _inherits(Wallet, _Wallet$);\n  var _super2 = _createSuper(Wallet);\n  /**\r\n   * Overload permits users to pass in either a standard Provider or an Alchemy\r\n   * object. The constructor will detect the object type and handle appropriately.\r\n   *\r\n   * @override\r\n   */\n  function Wallet(privateKey, alchemyOrProvider) {\n    var _this10;\n    _classCallCheck(this, Wallet);\n    // If object passed in is a provider, send to super\n    var superProvider;\n    if (alchemyOrProvider && Provider.isProvider(alchemyOrProvider)) {\n      superProvider = alchemyOrProvider;\n    }\n    _this10 = _super2.call(this, privateKey, superProvider);\n    // If object passed in is an Alchemy object, just set Alchemy\n    if (alchemyOrProvider && !Provider.isProvider(alchemyOrProvider)) {\n      _this10.alchemyProviderPromise = alchemyOrProvider.config.getProvider();\n    }\n    return _this10;\n  }\n  //////////////////////////////////////////////////////////////////\n  // Set of overrides from Signer to handle async provider retrieval.\n  //////////////////////////////////////////////////////////////////\n  /**\r\n   * Returns the balance of this wallet at blockTag.\r\n   *\r\n   * @param blockTag The block to check the balance of\r\n   * @override\r\n   */\n  _createClass(Wallet, [{\n    key: \"getBalance\",\n    value: function getBalance(blockTag) {\n      return this.getWallet().then(function (wallet) {\n        return wallet.getBalance(blockTag);\n      });\n    }\n    /**\r\n     * Returns the number of transactions this account has ever sent. This is the\r\n     * value required to be included in transactions as the nonce.\r\n     *\r\n     * @param blockTag The block to check the transaction count on\r\n     * @override\r\n     */\n  }, {\n    key: \"getTransactionCount\",\n    value: function getTransactionCount(blockTag) {\n      return this.getWallet().then(function (wallet) {\n        return wallet.getTransactionCount(blockTag);\n      });\n    }\n    /**\r\n     * Returns the result of estimating the cost to send the transactionRequest,\r\n     * with this account address being used as the from field.\r\n     *\r\n     * @param transaction Transaction to estimate the gas on\r\n     * @override\r\n     */\n  }, {\n    key: \"estimateGas\",\n    value: function estimateGas(transaction) {\n      return this.getWallet().then(function (wallet) {\n        return wallet.estimateGas(transaction);\n      });\n    }\n    /**\r\n     * Returns the result of calling using the transactionRequest, with this\r\n     * account address being used as the from field.\r\n     *\r\n     * @param transaction To make a call on\r\n     * @param blockTag The block to make the call on\r\n     * @override\r\n     */\n  }, {\n    key: \"call\",\n    value: function call(transaction, blockTag) {\n      return this.getWallet().then(function (wallet) {\n        return wallet.call(transaction, blockTag);\n      });\n    }\n    /**\r\n     * Populates ALL keys for a transaction and checks that `from` matches this\r\n     * `Signer`. Resolves ENS names and populates fields like `gasPrice`, `gasLimit`,\r\n     * `nonce`, and `chainId` if they are not provided.\r\n     *\r\n     * @param transaction The transaction to populate.\r\n     * @override\r\n     */\n  }, {\n    key: \"populateTransaction\",\n    value: function populateTransaction(transaction) {\n      return this.getWallet().then(function (wallet) {\n        return wallet.populateTransaction(transaction);\n      });\n    }\n    /**\r\n     * Populates all fields in a transaction, signs it and sends it to the network\r\n     *\r\n     * @param transaction The transaction to send.\r\n     * @override\r\n     */\n  }, {\n    key: \"sendTransaction\",\n    value: function sendTransaction(transaction) {\n      return this.getWallet().then(function (wallet) {\n        return wallet.sendTransaction(transaction);\n      });\n    }\n    /**\r\n     * Returns the chain ID this wallet is connected to.\r\n     *\r\n     * @override\r\n     */\n  }, {\n    key: \"getChainId\",\n    value: function getChainId() {\n      return this.getWallet().then(function (wallet) {\n        return wallet.getChainId();\n      });\n    }\n    /**\r\n     * Returns the current gas price.\r\n     *\r\n     * @override\r\n     */\n  }, {\n    key: \"getGasPrice\",\n    value: function getGasPrice() {\n      return this.getWallet().then(function (wallet) {\n        return wallet.getGasPrice();\n      });\n    }\n    /**\r\n     * Returns the current recommended FeeData to use in a transaction.\r\n     *\r\n     * For an EIP-1559 transaction, the maxFeePerGas and maxPriorityFeePerGas\r\n     * should be used.\r\n     *\r\n     * For legacy transactions and networks which do not support EIP-1559, the\r\n     * gasPrice should be used.\r\n     *\r\n     * @override\r\n     */\n  }, {\n    key: \"getFeeData\",\n    value: function getFeeData() {\n      return this.getWallet().then(function (wallet) {\n        return wallet.getFeeData();\n      });\n    }\n    /**\r\n     * Looks up the address of name. If the name is not owned, or does not have a\r\n     * Resolver configured, or the Resolver does not have an address configured,\r\n     * null is returned.\r\n     *\r\n     * @param name Name of the ENS address\r\n     * @override\r\n     */\n  }, {\n    key: \"resolveName\",\n    value: function resolveName(name) {\n      return this.getWallet().then(function (wallet) {\n        return wallet.resolveName(name);\n      });\n    }\n  }, {\n    key: \"getWallet\",\n    value: function getWallet() {\n      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee98() {\n        return _regeneratorRuntime().wrap(function _callee98$(_context101) {\n          while (1) switch (_context101.prev = _context101.next) {\n            case 0:\n              if (this.alchemyProviderPromise) {\n                _context101.next = 2;\n                break;\n              }\n              return _context101.abrupt(\"return\", this.connect(this.provider));\n            case 2:\n              _context101.t0 = this;\n              _context101.next = 5;\n              return this.alchemyProviderPromise;\n            case 5:\n              _context101.t1 = _context101.sent;\n              return _context101.abrupt(\"return\", _context101.t0.connect.call(_context101.t0, _context101.t1));\n            case 7:\n            case \"end\":\n              return _context101.stop();\n          }\n        }, _callee98, this);\n      }));\n    }\n  }]);\n  return Wallet;\n}(Wallet$1);\n/**\r\n * The Contract class is a wrapper around the Contract class from ethers.js and\r\n * is exported here for convenience.\r\n *\r\n * @public\r\n */\n// TODO: support passing in Alchemy instance into the contract.\nvar Contract = /*#__PURE__*/function (_Contract$) {\n  _inherits(Contract, _Contract$);\n  var _super3 = _createSuper(Contract);\n  function Contract() {\n    _classCallCheck(this, Contract);\n    return _super3.apply(this, arguments);\n  }\n  return _createClass(Contract);\n}(Contract$1);\n/**\r\n * The ContractFactory class is a wrapper around the ContractFactory class from\r\n * ethers.js and is exported here for convenience.\r\n *\r\n * @public\r\n */\nvar ContractFactory = /*#__PURE__*/function (_ContractFactory$) {\n  _inherits(ContractFactory, _ContractFactory$);\n  var _super4 = _createSuper(ContractFactory);\n  function ContractFactory() {\n    _classCallCheck(this, ContractFactory);\n    return _super4.apply(this, arguments);\n  }\n  return _createClass(ContractFactory);\n}(ContractFactory$1);\nexport { ALCHEMY_EVENT_TYPES as A, NftOrdering as B, CustomNetworks as C, DEFAULT_ALCHEMY_API_KEY as D, EthersNetwork as E, NftSaleMarketplace as F, GetTransfersForOwnerTransferType as G, NftSaleTakerType as H, IS_BROWSER as I, SimulateAssetType as J, SimulateChangeType as K, DecodingAuthority as L, DebugCallType as M, Network as N, OpenSeaSafelistRequestStatus as O, GasOptimizedTransactionStatus as P, WebhookVersion as Q, RefreshState as R, SortingOrder as S, TokenBalanceType as T, WebhookType as U, VERSION as V, Wallet as W, CommitmentLevel as X, DebugTracerType as Y, __awaiter$1 as _, DEFAULT_NETWORK as a, getAlchemyWsUrl as b, EthersEvent as c, deepCopy as d, getAlchemyEventTag as e, fromHex as f, getAlchemyHttpUrl as g, ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE as h, isAlchemyEvent as i, AlchemySubscription as j, ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE as k, logWarn as l, Alchemy as m, noop as n, Contract as o, ContractFactory as p, isHex as q, AssetTransfersCategory as r, setLogLevel as s, toHex as t, AssetTransfersOrder as u, verifyAlchemyEventName as v, NftTokenType as w, NftSpamClassification as x, NftExcludeFilters as y, NftFilters as z };","map":{"version":3,"names":["Network","TokenBalanceType","AssetTransfersCategory","AssetTransfersOrder","NftTokenType","NftSpamClassification","NftExcludeFilters","NftFilters","NftOrdering","GetTransfersForOwnerTransferType","SortingOrder","NftSaleMarketplace","NftSaleTakerType","RefreshState","OpenSeaSafelistRequestStatus","AlchemySubscription","SimulateAssetType","SimulateChangeType","DecodingAuthority","DebugCallType","GasOptimizedTransactionStatus","WebhookVersion","WebhookType","CommitmentLevel","DebugTracerType","DEFAULT_ALCHEMY_API_KEY","DEFAULT_NETWORK","ETH_MAINNET","DEFAULT_MAX_RETRIES","DEFAULT_REQUEST_TIMEOUT","getAlchemyHttpUrl","network","apiKey","concat","getAlchemyNftHttpUrl","getAlchemyWsUrl","getAlchemyWebhookHttpUrl","AlchemyApiType","EthersNetwork","_EthersNetwork","_defineProperty","ETH_ROPSTEN","ETH_GOERLI","ETH_KOVAN","ETH_RINKEBY","ETH_SEPOLIA","OPT_MAINNET","OPT_KOVAN","OPT_GOERLI","ARB_MAINNET","ARB_RINKEBY","ARB_GOERLI","MATIC_MAINNET","MATIC_MUMBAI","ASTAR_MAINNET","POLYGONZKEVM_MAINNET","POLYGONZKEVM_TESTNET","BASE_MAINNET","BASE_GOERLI","CustomNetworks","chainId","name","sepolia","noop","ETH_NULL_VALUE","ETH_NULL_ADDRESS","AlchemyConfig","config","_classCallCheck","maxRetries","url","authToken","batchRequests","requestTimeout","_createClass","key","value","_getRequestUrl","apiType","undefined","NFT","WEBHOOK","getProvider","_this","_baseAlchemyProvider","__awaiter$1","_regeneratorRuntime","mark","_callee","_yield$import","AlchemyProvider","wrap","_callee$","_context","prev","next","sent","abrupt","stop","getWebSocketProvider","_this2","_baseAlchemyWssProvider","_callee2","_yield$import2","AlchemyWebSocketProvider","_callee2$","_context2","version$1","_permanentCensorErrors","_censorErrors","LogLevels","debug","info","warning","error","off","_logLevel","_globalLogger","_checkNormalize","missing","forEach","form","normalize","Error","push","length","join","String","fromCharCode","message","_normalizeError","LogLevel$1","LogLevel","ErrorCode","HEX","Logger$1","version","Object","defineProperty","enumerable","writable","_log","logLevel","args","level","toLowerCase","throwArgumentError","console","log","apply","_len","arguments","Array","_key","levels","DEBUG","_len2","_key2","INFO","warn","_len3","_key3","WARNING","makeError","code","params","errors","UNKNOWN_ERROR","messageDetails","keys","Uint8Array","hex","i","JSON","stringify","toString","reason","NUMERIC_FAULT","fault","CALL_EXCEPTION","INSUFFICIENT_FUNDS","MISSING_NEW","NONCE_EXPIRED","REPLACEMENT_UNDERPRICED","TRANSACTION_REPLACED","UNPREDICTABLE_GAS_LIMIT","throwError","INVALID_ARGUMENT","argument","assert","condition","assertArgument","checkNormalize","UNSUPPORTED_OPERATION","operation","checkSafeUint53","checkArgumentCount","count","expectedCount","MISSING_ARGUMENT","UNEXPECTED_ARGUMENT","checkNew","target","kind","checkAbstract","globalLogger","setCensorship","censorship","permanent","setLogLevel","from","__awaiter","thisArg","_arguments","P","generator","adopt","resolve","Promise","reject","fulfilled","step","e","rejected","result","done","then","logger","defineReadOnly","object","resolveProperties","_callee3","promises","results","_callee3$","_context3","map","v","all","reduce","accum","opaque","bigint","boolean","number","string","_isFrozen","isArray","isFrozen","_deepCopy","freeze","item","deepCopy","fromHex","hexString","BigNumber","toNumber","toHex","num","toHexString","isHex","possibleHexString","test","formatBlock","block","Number","isInteger","stringToEnum","x","enumb","values","includes","getNftContractFromRaw","rawNftContract","address","contractMetadata","symbol","totalSupply","tokenType","parseNftTokenType","openSea","parseOpenSeaMetadata","contractDeployer","deployedBlockNumber","getBaseNftFromRaw","rawBaseNft","contractAddress","contract","tokenId","id","_a","tokenMetadata","getNftFromRaw","rawNft","spamInfo","parseSpamInfo","_b","_c","_d","_e","_f","_g","parseNftTokenId","title","description","parseNftDescription","timeLastUpdated","metadataError","rawMetadata","metadata","tokenUri","parseNftTokenUri","media","parseNftTokenUriArray","acquiredAt","getNftSalesFromRaw","rawNftSales","nftSales","rawNftSale","marketplace","parseNftSaleMarketplace","quantity","buyerAddress","sellerAddress","taker","parseNftTaker","sellerFee","marketplaceFee","protocolFee","royaltyFee","blockNumber","logIndex","bundleIndex","transactionHash","validAt","blockHash","blockTimestamp","pageKey","LOOKSRARE","SEAPORT","X2Y2","WYVERN","CRYPTOPUNKS","BLUR","UNKNOWN","BUYER","SELLER","getNftRarityFromRaw","rawNftRarity","_ref","prevalence","trait_type","traitType","getContractsForOwnerFromRaw","rawContractsForOwner","totalCount","contracts","isSpam","numDistinctTokensOwned","totalBalance","opensea","ERC721","ERC1155","NO_SUPPORTED_NFT_STANDARD","NOT_A_CONTRACT","classifications","uri","raw","gateway","arr","filter","floorPrice","collectionName","safelistRequestStatus","imageUrl","externalUrl","twitterUsername","discordUrl","lastIngestedAt","IS_BROWSER","window","nullsToUndefined","obj","getAssetTransfers","srcMethod","provider","_context4","fromAddress","_getAddress","toAddress","_send","assign","fromBlock","toBlock","maxCount","_callee4","getTransactionReceipts","_context5","_callee5","getLogs","_context6","getNetwork","getFilter","send","logs","removed","arrayOf","formatter","filterLog","bind","_callee6","_context8","resolvedFilter","_getBlockTag","t1","t0","call","_this3","_callee7","_callee7$","_context7","_callee8","format","array","CoreNamespace","getBalance","addressOrName","blockTag","_context9","_callee9","isContractAddress","_context10","getCode","_callee10","_context11","_callee11","getStorageAt","position","_context12","_callee12","getTransactionCount","_context13","_callee13","getBlock","blockHashOrBlockTag","_context14","_callee14","getBlockWithTransactions","_context15","_callee15","_context16","_callee16","getBlockNumber","_context17","_callee17","getGasPrice","_context18","_callee18","getFeeData","_context19","_callee19","ready","_context20","_callee20","transaction","_context21","_callee21","estimateGas","_context22","_callee22","getTransaction","_context23","_callee23","getTransactionReceipt","_context24","_callee24","sendTransaction","signedTransaction","_context25","_callee25","waitForTransaction","confirmations","timeout","_context26","_callee26","_context27","_callee27","method","_context28","_callee28","findContractDeployer","_context29","currentBlockNum","binarySearchFirstBlock","firstBlock","txReceipts","matchingReceipt","receipts","find","receipt","deployerAddress","_callee29","getTokenBalances","contractAddressesOrOptions","_context30","ERC20","type","_callee30","getTokensForOwner","options","_context31","contractAddresses","response","formattedBalances","tokenBalances","balance","rawBalance","tokenBalance","allSettled","token","metadataPromises","p","status","decimals","logo","ownedTokens","index","formatUnits","tokens","_callee31","getTokenMetadata","_context32","_callee32","_context33","_callee33","_context34","_callee34","resolveName","_context35","_callee35","lookupAddress","_context36","_callee36","start","end","_context37","mid","Math","floor","_callee37","DebugNamespace","traceCall","blockIdentifier","tracer","_context38","parseTracerParams","_callee38","traceTransaction","_context39","_callee39","traceBlock","_context40","isHexString","hexStripZeros","hexValue","_callee40","onlyTopCall","tracerConfig","sanitizeTokenType","logLevelStringToEnum","WARN","ERROR","silent","SILENT","logLevelToConsoleFn","_logLevelToConsoleFn","DEFAULT_LOG_LEVEL","loggerClient","logDebug","_len4","_key4","logInfo","_len5","_key5","logWarn","_len6","_key6","Logger","get","set","val","TypeError","_len7","_key7","_len8","_key8","_len9","_key9","_len10","_key10","now","Date","toISOString","_console","_len11","_key11","_toConsumableArray","VERSION","sendAxiosRequest","baseUrl","restApiName","methodName","overrides","requestUrl","headers","axios","DEFAULT_BACKOFF_INITIAL_DELAY_MS","DEFAULT_BACKOFF_MULTIPLIER","DEFAULT_BACKOFF_MAX_DELAY_MS","DEFAULT_BACKOFF_MAX_ATTEMPTS","ExponentialBackoff","maxAttempts","initialDelayMs","backoffMultiplier","maxDelayMs","numAttempts","currentDelayMs","isInBackoff","backoff","_this4","backoffDelayWithJitterMs","withJitterMs","max","min","setTimeout","delayMs","random","requestHttpWithBackoff","lastError","attempt","_context41","data","isAxiosError","isRetryableHttpError","_callee41","err","retryableCodes","paginateEndpoint","reqPageKey","resPageKey","hasNext","requestParams","_context42","__await","getNftMetadata","tokenUriTimeoutInMs","refreshCache","_context43","_callee42","getNftMetadataBatch","_context44","_callee43","getContractMetadata","_context45","_callee44","getContractMetadataBatch","_context46","_callee45","getNftsForOwnerIterator","owner","withMetadata","omitMetadataToWithMetadata","omitMetadata","_context47","__asyncValues","filters","excludeFilters","_iterator","_createForOfIteratorHelper","ownedNfts","s","_step","n","ownedNft","nftFromGetNftResponse","parseInt","f","finish","getNftsForOwner","_context48","includeFilters","pageSize","orderBy","res","_callee46","getNftsForContract","_context49","startToken","limit","nfts","nftFromGetNftContractResponse","nextToken","_callee47","getNftsForContractIterator","_context50","_iterator2","_step2","nft","getOwnersForContract","_context51","owners","ownerAddresses","_callee48","getContractsForOwner","_context52","_callee49","getOwnersForNft","_context53","_callee50","getMintedNfts","_context54","ownerAddress","category","nftTokenTypeToCategory","excludeZeroValue","getNftsForTransfers","_callee51","getTransfersForOwner","transferType","_context55","TO","transfersResponse","_callee52","getTransfersForContract","SPECIALNFT","_context56","t2","t4","t5","t3","order","_callee53","parse1155Transfer","transfer","erc1155Metadata","rawContract","checkNftOwnership","_context57","_callee54","verifyNftOwnership","_context58","acc","curr","_iterator3","_step3","_callee55","isSpamContract","_context59","_callee56","getSpamContracts","_context60","_callee57","getFloorPrice","_context61","_callee58","getNftSales","_context62","_callee59","computeRarity","_context63","_callee60","searchContractMetadata","query","_context64","_callee61","summarizeNftAttributes","_context65","_callee62","refreshNftMetadata","tokenIdString","_context66","first","refresh","second","_callee63","refreshContract","_context67","refreshState","parseReingestionState","reingestionState","progress","_callee64","_context68","_callee65","isNftWithMetadata","metadataTransfers","transfers","flatMap","getTokensFromTransfer","to","hash","blockNum","_context69","batchSize","requestBatches","slice","batch","responseBatches","flat","nftsByTokenId","Map","transferredNfts","t","_callee66","DOES_NOT_EXIST","ALREADY_QUEUED","IN_PROGRESS","FINISHED","QUEUED","QUEUE_FAILED","NftNamespace","optionsOrTokenType","_context70","_callee67","NotifyNamespace","getAllWebhooks","verifyConfig","_context71","sendWebhookRequest","webhooks","parseRawWebhookResponse","_callee68","getAddresses","webhookOrId","webhookId","_context72","webhook_id","after","parseRawAddressActivityResponse","_callee69","getGraphqlQuery","_context73","parseRawCustomGraphqlWebhookResponse","_callee70","getNftFilters","_context74","parseRawNftFiltersResponse","_callee71","updateWebhook","update","_context75","is_active","isActive","nft_filters_to_add","addFilters","nftFilterToParam","nft_filters_to_remove","removeFilters","nft_metadata_filters_to_add","addMetadataFilters","nft_metadata_filters_to_remove","removeMetadataFilters","resolveAddresses","addAddresses","removeAddresses","addresses_to_add","addresses_to_remove","newAddresses","addresses","_callee72","createWebhook","MINED_TRANSACTION","DROPPED_TRANSACTION","_context76","appId","NETWORK_TO_WEBHOOK_NETWORK","NFT_ACTIVITY","NFT_METADATA_UPDATE","contract_address","token_id","nftFilterObj","nft_filters","nft_metadata_filters","ADDRESS_ACTIVITY","GRAPHQL","graphqlQuery","webhook_type","webhook_url","app_id","graphql_query","parseRawWebhook","_callee73","deleteWebhook","_context77","_callee74","_context78","resolvedAddresses","_iterator4","_step4","rawAddress","_callee75","WEBHOOK_NETWORK_TO_NETWORK","rawWebhook","timeCreated","time_created","signingKey","signing_key","pagination","total_count","cursors","GAS_OPTIMIZED_TX_FEE_MULTIPLES","TransactNamespace","sendPrivateTransaction","maxBlockNumber","_context79","hexBlockNumber","tx","preferences","_callee76","cancelPrivateTransaction","_context80","txHash","_callee77","simulateAssetChangesBundle","transactions","_context81","_callee78","simulateAssetChanges","_context82","_callee79","simulateExecutionBundle","_context83","_callee80","simulateExecution","_context84","_callee81","_context85","_callee82","_context86","_callee83","_context87","_callee84","getMaxPriorityFeePerGas","_context88","feeHex","_callee85","_context89","_callee86","sendGasOptimizedTransaction","transactionOrSignedTxs","wallet","_context90","_sendGasOptimizedTransaction","gasLimit","priorityFee","currentBlock","baseFee","baseFeePerGas","gasSpreadTransactions","generateGasSpreadTransactions","signTransaction","signedTransactions","_callee87","getGasOptimizedTransactionStatus","trackingId","_context91","_callee88","_context92","rawTransactions","_callee89","feeMultiplier","maxFeePerGas","round","maxPriorityFeePerGas","ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE","ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE","ALCHEMY_EVENT_TYPES","Event","tag","listener","once","_lastBlockNumber","_inflight","split","comps","topics","deserializeTopics","pollable","PollableEvents","indexOf","EthersEvent","_Event","_inherits","_super","_createSuper","deserializeAddressField","deserializeAddressesField","isAlchemyEvent","event","getAlchemyEventTag","PENDING_TRANSACTIONS","serializePendingTransactionsEvent","MINED_TRANSACTIONS","serializeMinedTransactionsEvent","verifyAlchemyEventName","eventName","serializeAddressField","hashesOnly","serializeBooleanField","serializeAddressesField","includeRemoved","field","topic","addressStr","addressPair","WebSocketNamespace","on","_this5","_callee90","processedEvent","_callee90$","_context93","_resolveEnsAlchemyEvent","_this6","_callee91","_callee91$","_context94","_this7","_callee92","_callee92$","_context95","removeAllListeners","_this8","_callee93","_callee93$","_context96","listenerCount","_context97","_callee94","listeners","_context98","_callee95","_context99","processedAddresses","_iterator5","_step5","_resolveNameOrError","_this9","_callee96","_context100","resolved","_callee97","Alchemy","settings","core","ws","transact","notify","Wallet","_Wallet$","_super2","privateKey","alchemyOrProvider","_this10","superProvider","Provider","isProvider","alchemyProviderPromise","getWallet","populateTransaction","getChainId","_context101","connect","_callee98","Wallet$1","Contract","_Contract$","_super3","Contract$1","ContractFactory","_ContractFactory$","_super4","ContractFactory$1"],"sources":["/Users/kbookout/escrow-hardhat/app/node_modules/alchemy-sdk/src/types/types.ts","/Users/kbookout/escrow-hardhat/app/node_modules/alchemy-sdk/src/util/const.ts","/Users/kbookout/escrow-hardhat/app/node_modules/alchemy-sdk/src/api/alchemy-config.ts","/Users/kbookout/escrow-hardhat/app/node_modules/alchemy-sdk/node_modules/@ethersproject/logger/lib.esm/_version.js","/Users/kbookout/escrow-hardhat/app/node_modules/alchemy-sdk/node_modules/@ethersproject/logger/lib.esm/index.js","/Users/kbookout/escrow-hardhat/app/node_modules/alchemy-sdk/node_modules/@ethersproject/properties/lib.esm/_version.js","/Users/kbookout/escrow-hardhat/app/node_modules/alchemy-sdk/node_modules/@ethersproject/properties/lib.esm/index.js","/Users/kbookout/escrow-hardhat/app/node_modules/alchemy-sdk/src/api/util.ts","/Users/kbookout/escrow-hardhat/app/node_modules/alchemy-sdk/src/util/util.ts","/Users/kbookout/escrow-hardhat/app/node_modules/alchemy-sdk/src/internal/core-api.ts","/Users/kbookout/escrow-hardhat/app/node_modules/alchemy-sdk/src/api/core-namespace.ts","/Users/kbookout/escrow-hardhat/app/node_modules/alchemy-sdk/src/api/debug-namespace.ts","/Users/kbookout/escrow-hardhat/app/node_modules/alchemy-sdk/src/util/inputSanitization.ts","/Users/kbookout/escrow-hardhat/app/node_modules/alchemy-sdk/src/util/logger.ts","/Users/kbookout/escrow-hardhat/app/node_modules/alchemy-sdk/src/version.ts","/Users/kbookout/escrow-hardhat/app/node_modules/alchemy-sdk/src/util/sendRest.ts","/Users/kbookout/escrow-hardhat/app/node_modules/alchemy-sdk/src/internal/backoff.ts","/Users/kbookout/escrow-hardhat/app/node_modules/alchemy-sdk/src/internal/dispatch.ts","/Users/kbookout/escrow-hardhat/app/node_modules/alchemy-sdk/src/internal/nft-api.ts","/Users/kbookout/escrow-hardhat/app/node_modules/alchemy-sdk/src/api/nft-namespace.ts","/Users/kbookout/escrow-hardhat/app/node_modules/alchemy-sdk/src/api/notify-namespace.ts","/Users/kbookout/escrow-hardhat/app/node_modules/alchemy-sdk/src/api/transact-namespace.ts","/Users/kbookout/escrow-hardhat/app/node_modules/alchemy-sdk/src/internal/internal-types.ts","/Users/kbookout/escrow-hardhat/app/node_modules/alchemy-sdk/src/internal/ethers-event.ts","/Users/kbookout/escrow-hardhat/app/node_modules/alchemy-sdk/src/api/websocket-namespace.ts","/Users/kbookout/escrow-hardhat/app/node_modules/alchemy-sdk/src/api/alchemy.ts","/Users/kbookout/escrow-hardhat/app/node_modules/alchemy-sdk/src/api/alchemy-wallet.ts","/Users/kbookout/escrow-hardhat/app/node_modules/alchemy-sdk/src/api/alchemy-contract.ts"],"sourcesContent":["import {\n  BlockTag,\n  EventType,\n  TransactionReceipt\n} from '@ethersproject/abstract-provider';\nimport { BigNumberish } from '@ethersproject/bignumber';\n\nimport { BaseNft, Nft, NftContract } from '../api/nft';\n\nexport * from './ethers-types';\n\n// TODO: separate this file into other files.\n\n/**\n * Options object used to configure the Alchemy SDK.\n *\n * @public\n */\nexport interface AlchemySettings {\n  /**\n   * The Alchemy API key that can be found in the Alchemy dashboard.\n   *\n   * Defaults to: \"demo\" (a rate-limited public API key)\n   */\n  apiKey?: string;\n\n  /**\n   * The name of the network. Once configured, the network cannot be changed. To\n   * use a different network, instantiate a new `Alchemy` instance.\n   *\n   * Defaults to: Network.ETH_MAINNET\n   */\n  network?: Network;\n\n  /** The maximum number of retries to attempt if a request fails. Defaults to 5. */\n  maxRetries?: number;\n\n  /**\n   * Optional URL endpoint to use for all requests. Setting this field will\n   * override the URL generated by the {@link network} and {@link apiKey} fields.\n   *\n   * This field is useful for testing or for using a custom node endpoint. Note\n   * that not all methods will work with custom URLs.\n   */\n  url?: string;\n\n  /**\n   * Alchemy auth token required to use the Notify API. This token can be found\n   * in the Alchemy Dashboard on the Notify tab.\n   */\n  authToken?: string;\n\n  /**\n   * Optional Request timeout provided in `ms` while using NFT and NOTIFY API.\n   * Default to 0 (No timeout).\n   */\n  requestTimeout?: number;\n\n  /**\n   * Optional setting that automatically batches and sends json-rpc requests for\n   * higher throughput and reduced network IO. Defaults to false.\n   *\n   * This implementation is based on the `JsonRpcBatchProvider` in ethers.\n   */\n  batchRequests?: boolean;\n}\n\n/**\n * The supported networks by Alchemy. Note that some functions are not available\n * on all networks. Please refer to the Alchemy documentation for which APIs are\n * available on which networks\n * {@link https://docs.alchemy.com/alchemy/apis/feature-support-by-chain}\n *\n * @public\n */\nexport enum Network {\n  ETH_MAINNET = 'eth-mainnet',\n  /** @deprecated - Will be removed in subsequent versions */\n  ETH_ROPSTEN = 'eth-ropsten',\n  ETH_GOERLI = 'eth-goerli',\n  /** @deprecated - Will be removed in subsequent versions */\n  ETH_KOVAN = 'eth-kovan',\n  /** @deprecated - Will be removed in subsequent versions */\n  ETH_RINKEBY = 'eth-rinkeby',\n  ETH_SEPOLIA = 'eth-sepolia',\n  OPT_MAINNET = 'opt-mainnet',\n  /** @deprecated - Will be removed in subsequent versions */\n  OPT_KOVAN = 'opt-kovan',\n  OPT_GOERLI = 'opt-goerli',\n  ARB_MAINNET = 'arb-mainnet',\n  /** @deprecated - Will be removed in subsequent versions */\n  ARB_RINKEBY = 'arb-rinkeby',\n  ARB_GOERLI = 'arb-goerli',\n  MATIC_MAINNET = 'polygon-mainnet',\n  MATIC_MUMBAI = 'polygon-mumbai',\n  ASTAR_MAINNET = 'astar-mainnet',\n  POLYGONZKEVM_MAINNET = 'polygonzkevm-mainnet',\n  POLYGONZKEVM_TESTNET = 'polygonzkevm-testnet',\n  BASE_MAINNET = 'base-mainnet',\n  BASE_GOERLI = 'base-goerli'\n}\n\n/** Token Types for the `getTokenBalances()` endpoint. */\nexport enum TokenBalanceType {\n  /**\n   * Option to fetch the top 100 tokens by 24-hour volume. This option is only\n   * available on Mainnet in Ethereum, Polygon, and Arbitrum.\n   */\n  DEFAULT_TOKENS = 'DEFAULT_TOKENS',\n\n  /**\n   * Option to fetch the set of ERC-20 tokens that the address as ever held. his\n   * list is produced by an address's historical transfer activity and includes\n   * all tokens that the address has ever received.\n   */\n  ERC20 = 'erc20'\n}\n\n/**\n * Optional params to pass into `getTokenBalances()` to fetch all ERC-20 tokens\n * instead of passing in an array of contract addresses to fetch balances for.\n */\nexport interface TokenBalancesOptionsErc20 {\n  /** The ERC-20 token type. */\n  type: TokenBalanceType.ERC20;\n\n  /** Optional page key for pagination (only applicable to TokenBalanceType.ERC20) */\n  pageKey?: string;\n}\n\n/**\n * Optional params to pass into `getTokenBalances()` to fetch the top 100 tokens\n * instead of passing in an array of contract addresses to fetch balances for.\n */\nexport interface TokenBalancesOptionsDefaultTokens {\n  /** The top 100 token type. */\n  type: TokenBalanceType.DEFAULT_TOKENS;\n}\n\n/**\n * Response object for when the {@link TokenBalancesOptionsErc20} options are\n * used. A page key may be returned if the provided address has many transfers.\n */\nexport interface TokenBalancesResponseErc20 extends TokenBalancesResponse {\n  /**\n   * An optional page key to passed into the next request to fetch the next page\n   * of token balances.\n   */\n  pageKey?: string;\n}\n\n/** @public */\nexport interface TokenBalancesResponse {\n  address: string;\n  tokenBalances: TokenBalance[];\n}\n\n/** @public */\nexport type TokenBalance = TokenBalanceSuccess | TokenBalanceFailure;\n\n/** @public */\nexport interface TokenBalanceSuccess {\n  contractAddress: string;\n  tokenBalance: string;\n  error: null;\n}\n\n/** @public */\nexport interface TokenBalanceFailure {\n  contractAddress: string;\n  tokenBalance: null;\n  error: string;\n}\n\n/**\n * Optional params to pass into {@link CoreNamespace.getTokensForOwner}.\n */\nexport interface GetTokensForOwnerOptions {\n  /**\n   * List of contract addresses to filter by. If omitted, defaults to\n   * {@link TokenBalanceType.ERC20}.\n   */\n  contractAddresses?: string[] | TokenBalanceType;\n  /**\n   * Optional page key from an existing {@link GetTokensForOwnerResponse} to use for\n   * pagination.\n   */\n  pageKey?: string;\n}\n\n/**\n * Response object for {@link CoreNamespace.getTokensForOwner}.\n */\nexport interface GetTokensForOwnerResponse {\n  /** Owned tokens for the provided addresses along with relevant metadata. */\n  tokens: OwnedToken[];\n  /** Page key for the next page of results, if one exists. */\n  pageKey?: string;\n}\n\n/**\n * Represents an owned token on a {@link GetTokensForOwnerResponse}.\n */\nexport interface OwnedToken {\n  /** The contract address of the token. */\n  contractAddress: string;\n  /**\n   * The raw value of the balance field as a hex string. This value is undefined\n   * if the {@link error} field is present.\n   */\n  rawBalance?: string;\n  /**\n   * The formatted value of the balance field as a hex string. This value is\n   * undefined if the {@link error} field is present, or if the `decimals` field=\n   * is undefined.\n   */\n  balance?: string;\n  /** */\n  /**\n   * The token's name. Is undefined if the name is not defined in the contract and\n   * not available from other sources.\n   */\n  name?: string;\n  /**\n   * The token's symbol. Is undefined if the symbol is not defined in the contract\n   * and not available from other sources.\n   */\n  symbol?: string;\n  /**\n   * The number of decimals of the token. Is undefined if not defined in the\n   * contract and not available from other sources.\n   */\n  decimals?: number;\n  /** URL link to the token's logo. Is undefined if the logo is not available. */\n  logo?: string;\n  /**\n   * Error from fetching the token balances. If this field is defined, none of\n   * the other fields will be defined.\n   */\n  error?: string;\n}\n\n/**\n * Response object for the {@link CoreNamespace.getTokenMetadata} method.\n *\n * @public\n */\nexport interface TokenMetadataResponse {\n  /**\n   * The token's name. Is `null` if the name is not defined in the contract and\n   * not available from other sources.\n   */\n  name: string | null;\n\n  /**\n   * The token's symbol. Is `null` if the symbol is not defined in the contract\n   * and not available from other sources.\n   */\n  symbol: string | null;\n\n  /**\n   * The number of decimals of the token. Returns `null` if not defined in the\n   * contract and not available from other sources.\n   */\n  decimals: number | null;\n\n  /** URL link to the token's logo. Is `null` if the logo is not available. */\n  logo: string | null;\n}\n\n/**\n * Parameters for the {@link CoreNamespace.getAssetTransfers} method.\n *\n * @public\n */\nexport interface AssetTransfersParams {\n  /**\n   * The starting block to check for transfers. This value is inclusive and\n   * defaults to `0x0` if omitted.\n   */\n  fromBlock?: string;\n\n  /**\n   * The ending block to check for transfers. This value is inclusive and\n   * defaults to the latest block if omitted.\n   */\n  toBlock?: string;\n\n  /**\n   * Whether to return results in ascending or descending order by block number.\n   * Defaults to ascending if omitted.\n   */\n  order?: SortingOrder;\n\n  /**\n   * The from address to filter transfers by. This value defaults to a wildcard\n   * for all addresses if omitted.\n   */\n  fromAddress?: string;\n\n  /**\n   * The to address to filter transfers by. This value defaults to a wildcard\n   * for all address if omitted.\n   */\n  toAddress?: string;\n\n  /**\n   * List of contract addresses to filter for - only applies to \"erc20\",\n   * \"erc721\", \"erc1155\" transfers. Defaults to all address if omitted.\n   */\n  contractAddresses?: string[];\n\n  /**\n   * Whether to exclude transfers with zero value. Note that zero value is\n   * different than null value. Defaults to `true` if omitted.\n   */\n  excludeZeroValue?: boolean;\n\n  /** REQUIRED field. An array of categories to get transfers for. */\n  category: AssetTransfersCategory[];\n\n  /** The maximum number of results to return per page. Defaults to 1000 if omitted. */\n  maxCount?: number;\n\n  /**\n   * Optional page key from an existing {@link OwnedBaseNftsResponse}\n   * {@link AssetTransfersResult}to use for pagination.\n   */\n  pageKey?: string;\n\n  /**\n   * Whether to include additional metadata about each transfer event. Defaults\n   * to `false` if omitted.\n   */\n  withMetadata?: boolean;\n}\n\n/**\n * Parameters for the {@link CoreNamespace.getAssetTransfers} method that\n * includes metadata.\n *\n * @public\n */\nexport interface AssetTransfersWithMetadataParams extends AssetTransfersParams {\n  withMetadata: true;\n}\n\n/**\n * Categories of transfers to use with the {@link AssetTransfersParams} request\n * object when using {@link CoreNamespace.getAssetTransfers}.\n *\n * @public\n */\nexport enum AssetTransfersCategory {\n  /**\n   * Top level ETH transactions that occur where the `fromAddress` is an\n   * external user-created address. External addresses have private keys and are\n   * accessed by users.\n   */\n  EXTERNAL = 'external',\n\n  /**\n   * Top level ETH transactions that occur where the `fromAddress` is an\n   * internal, smart contract address. For example, a smart contract calling\n   * another smart contract or sending\n   */\n  INTERNAL = 'internal',\n\n  /** ERC20 transfers. */\n  ERC20 = 'erc20',\n\n  /** ERC721 transfers. */\n  ERC721 = 'erc721',\n\n  /** ERC1155 transfers. */\n  ERC1155 = 'erc1155',\n\n  /** Special contracts that don't follow ERC 721/1155, (ex: CryptoKitties). */\n  SPECIALNFT = 'specialnft'\n}\n\n/**\n * Enum for the order of the {@link AssetTransfersParams} request object when\n * using {@link CoreNamespace.getAssetTransfers}.\n *\n * @deprecated Use {@link SortingOrder} instead. This enum will be removed in a\n *   future version.\n * @public\n */\nexport enum AssetTransfersOrder {\n  ASCENDING = 'asc',\n  DESCENDING = 'desc'\n}\n\n/**\n * An enum for specifying the token type on NFTs.\n *\n * @public\n */\nexport enum NftTokenType {\n  ERC721 = 'ERC721',\n  ERC1155 = 'ERC1155',\n  NO_SUPPORTED_NFT_STANDARD = 'NO_SUPPORTED_NFT_STANDARD',\n  NOT_A_CONTRACT = 'NOT_A_CONTRACT',\n  UNKNOWN = 'UNKNOWN'\n}\n\n/**\n * Response object for the {@link CoreNamespace.getAssetTransfers} method.\n *\n * @public\n */\nexport interface AssetTransfersResponse {\n  transfers: AssetTransfersResult[];\n  /** Page key for the next page of results, if one exists. */\n  pageKey?: string;\n}\n\n/**\n * Response object for the {@link CoreNamespace.getAssetTransfers} method when\n * the {@link AssetTransfersWithMetadataParams} are used.\n *\n * @public\n */\nexport interface AssetTransfersWithMetadataResponse {\n  transfers: AssetTransfersWithMetadataResult[];\n  pageKey?: string;\n}\n\n/**\n * Represents a transfer event that is returned in a {@link AssetTransfersResponse}.\n *\n * @public\n */\nexport interface AssetTransfersResult {\n  /** The unique ID of the transfer. */\n  uniqueId: string;\n\n  /** The category of the transfer. */\n  category: AssetTransfersCategory;\n\n  /** The block number where the transfer occurred. */\n  blockNum: string;\n\n  /** The from address of the transfer. */\n  from: string;\n\n  /** The to address of the transfer. */\n  to: string | null;\n\n  /**\n   * Converted asset transfer value as a number (raw value divided by contract\n   * decimal). `null` if ERC721 transfer or contract decimal not available.\n   */\n  value: number | null;\n\n  /**\n   * The raw ERC721 token id of the transfer as a hex string. `null` if not an\n   * ERC721 transfer.\n   */\n  erc721TokenId: string | null;\n\n  /**\n   * A list of ERC1155 metadata objects if the asset transferred is an ERC1155\n   * token. `null` if not an ERC1155 transfer.\n   */\n  erc1155Metadata: ERC1155Metadata[] | null;\n\n  /** The token id of the token transferred. */\n  tokenId: string | null;\n\n  /**\n   * Returns the token's symbol or ETH for other transfers. `null` if the\n   * information was not available.\n   */\n  asset: string | null;\n\n  /** The transaction hash of the transfer transaction. */\n  hash: string;\n\n  /** Information about the raw contract of the asset transferred. */\n  rawContract: RawContract;\n}\n\n/**\n * Represents a transfer event that is returned in a\n * {@link AssetTransfersResponse} when {@link AssetTransfersWithMetadataParams} are used.\n *\n * @public\n */\nexport interface AssetTransfersWithMetadataResult extends AssetTransfersResult {\n  /** Additional metadata about the transfer event. */\n  metadata: AssetTransfersMetadata;\n}\n\n/**\n * The metadata object for a {@link AssetTransfersResult} when the\n * {@link AssetTransfersParams.withMetadata} field is set to true.\n *\n * @public\n */\nexport interface AssetTransfersMetadata {\n  /** Timestamp of the block from which the transaction event originated. */\n  blockTimestamp: string;\n}\n\n/**\n * Represents NFT metadata that holds fields. Note that since there is no\n * standard metadata format, the fields are not guaranteed to be present.\n *\n * @public\n */\nexport interface NftMetadata extends Record<string, any> {\n  /** Name of the NFT asset. */\n  name?: string;\n\n  /** A human-readable description of the NFT asset. */\n  description?: string;\n\n  /** URL to the NFT asset image. */\n  image?: string;\n\n  /**\n   * The image URL that appears along the top of the NFT asset page. This tends\n   * to be the highest resolution image.\n   */\n  external_url?: string;\n\n  /** Background color of the NFT item. Usually defined as a 6 character hex string. */\n  background_color?: string;\n\n  /** The traits, attributes, and characteristics for the NFT asset. */\n  attributes?: Array<Record<string, any>>;\n}\n\n/**\n * Represents the URI information the NFT's metadata.\n *\n * @public\n */\nexport interface TokenUri {\n  /**\n   * URI for the location of the NFT's original metadata blob (ex: the original\n   * IPFS link).\n   */\n  raw: string;\n\n  /** Public gateway URI for the raw URI. Generally offers better performance. */\n  gateway: string;\n}\n\n/**\n * Represents the URI information for the NFT's media assets.\n *\n * @public\n */\nexport interface Media {\n  /**\n   * URI for the location of the NFT's original metadata blob for media (ex: the\n   * original IPFS link).\n   */\n  raw: string;\n\n  /** Public gateway URI for the raw URI. Generally offers better performance. */\n  gateway: string;\n\n  /** URL for a resized thumbnail of the NFT media asset. */\n  thumbnail?: string;\n\n  /**\n   * The media format (ex: jpg, gif, png) of the {@link gateway} and\n   * {@link thumbnail} assets.\n   */\n  format?: string;\n\n  /**\n   * DEPRECATED - The size of the media asset in bytes\n   *\n   * @deprecated - Please use {@link bytes} instead. This field will be removed\n   *   in a subsequent release.\n   */\n  size?: number;\n\n  /** The size of the media asset in bytes. */\n  bytes?: number;\n}\n\n/** Potential reasons why an NFT contract was classified as spam. */\nexport enum NftSpamClassification {\n  Erc721TooManyOwners = 'Erc721TooManyOwners',\n  Erc721TooManyTokens = 'Erc721TooManyTokens',\n  Erc721DishonestTotalSupply = 'Erc721DishonestTotalSupply',\n  MostlyHoneyPotOwners = 'MostlyHoneyPotOwners',\n  OwnedByMostHoneyPots = 'OwnedByMostHoneyPots'\n}\n\n/** Detailed information on whether and why an NFT contract was classified as spam. */\nexport interface SpamInfo {\n  isSpam: boolean;\n\n  /** A list of reasons why an NFT contract was marked as spam. */\n  classifications: NftSpamClassification[];\n}\n\n/** Block time and number at which an NFT was acquired. */\nexport interface AcquiredAt {\n  /** Timestamp of the block at which an NFT was last acquired. */\n  blockTimestamp?: string;\n\n  /** Block number of the block at which an NFT was last acquired. */\n  blockNumber?: number;\n}\n\n/**\n * Optional parameters object for the {@link getNftsForOwner} and\n * {@link getNftsForOwnerIterator} functions.\n *\n * This interface is used to fetch NFTs with their associated metadata. To get\n * Nfts without their associated metadata, use {@link GetBaseNftsForOwnerOptions}.\n *\n * @public\n */\nexport interface GetNftsForOwnerOptions {\n  /**\n   * Optional page key from an existing {@link OwnedBaseNftsResponse} or\n   * {@link OwnedNftsResponse}to use for pagination.\n   */\n  pageKey?: string;\n\n  /** Optional list of contract addresses to filter the results by. Limit is 20. */\n  contractAddresses?: string[];\n\n  /**\n   * Optional list of filters applied to the query. NFTs that match one or more\n   * of these filters are excluded from the response.\n   */\n  excludeFilters?: NftFilters[];\n\n  /**\n   * Optional list of filters applied to the query. NFTs that match one or more\n   * of these filters are included in the response.\n   */\n  includeFilters?: NftFilters[];\n\n  /**\n   * Sets the total number of NFTs to return in the response. Defaults to 100.\n   * Maximum page size is 100.\n   */\n  pageSize?: number;\n\n  /** Optional boolean flag to omit NFT metadata. Defaults to `false`. */\n  omitMetadata?: boolean;\n\n  /**\n   * No set timeout by default - When metadata is requested, this parameter is\n   * the timeout (in milliseconds) for the website hosting the metadata to\n   * respond. If you want to only access the cache and not live fetch any\n   * metadata for cache misses then set this value to 0.\n   */\n  tokenUriTimeoutInMs?: number;\n\n  /**\n   * Order in which to return results. By default, results are ordered by\n   * contract address and token ID in lexicographic order.\n   */\n  orderBy?: NftOrdering;\n}\n\n/**\n * Optional parameters object for the {@link getNftsForOwner} and\n * {@link getNftsForOwnerIterator} functions.\n *\n * This interface is used to fetch NFTs without their associated metadata. To\n * get Nfts with their associated metadata, use {@link GetNftsForOwnerOptions}.\n *\n * @public\n */\nexport interface GetBaseNftsForOwnerOptions {\n  /**\n   * Optional page key from an existing {@link OwnedBaseNftsResponse} or\n   * {@link OwnedNftsResponse}to use for pagination.\n   */\n  pageKey?: string;\n\n  /** Optional list of contract addresses to filter the results by. Limit is 20. */\n  contractAddresses?: string[];\n\n  /**\n   * Optional list of filters applied to the query. NFTs that match one or more\n   * of these filters are excluded from the response.\n   */\n  excludeFilters?: NftFilters[];\n\n  /**\n   * Optional list of filters applied to the query. NFTs that match one or more\n   * of these filters are included in the response.\n   */\n  includeFilters?: NftFilters[];\n\n  /**\n   * Sets the total number of NFTs to return in the response. Defaults to 100.\n   * Maximum page size is 100.\n   */\n  pageSize?: number;\n\n  /** Optional boolean flag to include NFT metadata. Defaults to `false`. */\n  omitMetadata: true;\n\n  /**\n   * No set timeout by default - When metadata is requested, this parameter is\n   * the timeout (in milliseconds) for the website hosting the metadata to\n   * respond. If you want to only access the cache and not live fetch any\n   * metadata for cache misses then set this value to 0.\n   */\n  tokenUriTimeoutInMs?: number;\n\n  /**\n   * Order in which to return results. By default, results are ordered by\n   * contract address and token ID in lexicographic order.\n   */\n  orderBy?: NftOrdering;\n}\n\n/**\n * Enum of NFT filters that can be applied to a {@link getNftsForOwner} request.\n * NFTs that match one or more of these filters are excluded from the response.\n *\n * @deprecated Use {@link NftFilters} instead. This enum will be removed in a\n *   future version.\n *\n * @beta\n */\nexport enum NftExcludeFilters {\n  /** Exclude NFTs that have been classified as spam. */\n  SPAM = 'SPAM',\n\n  /** Exclude NFTs that have been airdropped to a user. */\n  AIRDROPS = 'AIRDROPS'\n}\n\n/**\n * Enum of NFT filters that can be applied to a {@link getNftsForOwner} or a\n * {@link getContractsForOwner} request.\n *\n * @beta\n */\nexport enum NftFilters {\n  /** NFTs that have been classified as spam. */\n  SPAM = 'SPAM',\n\n  /** NFTs that have been airdropped to a user. */\n  AIRDROPS = 'AIRDROPS'\n}\n\n/**\n * Enum of ordering that can be applied to a {@link getNftsForOwner} or a\n * {@link getContractsForOwner} response.\n *\n * @beta\n */\nexport enum NftOrdering {\n  TRANSFERTIME = 'TRANSFERTIME'\n}\n\n/**\n * The response object for the {@link getNftsForOwner} and\n * {@link getNftsForOwnerIterator} functions. The object contains the NFTs with\n * metadata owned by the provided address, along with pagination information and\n * the total count.\n *\n * @public\n */\nexport interface OwnedNftsResponse {\n  /** The NFTs owned by the provided address. */\n  readonly ownedNfts: OwnedNft[];\n\n  /**\n   * Pagination token that can be passed into another request to fetch the next\n   * NFTs. If there is no page key, then there are no more NFTs to fetch.\n   */\n  readonly pageKey?: string;\n\n  /** The total count of NFTs owned by the provided address. */\n  readonly totalCount: number;\n\n  /** The canonical head block hash of when your request was received. */\n  blockHash: string;\n}\n\n/**\n * The response object for the {@link getNftsForOwner} and\n * {@link getNftsForOwnerIterator} functions. The object contains the NFTs\n * without metadata owned by the provided address, along with pagination\n * information and the total count.\n *\n * @public\n */\nexport interface OwnedBaseNftsResponse {\n  /** The NFTs owned by the provided address. */\n  readonly ownedNfts: OwnedBaseNft[];\n\n  /**\n   * Pagination token that can be passed into another request to fetch the next\n   * NFTs. If there is no page key, then there are no more NFTs to fetch.\n   */\n  readonly pageKey?: string;\n\n  /** The total count of NFTs owned by the provided address. */\n  readonly totalCount: number;\n\n  /** The canonical head block hash of when your request was received. */\n  blockHash: string;\n}\n\n/**\n * Represents an NFT with metadata owned by an address.\n *\n * @public\n */\nexport interface OwnedNft extends Nft {\n  /** The token balance of the NFT. */\n  readonly balance: number;\n}\n\n/**\n * Represents an NFT without metadata owned by an address.\n *\n * @public\n */\nexport interface OwnedBaseNft extends BaseNft {\n  /** The token balance of the NFT. */\n  readonly balance: number;\n}\n\n/**\n * The response object for the {@link getOwnersForNft}.\n *\n * @public\n */\nexport interface GetOwnersForNftResponse {\n  /** An array of owner addresses for the provided token. */\n  readonly owners: string[];\n\n  /** Optional The key for the next page of results, if applicable. */\n  readonly pageKey?: string;\n}\n\n/**\n * The response object for the {@link getOwnersForContract}.\n *\n * @public\n */\nexport interface GetOwnersForContractResponse {\n  /** An array of owner addresses for the provided contract address */\n  owners: string[];\n\n  /**\n   * Total count of unique owners. Only present if\n   * {@link GetOwnersForContractOptions.includeCount} is true. */\n  totalCount?: number;\n\n  /** Optional page key that is returned when a collection has more than 50,000 owners. */\n  pageKey?: string;\n}\n\n/**\n * The response object for the {@link getOwnersForContract}.\n *\n * @public\n */\nexport interface GetOwnersForContractWithTokenBalancesResponse {\n  /** An array of owner addresses for the provided contract address */\n  owners: NftContractOwner[];\n\n  /** Optional page key that is returned when a collection has more than 50,000 owners. */\n  pageKey: string;\n}\n\n/**\n * An object representing the owner of an NFT and its corresponding token\n * balances in a {@link GetOwnersForContractWithTokenBalancesResponse} object.\n */\nexport interface NftContractOwner {\n  /** The NFT's owner address. */\n  ownerAddress: string;\n\n  /** A list of objects containing token balances for the provided NFT contract. */\n  tokenBalances: NftContractTokenBalance[];\n}\n\n/**\n * An object representing the owned token and balance values in a\n * {@link GetOwnersForContractWithTokenBalancesResponse} object.\n */\nexport interface NftContractTokenBalance {\n  /** The token id owned in the NFT contract. */\n  tokenId: string;\n\n  /** The token Id balance for the provided owner. */\n  balance: number;\n}\n\n/**\n * Additional options for the {@link NftNamespace.getNftMetadata} method.\n */\nexport interface GetNftMetadataOptions {\n  /** Optional field to specify the type of token to speed up the query. */\n  tokenType?: NftTokenType;\n  /**\n   * No set timeout by default - When metadata is requested, this parameter is\n   * the timeout (in milliseconds) for the website hosting the metadata to\n   * respond. If you want to only access the cache and not live fetch any\n   * metadata for cache misses then set this value to 0.\n   */\n  tokenUriTimeoutInMs?: number;\n\n  /**\n   * Whether to refresh the metadata for the given NFT token before returning\n   * the response. Defaults to false for faster response times.\n   */\n  refreshCache?: boolean;\n}\n\n/**\n * Represents an NFT token to fetch metadata for in a\n * {@link NftNamespace.getNftMetadataBatch} method.\n */\nexport interface NftMetadataBatchToken {\n  /** The NFT contract address. Limited to ERC721 and ERC1155 tokens. */\n  contractAddress: string;\n\n  /** The id of the NFT. */\n  tokenId: BigNumberish;\n\n  /** Optional field to specify the type of token to speed up the query. */\n  tokenType?: NftTokenType.ERC1155 | NftTokenType.ERC721;\n}\n\n/** Additional options for the {@link NftNamespace.getNftMetadataBatch} method. */\nexport interface NftMetadataBatchOptions {\n  /**\n   * No set timeout by default - When metadata is requested, this parameter is\n   * the timeout (in milliseconds) for the website hosting the metadata to\n   * respond. If you want to only access the cache and not live fetch any\n   * metadata for cache misses then set this value to 0.\n   */\n  tokenUriTimeoutInMs?: number;\n\n  /**\n   * Whether to refresh the metadata for the given NFT token before returning\n   * the response. Defaults to false for faster response times.\n   */\n  refreshCache?: boolean;\n}\n\n/**\n * The successful object returned by the {@link getFloorPrice} call for each\n * marketplace (e.g. looksRare).\n *\n * @public\n */\nexport interface FloorPriceMarketplace {\n  /** The floor price of the collection on the given marketplace */\n  readonly floorPrice: number;\n  /** The currency in which the floor price is denominated */\n  readonly priceCurrency: string;\n  /** The link to the collection on the given marketplace */\n  readonly collectionUrl: string;\n  /** UTC timestamp of when the floor price was retrieved from the marketplace */\n  readonly retrievedAt: string;\n}\n\n/**\n * The failing object returned by the {@link getFloorPrice} call for each\n * marketplace (e.g. looksRare).\n *\n * @public\n */\nexport interface FloorPriceError {\n  /** Error fetching floor prices from the given marketplace */\n  readonly error: string;\n}\n\n/**\n * The response object for the {@link getFloorPrice} method.\n *\n * @public\n */\nexport interface GetFloorPriceResponse {\n  /**\n   * Name of the NFT marketplace where the collection is listed. Current\n   * marketplaces supported: OpenSea, LooksRare\n   */\n  readonly openSea: FloorPriceMarketplace | FloorPriceError;\n  readonly looksRare: FloorPriceMarketplace | FloorPriceError;\n}\n\n/**\n * Optional parameters object for the the {@link getContractsForOwner} method\n *\n * @public\n */\nexport interface GetContractsForOwnerOptions {\n  /** Key for pagination to use to fetch results from the next page if available. */\n  pageKey?: string;\n\n  /**\n   * Configure the number of NFTs to return in each response. Maximum pages size\n   * is 100. Defaults to 100.\n   */\n  pageSize?: number;\n\n  /**\n   * Optional list of filters applied to the query. NFTs that match one or more\n   * of these filters are included in the response. May not be used in\n   * conjunction with {@link excludeFilters}.\n   */\n  includeFilters?: NftFilters[];\n\n  /**\n   * Optional list of filters applied to the query. NFTs that match one or more\n   * of these filters are excluded from the response. May not be used in\n   * conjunction with {@link includeFilters}\n   */\n  excludeFilters?: NftFilters[];\n\n  /**\n   * Order in which to return results. By default, results are ordered by\n   * contract address and token ID in lexicographic order.\n   */\n  orderBy?: NftOrdering;\n}\n\n/**\n * The response for the {@link NftNamespace.getContractsForOwner} method.\n *\n * @public\n */\nexport interface GetContractsForOwnerResponse {\n  /** The list of contracts, that match the query, held by the given address. */\n  contracts: ContractForOwner[];\n\n  /** Key for pagination to use to fetch results from the next page if available. */\n  pageKey?: string;\n\n  /** Total number of NFT contracts held by the given address. */\n  totalCount: number;\n}\n\n/** Represents a single NFT contract data in the {@link GetContractsForOwnerResponse}. */\nexport interface ContractForOwner extends NftContract {\n  /**\n   * Sum of NFT balances across all token IDs held by the owner. For\n   * non-fungible tokens this will be equal to the numDistinctTokensOwned, but\n   * it may be higher if the user holds some fungible ERC1155 tokens.\n   */\n  totalBalance: number;\n\n  /** The title of the token held by the owner. */\n  title: string;\n\n  /**\n   * Number of distinct token IDs held by the owner. For non-fungible tokens\n   * this will be equal to the totalBalance, but it may be lower if the user\n   * holds some fungible ERC1155 tokens.\n   */\n  numDistinctTokensOwned: number;\n\n  isSpam: boolean;\n\n  /** One of the tokens from this contract held by the owner. */\n  tokenId: string;\n\n  /** Alternative NFT metadata for this contract to be parsed manually. */\n  media: Media[];\n}\n\n/**\n * The type of transfer for the request. Note that using `TO` will also include\n * NFTs that were minted by the owner.\n */\nexport enum GetTransfersForOwnerTransferType {\n  'TO' = 'TO',\n  'FROM' = 'FROM'\n}\n\n/**\n * Optional parameters object for the {@link NftNamespace.getTransfersForOwner} method.\n */\nexport interface GetTransfersForOwnerOptions {\n  /**\n   * List of NFT contract addresses to filter mints by. If omitted, defaults to\n   * all contract addresses.\n   */\n  contractAddresses?: string[];\n\n  /**\n   * Filter mints by ERC721 vs ERC1155 contracts. If omitted, defaults to all\n   * NFTs.\n   */\n  tokenType?: NftTokenType.ERC1155 | NftTokenType.ERC721;\n\n  /**\n   * Optional page key from an existing {@link TransfersNftResponse} to use for\n   * pagination.\n   */\n  pageKey?: string;\n}\n\n/**\n * Optional parameters object for the {@link NftNamespace.getTransfersForOwner}\n * method.\n */\nexport interface GetTransfersForContractOptions {\n  /** Starting block (inclusive) to get transfers from. */\n  fromBlock?: BlockTag;\n  /** Ending block (inclusive) to get transfers from. */\n  toBlock?: BlockTag;\n  /**\n   * Whether to return results in ascending or descending order by block number.\n   * Defaults to ascending if omitted.\n   */\n  order?: SortingOrder;\n  /**\n   * Optional page key from an existing {@link TransfersNftResponse} to use for\n   * pagination.\n   */\n  pageKey?: string;\n}\n\n/**\n * Response object for NFT methods that fetch NFTs that were transferred or\n * minted (ex: {@link NftNamespace.getTransfersForOwner} or\n * {@link NftNamespace.getMintedNfts}).\n */\nexport interface TransfersNftResponse {\n  /** An array of NFTs.*/\n  nfts: TransferredNft[];\n  /** Optional page key to use to fetch the next group of NFTs. */\n  pageKey?: string;\n}\n\n/**\n * NFT with extra data for a single NFT that was transferred or minted.\n */\nexport interface TransferredNft extends Nft {\n  /**\n   * The address the NFT was from. For minted NFTs, this field is the set to\n   * `0x0000000000000000000000000000000000000000`.\n   **/\n  from: string;\n  /** The address the NFT was sent or minted to. */\n  to?: string;\n  /** The transaction hash where the transfer or mint occurred. */\n  transactionHash: string;\n  /** The block number as a hex string of when the transfer or mint occurred. */\n  blockNumber: string;\n}\n\n/**\n * Optional parameters object for the {@link NftNamespace.getMintedNfts} method.\n */\nexport interface GetMintedNftsOptions {\n  /**\n   * List of NFT contract addresses to filter mints by. If omitted, defaults to\n   * all contract addresses.\n   */\n  contractAddresses?: string[];\n\n  /**\n   * Filter mints by ERC721 vs ERC1155 contracts. If omitted, defaults to all\n   * NFTs.\n   */\n  tokenType?: NftTokenType.ERC1155 | NftTokenType.ERC721;\n\n  /**\n   * Optional page key from an existing {@link TransfersNftResponse} to use for\n   * pagination.\n   */\n  pageKey?: string;\n}\n\n/**\n * @deprecated Use {@link TransfersNftResponse} instead.\n */\nexport interface GetMintedNftsResponse {\n  /** An array of the minted NFTs for the provided owner address. */\n  nfts: Nft[];\n\n  /** Key for pagination to use to fetch results from the next page if available. */\n  pageKey?: string;\n}\n\n/**\n * Optional parameters object for the {@link NftNamespace.getNftSales} method.\n *\n * This interface is used to filter the NFT sales data.\n *\n * @public\n */\nexport interface GetNftSalesOptions {\n  /** The block number to start fetching NFT sales data from. */\n  fromBlock?: number | 'latest';\n\n  /** The block number limit to fetch NFT sales data from. */\n  toBlock?: number | 'latest';\n\n  /** Whether to return the results in ascending or descending order by block number. */\n  order?: SortingOrder;\n\n  /** The NFT marketplace to filter sales by. */\n  marketplace?: NftSaleMarketplace;\n\n  /** The address of the NFT buyer to filter sales by. */\n  buyerAddress?: string;\n\n  /** The address of the NFT seller to filter sales by. */\n  sellerAddress?: string;\n\n  /**\n   * Filter by whether the buyer or seller was the taker in the NFT trade.\n   * Defaults to returning both buyer and seller taker trades.\n   */\n  taker?: NftSaleTakerType;\n\n  /** The maximum number of NFT sales to return. */\n  limit?: number;\n\n  /** Key for pagination to use to fetch results from the next page if available. */\n  pageKey?: string;\n}\n\n/**\n * Alternative optional parameters object for the {@link NftNamespace.getNftSales}\n * method that allows filtering results by contractAddress.\n *\n * This interface is used to filter the NFT sales data.\n *\n * @public\n */\nexport interface GetNftSalesOptionsByContractAddress\n  extends GetNftSalesOptions {\n  /** The contract address of a NFT collection to filter sales by. */\n  contractAddress: string;\n\n  /** The token ID of an NFT within the specified contractAddress to filter sales by. */\n  tokenId?: BigNumberish;\n}\n\n/**\n * The response for the {@link NftNamespace.getNftSales} method.\n *\n * @public\n */\nexport interface GetNftSalesResponse {\n  /** List of NFT sales that match the query */\n  nftSales: NftSale[];\n\n  /** Block Information of the block as of which the corresponding data is valid. */\n  validAt: NftSaleValidAt;\n\n  /** The page key to use to fetch the next page if more results are available. */\n  pageKey?: string;\n}\n\n/** Represents a single NFT sale data in the {@link GetNftSalesResponse}. */\nexport interface NftSale {\n  /** The marketplace the sale took place on. */\n  marketplace: NftSaleMarketplace;\n\n  /** The NFT contract address. */\n  contractAddress: string;\n\n  /** The decimal token ID of the NFT being sold. */\n  tokenId: string;\n\n  /** The number of tokens sold in the sale as a decimal integer string. */\n  quantity: string;\n\n  /** The address of the buyer in the NFT sale. */\n  buyerAddress: string;\n\n  /** The address of the seller in the NFT sale. */\n  sellerAddress: string;\n\n  /** Whether the price taker in the trade was the buyer or the seller. */\n  taker: NftSaleTakerType;\n\n  /** The payment from buyer to the seller. */\n  sellerFee: NftSaleFeeData;\n\n  /**\n   * The payment from buyer to the marketplace.\n   * @deprecated Please use `protocolFee` instead.\n   */\n  marketplaceFee?: NftSaleFeeData;\n\n  /** The payment from buyer to the marketplace. */\n  protocolFee?: NftSaleFeeData;\n\n  /** The payment from buyer to the royalty address of the NFT collection. */\n  royaltyFee?: NftSaleFeeData;\n\n  /** The block number the NFT sale took place in. */\n  blockNumber: number;\n\n  /** The log number of the sale event emitted within the block. */\n  logIndex: number;\n\n  /** The index of the token within the bundle of NFTs sold in the sale. */\n  bundleIndex: number;\n\n  /** The transactionHash of the NFT sale. */\n  transactionHash: string;\n}\n\n/** The block information at which the NFT sale information is valid at. */\nexport interface NftSaleValidAt {\n  /** The block number the sale information is valid at. */\n  blockNumber: number;\n  /** The block hash. Used to detect reorgs. */\n  blockHash?: string;\n  /** The timestamp for the block. */\n  blockTimestamp?: string;\n}\n\n/**\n * Fee detail for an NFT sale.\n *\n * @public\n */\nexport interface NftSaleFeeData {\n  /** The fee payment amount as a decimal integer string. */\n  amount: string;\n\n  /** The symbol of the token used for the payment. */\n  symbol: string;\n\n  /**\n   * The number of decimals of the token used for the payment.\n   * @deprecated Please use `decimals` instead. This field contains a typo\n   * and will always be undefined. It's been marked as deprecated to avoid\n   * breaking changes.\n   */\n  decimal: number;\n\n  /** The number of decimals of the token used for the payment. */\n  decimals: number;\n}\n\n/**\n * Enum for representing the supported sorting orders of the API.\n *\n * @public\n */\nexport enum SortingOrder {\n  ASCENDING = 'asc',\n  DESCENDING = 'desc'\n}\n\n/**\n * Enum representing the supported NFT marketplaces by the\n * {@link NftNamespace.getNftSales} method.\n *\n * @public\n */\nexport enum NftSaleMarketplace {\n  SEAPORT = 'seaport',\n  LOOKSRARE = 'looksrare',\n  X2Y2 = 'x2y2',\n  WYVERN = 'wyvern',\n  CRYPTOPUNKS = 'cryptopunks',\n  BLUR = 'blur',\n  UNKNOWN = 'unknown'\n}\n\n/**\n * Enum for specifying the taker type for the {@link NftNamespace.getNftSales}\n * method.\n *\n * @public\n */\nexport enum NftSaleTakerType {\n  BUYER = 'buyer',\n  SELLER = 'seller'\n}\n\n/**\n * Information about the rarity of an NFT's attribute in the specified collection.\n *\n * @public\n */\nexport interface NftAttributeRarity {\n  /** Name of the NFT's attribute. */\n  value: string;\n\n  /** The type of NFT attribute. */\n  traitType: string;\n\n  /**\n   * A number from 0 to 1 representing the prevalence of this value for this\n   * trait type in the current collection.\n   */\n  prevalence: number;\n}\n\n/**\n * Summary of the attribute prevalence for the specified NFT contract.\n *\n * @public\n */\nexport interface NftAttributesResponse {\n  /** The specified NFT contract's address. */\n  contractAddress: string;\n\n  /** The specified NFT contract's total supply. */\n  totalSupply: number;\n\n  /**\n   * The attribute prevalence of each trait grouped by the trait type for the\n   * provided NFT.\n   */\n  summary: Record<string, Record<string, number>>;\n}\n\n/** The refresh result response object returned by {@link refreshContract}. */\nexport interface RefreshContractResult {\n  /** The NFT contract address that was passed in to be refreshed. */\n  contractAddress: string;\n\n  /** The current state of the refresh request. */\n  refreshState: RefreshState;\n\n  /**\n   * Percentage of tokens currently refreshed, represented as an integer string.\n   * Field can be null if the refresh has not occurred.\n   */\n  progress: string | null;\n}\n\n/** The current state of the NFT contract refresh process. */\nexport enum RefreshState {\n  /** The provided contract is not an NFT or does not contain metadata. */\n  DOES_NOT_EXIST = 'does_not_exist',\n\n  /** The contract has already been queued for refresh. */\n  ALREADY_QUEUED = 'already_queued',\n\n  /** The contract is currently being refreshed. */\n  IN_PROGRESS = 'in_progress',\n\n  /** The contract refresh is complete. */\n  FINISHED = 'finished',\n\n  /** The contract refresh has been queued and await execution. */\n  QUEUED = 'queued',\n\n  /** The contract was unable to be queued due to an internal error. */\n  QUEUE_FAILED = 'queue_failed'\n}\n\n/**\n * The parameter field of {@link TransactionReceiptsParams}.\n *\n * @public\n */\nexport interface TransactionReceiptsBlockNumber {\n  /** The block number to get transaction receipts for. */\n  blockNumber: string;\n}\n\n/**\n * The parameter field of {@link TransactionReceiptsParams}.\n *\n * @public\n */\nexport interface TransactionReceiptsBlockHash {\n  /** The block hash to get transaction receipts for. */\n  blockHash: string;\n}\n\n/**\n * The parameters to use with the {@link CoreNamespace.getTransactionReceipts} method.\n *\n * @public\n */\nexport type TransactionReceiptsParams =\n  | TransactionReceiptsBlockNumber\n  | TransactionReceiptsBlockHash;\n\n/**\n * Response object for a {@link CoreNamespace.getTransactionReceipts} call.\n *\n * @public\n */\nexport interface TransactionReceiptsResponse {\n  /** A list of transaction receipts for the queried block. */\n  receipts: TransactionReceipt[] | null;\n}\n\n/**\n * Metadata object returned in a {@link AssetTransfersResult} object if the asset\n * transferred is an ERC1155.\n *\n * @public\n */\nexport interface ERC1155Metadata {\n  tokenId: string;\n  value: string;\n}\n\n/**\n * Information about the underlying contract for the asset that was transferred\n * in a {@link AssetTransfersResult} object.\n *\n * @public\n */\nexport interface RawContract {\n  /**\n   * The raw transfer value as a hex string. `null` if the transfer was for an\n   * ERC721 or ERC1155 token.\n   */\n  value: string | null;\n\n  /** The contract address. `null` if it was an internal or external transfer. */\n  address: string | null;\n\n  /**\n   * The number of decimals in the contract as a hex string. `null` if the value\n   * is not in the contract and not available from other sources.\n   */\n  decimal: string | null;\n}\n\n/**\n * Optional parameters object for the {@link getNftsForContract} and\n * {@link getNftsForContractIterator} functions.\n *\n * This interface is used to fetch NFTs with their associated metadata. To get\n * Nfts without their associated metadata, use {@link GetBaseNftsForContractOptions}.\n *\n * @public\n */\nexport interface GetNftsForContractOptions {\n  /**\n   * Optional page key from an existing {@link NftContractBaseNftsResponse} or\n   * {@link NftContractNftsResponse}to use for pagination.\n   */\n  pageKey?: string;\n\n  /** Optional boolean flag to omit NFT metadata. Defaults to `false`. */\n  omitMetadata?: boolean;\n\n  /**\n   * Sets the total number of NFTs to return in the response. Defaults to 100.\n   * Maximum page size is 100.\n   */\n  pageSize?: number;\n\n  /**\n   * No set timeout by default - When metadata is requested, this parameter is\n   * the timeout (in milliseconds) for the website hosting the metadata to\n   * respond. If you want to only access the cache and not live fetch any\n   * metadata for cache misses then set this value to 0.\n   */\n  tokenUriTimeoutInMs?: number;\n}\n\n/**\n * Optional parameters object for the {@link getNftsForContract} and\n * {@link getNftsForContractIterator} functions.\n *\n * This interface is used to fetch NFTs without their associated metadata. To\n * get Nfts with their associated metadata, use {@link GetNftsForContractOptions}.\n *\n * @public\n */\nexport interface GetBaseNftsForContractOptions {\n  /**\n   * Optional page key from an existing {@link NftContractBaseNftsResponse} or\n   * {@link NftContractNftsResponse}to use for pagination.\n   */\n  pageKey?: string;\n\n  /** Optional boolean flag to omit NFT metadata. Defaults to `false`. */\n  omitMetadata: false;\n\n  /**\n   * Sets the total number of NFTs to return in the response. Defaults to 100.\n   * Maximum page size is 100.\n   */\n  pageSize?: number;\n\n  /**\n   * No set timeout by default - When metadata is requested, this parameter is\n   * the timeout (in milliseconds) for the website hosting the metadata to\n   * respond. If you want to only access the cache and not live fetch any\n   * metadata for cache misses then set this value to 0.\n   */\n  tokenUriTimeoutInMs?: number;\n}\n\n/**\n * Optional parameters object for the {@link getNftsForContract} method.\n *\n * This interface configures options when fetching the owner addresses of the\n * provided contract.\n *\n * @public\n */\nexport interface GetOwnersForContractOptions {\n  /**\n   * Whether to include the token balances per token id for each owner. Defaults\n   * to false when omitted.\n   */\n  withTokenBalances?: boolean;\n\n  /** The block number in hex or decimal to fetch owners for. */\n  block?: string;\n\n  /** Optional page key to paginate the next page for large requests. */\n  pageKey?: string;\n\n  /**\n   * If true, include total count of owners in the response. Only applicable\n   * when `withTokenBalances` is not set to `true`.\n   */\n  includeCount?: boolean;\n}\n\n/**\n * Optional parameters object for the {@link getNftsForContract} method.\n *\n * This interface configures options when fetching the owner addresses of the\n * provided contract.\n *\n * @public\n */\nexport interface GetOwnersForContractWithTokenBalancesOptions {\n  /**\n   * Whether to include the token balances per token id for each owner. Defaults\n   * to false when omitted.\n   */\n  withTokenBalances: true;\n\n  /** The block number in hex or decimal to fetch owners for. */\n  block?: string;\n\n  /** Optional page key to paginate the next page for large requests. */\n  pageKey?: string;\n}\n\n/**\n * Optional parameters object for the {@link getOwnersForNft} method.\n *\n * This interface configures options when fetching the owner addresses of the\n * provided NFT contract.\n *\n * @public\n */\nexport interface GetOwnersForNftOptions {\n  /** Optional page key to paginate the next page for large requests. */\n  pageKey?: string;\n\n  /**\n   * Sets the total number of owners to return in the response.\n   */\n  pageSize?: number;\n}\n\n/**\n * The response object for the {@link getNftsForContract} function. The object\n * contains the NFTs without metadata inside the NFT contract.\n *\n * @public\n */\nexport interface NftContractBaseNftsResponse {\n  /** An array of NFTs without metadata. */\n  nfts: BaseNft[];\n\n  /**\n   * Pagination token that can be passed into another request to fetch the next\n   * NFTs. If there is no page key, then there are no more NFTs to fetch.\n   */\n  pageKey?: string;\n}\n\n/**\n * The response object for the {@link getNftsForContract} function. The object\n * contains the NFTs with metadata inside the NFT contract.\n *\n * @public\n */\nexport interface NftContractNftsResponse {\n  /** An array of NFTs with metadata. */\n  nfts: Nft[];\n\n  /**\n   * Pagination token that can be passed into another request to fetch the next\n   * NFTs. If there is no page key, then there are no more NFTs to fetch.\n   */\n  pageKey?: string;\n}\n\n/** OpenSea's metadata for an NFT collection. */\nexport interface OpenSeaCollectionMetadata {\n  /** The floor price of the NFT. */\n  floorPrice?: number;\n  /** The name of the collection on OpenSea. */\n  collectionName?: string;\n  /** The approval status of the collection on OpenSea. */\n  safelistRequestStatus?: OpenSeaSafelistRequestStatus;\n  /** The image URL determined by OpenSea. */\n  imageUrl?: string;\n  /** The description of the collection on OpenSea. */\n  description?: string;\n  /** The homepage of the collection as determined by OpenSea. */\n  externalUrl?: string;\n  /** The Twitter handle of the collection. */\n  twitterUsername?: string;\n  /** The Discord URL of the collection. */\n  discordUrl?: string;\n  /** Timestamp of when the OpenSea metadata was last ingested by Alchemy. */\n  lastIngestedAt?: string;\n}\n\n/** An OpenSea collection's approval status. */\nexport enum OpenSeaSafelistRequestStatus {\n  /** Verified collection. */\n  VERIFIED = 'verified',\n  /** Collections that are approved on open sea and can be found in search results. */\n  APPROVED = 'approved',\n  /** Collections that requested safelisting on OpenSea. */\n  REQUESTED = 'requested',\n  /** Brand new collections. */\n  NOT_REQUESTED = 'not_requested'\n}\n\n/**\n * The response object for the {@link findContractDeployer} function.\n *\n * @public\n */\nexport interface DeployResult {\n  /** The address of the contract deployer, if it is available. */\n  readonly deployerAddress?: string;\n\n  /** The block number the contract was deployed in. */\n  readonly blockNumber: number;\n}\n\n/**\n * Method names for Alchemy's custom Subscription API endpoints.\n *\n * This value is provided in the `method` field when creating an event filter on\n * the Websocket Namespace.\n */\nexport enum AlchemySubscription {\n  PENDING_TRANSACTIONS = 'alchemy_pendingTransactions',\n  MINED_TRANSACTIONS = 'alchemy_minedTransactions'\n}\n\n/**\n * Event filter for the {@link AlchemyWebSocketProvider.on} and\n * {@link AlchemyWebSocketProvider.once} methods to use Alchemy's custom\n * `alchemy_pendingTransactions` endpoint.\n *\n * Returns the transaction information for all pending transactions that match a\n * given filter. For full documentation, see:\n * {@link https://docs.alchemy.com/reference/alchemy-pendingtransactions}\n *\n * Note that excluding all optional parameters will return transaction\n * information for ALL pending transactions that are added to the mempool.\n *\n * @public\n */\nexport interface AlchemyPendingTransactionsEventFilter {\n  method: AlchemySubscription.PENDING_TRANSACTIONS;\n\n  /**\n   * Filter pending transactions sent FROM the provided address or array of\n   * addresses.\n   *\n   * If a {@link AlchemyPendingTransactionsEventFilter.toAddress} is also\n   * present, then this filter will return transactions sent from the\n   * `fromAddress` OR transactions received by the `toAddress`.\n   */\n  fromAddress?: string | string[];\n\n  /**\n   * Filter pending transactions sent TO the provided address or array of\n   * addresses.\n   *\n   * If a {@link AlchemyPendingTransactionsEventFilter.fromAddress} is also\n   * present, then this filter will return transactions sent from the\n   * `fromAddress` OR transactions received by the `toAddress`.\n   */\n  toAddress?: string | string[];\n\n  /**\n   * Whether to only include transaction hashes and exclude the rest of the\n   * transaction response for a smaller payload. Defaults to false (by default,\n   * the entire transaction response is included).\n   *\n   * Note that setting only {@link hashesOnly} to true will return the same\n   * response as subscribing to `newPendingTransactions`.\n   */\n  hashesOnly?: boolean;\n}\n\n/**\n * Event filter for the {@link AlchemyWebSocketProvider.on} and\n * {@link AlchemyWebSocketProvider.once} methods to use Alchemy's custom\n * `alchemy_minedTransactions` endpoint.\n *\n * Returns the transaction information for all mined transactions that match the\n * provided filter. For full documentation, see:\n * {@link https://docs.alchemy.com/reference/alchemy-minedtransactions}\n *\n * Note that excluding all optional parameters will return transaction\n * information for ALL mined transactions.\n *\n * @public\n */\nexport interface AlchemyMinedTransactionsEventFilter {\n  method: AlchemySubscription.MINED_TRANSACTIONS;\n\n  /**\n   * Address filters to subscribe to. Defaults to all transactions if omitted.\n   * Limit 100 address filters. Requires a non-empty array.\n   */\n  addresses?: NonEmptyArray<AlchemyMinedTransactionsAddress>;\n\n  /**\n   * Whether to include transactions that were removed from the mempool.\n   * Defaults to false.\n   */\n  includeRemoved?: boolean;\n\n  /**\n   * Whether to only include transaction hashes and exclude the rest of the\n   * transaction response for a smaller payload. Defaults to false (by default,\n   * the entire transaction response is included).\n   */\n  hashesOnly?: boolean;\n}\n\n/**\n * Address filters for {@link AlchemyMinedTransactionsEventFilter}. Requires at\n * least one of the fields to be set.\n */\nexport type AlchemyMinedTransactionsAddress = RequireAtLeastOne<{\n  to?: string;\n  from?: string;\n}>;\n\n/**\n * Alchemy's event type that extends the default {@link EventType} interface to\n * also include Alchemy's Subscription API.\n *\n * @public\n */\nexport type AlchemyEventType = EventType | AlchemyEventFilter;\n\n/**\n * This type represents the Alchemy's Subscription API endpoints as event\n * filters compatible with other ethers events.\n */\nexport type AlchemyEventFilter =\n  | AlchemyMinedTransactionsEventFilter\n  | AlchemyPendingTransactionsEventFilter;\n\n/** Options for the {@link TransactNamespace.sendPrivateTransaction} method. */\nexport interface SendPrivateTransactionOptions {\n  /**\n   * Whether to use fast-mode. Defaults to false. Please note that fast mode\n   * transactions cannot be cancelled using\n   * {@link TransactNamespace.cancelPrivateTransaction}. method.\n   *\n   * See {@link https://docs.flashbots.net/flashbots-protect/rpc/fast-mode} for\n   * more details.\n   */\n  fast: boolean;\n}\n\n/**\n * Asset type returned when calling {@link TransactNamespace.simulateAssetChanges}.\n * Allows you to determine if the assets approved or / and transferred are\n * native, tokens or NFTs.\n */\nexport enum SimulateAssetType {\n  /**\n   * Native transfers that involve the currency of the chain the simulation is\n   * run on (ex: ETH for Ethereum, MATIC for Polygon, ETH for Arbitrum).\n   */\n  NATIVE = 'NATIVE',\n  /** ERC20 approval or transfers. */\n  ERC20 = 'ERC20',\n  /** ERC721 approval or transfers. */\n  ERC721 = 'ERC721',\n  /** ERC1155 approval or transfers. */\n  ERC1155 = 'ERC1155',\n  /**\n   * Special contracts that don't follow ERC 721/1155.Currently limited to\n   * CryptoKitties and CryptoPunks.\n   */\n  SPECIAL_NFT = 'SPECIAL_NFT'\n}\n\n/**\n * Change type returned when calling {@link TransactNamespace.simulateAssetChanges}.\n */\nexport enum SimulateChangeType {\n  /**\n   * Represents a transaction that approved or disapproved permissions for a\n   * contract.\n   *\n   * APPROVE without token ID → approve all tokens\n   * APPROVE without amount → approve all amount\n   * APPROVE with zero amount → approval being cleared\n   */\n  APPROVE = 'APPROVE',\n\n  /**\n   * Represents a transaction that transferred tokens from one address to another.\n   */\n  TRANSFER = 'TRANSFER'\n}\n\n/**\n * The error field returned in a {@link SimulateAssetChangesResponse} if the\n * simulation failed.\n */\nexport interface SimulateAssetChangesError extends Record<string, any> {\n  /** The error message. */\n  message: string;\n}\n\n/**\n * Represents an asset change from a call to\n * {@link TransactNamespace.simulateAssetChanges}.\n */\nexport interface SimulateAssetChangesChange {\n  /** The type of asset from the transaction. */\n  assetType: SimulateAssetType;\n\n  /** The type of change from the transaction. */\n  changeType: SimulateChangeType;\n\n  /** The from address. */\n  from: string;\n\n  /** The to address. */\n  to: string;\n\n  /**\n   * The raw amount as an integer string. Only available on TRANSFER changes for\n   * NATIVE and ERC20 assets, or ERC721/ERC1155 disapprove changes (field set to\n   * '0').\n   */\n  rawAmount?: string;\n\n  /**\n   * The amount as an integer string. This value is calculated by applying the\n   * `decimals` field to the `rawAmount` field. Only available on TRANSFER\n   * changes for NATIVE and ERC20 assets, or ERC721/ERC1155 disapprove changes\n   * (field set to '0').\n   */\n  amount?: string;\n\n  /** The name of the asset transferred, if available. */\n  name?: string;\n\n  /** The symbol of the asset transferred if available. */\n  symbol?: string;\n\n  /**\n   * The number of decimals used by the ERC20 token. Set to 0 for APPROVE\n   * changes. Field is undefined if it's not defined in the contract and not\n   * available from other sources.\n   */\n  decimals?: number;\n\n  /**\n   * The contract address of the asset. Only applicable to ERC20, ERC721,\n   * ERC1155, NFT and SPECIAL_NFT transactions.\n   */\n  contractAddress?: string;\n\n  /**\n   * URL for the logo of the asset, if available. Only applicable to ERC20 transactions.\n   */\n  logo?: string;\n\n  /**\n   * The token id of the asset transferred. Only applicable to ERC721,\n   * ERC1155 and SPECIAL_NFT NFTs.\n   */\n  tokenId?: string;\n}\n\n/**\n * Response object for the {@link TransactNamespace.simulateAssetChanges} method.\n */\nexport interface SimulateAssetChangesResponse {\n  /** An array of asset changes that resulted from the transaction. */\n  changes: SimulateAssetChangesChange[];\n  /**\n   * The amount of gas used by the transaction represented as a hex string. The\n   * field is undefined if an error occurred.\n   */\n  gasUsed?: string;\n  /** Optional error field that is present if an error occurred. */\n  error?: SimulateAssetChangesError;\n}\n\n/**\n * Authority used to decode calls and logs when using the\n * {@link TransactNamespace.simulateExecution} method.\n */\nexport enum DecodingAuthority {\n  ETHERSCAN = 'ETHERSCAN'\n}\n\n/** The input or output parameters from a {@link DecodedDebugCallTrace}. */\nexport interface DecodedCallParam {\n  /** Value of the parameter. */\n  value: string;\n  /** The name of the parameter. */\n  name: string;\n  /** The type of the parameter.*/\n  type: string;\n}\n\n/** The input parameters from a {@link DecodedLog}. */\nexport interface DecodedLogInput extends DecodedCallParam {\n  /** Whether the log is marked as indexed in the smart contract. */\n  indexed: boolean;\n}\n\n/**\n * Decoded representation of the call trace that is part of a\n * {@link SimulationCallTrace}.\n */\nexport interface DecodedDebugCallTrace {\n  /** The smart contract method called. */\n  methodName: string;\n  /** Method inputs. */\n  inputs: DecodedCallParam[];\n  /** Method outputs. */\n  outputs: DecodedCallParam[];\n  /** The source used to provide the decoded call trace. */\n  authority: DecodingAuthority;\n}\n\n/** The type of call in a debug call trace. */\nexport enum DebugCallType {\n  CREATE = 'CREATE',\n  CALL = 'CALL',\n  STATICCALL = 'STATICCALL',\n  DELEGATECALL = 'DELEGATECALL'\n}\n\n/**\n * Debug call trace in a {@link SimulateExecutionResponse}.\n */\nexport interface SimulationCallTrace\n  extends Omit<DebugCallTrace, 'revertReason' | 'calls'> {\n  /** The type of call. */\n  type: DebugCallType;\n  /** A decoded version of the call. Provided on a best-effort basis. */\n  decoded?: DecodedDebugCallTrace;\n}\n\n/**\n * Decoded representation of the debug log that is part of a\n * {@link SimulationDebugLog}.\n */\n\nexport interface DecodedLog {\n  /** The decoded name of the log event. */\n  eventName: string;\n  /** The decoded inputs to the log. */\n  inputs: DecodedLogInput[];\n  /** The source used to provide the decoded log. */\n  authority: DecodingAuthority;\n}\n\n/**\n * Debug log in a {@link SimulateExecutionResponse}.\n */\nexport interface SimulationDebugLog {\n  /** An array of topics in the log. */\n  topics: string[];\n  /** The address of the contract that generated the log. */\n  address: string;\n  /** The data included the log. */\n  data: string;\n  /** A decoded version of the log. Provided on a best-effort basis. */\n  decoded?: DecodedLog;\n}\n\n/** Response object for the {@link TransactNamespace.simulateExecution} method. */\nexport interface SimulateExecutionResponse {\n  /**\n   * An array of traces generated during simulation that represent the execution\n   * of the transaction along with the decoded calls if available.\n   */\n  calls: SimulationCallTrace[];\n\n  /**\n   * An array of logs emitted during simulation along with the decoded logs if\n   * available.\n   */\n  logs: SimulationDebugLog[];\n}\n\n/**\n * Response object for the {@link TransactNamespace.sendGasOptimizedTransaction} method.\n *\n * @internal\n */\n// TODO(txjob): Remove internal tag once this feature is released.\nexport interface GasOptimizedTransactionResponse {\n  /**\n   * The tracking id. This can be used to check the status of the transaction\n   * via {@link TransactNamespace.getGasOptimizedTransactionStatus}.\n   */\n  trackingId: string;\n\n  /* An array of the transaction hashes from submitted transactions. */\n  transactionHashes: string[];\n}\n\n/**\n * Response object for the\n * {@link TransactNamespace.getGasOptimizedTransactionStatus} method.\n *\n * @internal\n */\n// TODO(txjob): Remove internal tag once this feature is released.\nexport interface GasOptimizedTransactionStatusResponse {\n  /** The status of the submitted transaction job. */\n  jobStatus: GasOptimizedTransactionStatus;\n\n  /** An array of the submitted transactions hashes that have been attempted. */\n  transactionHashesAttempted: string[];\n\n  /** The final mined transaction hash if the job was completed successfully. */\n  minedTransactionHash?: string;\n}\n\n/**\n * Potential transaction job statuses for a {@link GasOptimizedTransactionResponse}\n *\n * @internal\n */\n// TODO(txjob): Remove internal tag once this feature is released.\nexport enum GasOptimizedTransactionStatus {\n  UNSPECIFIED = 'TRANSACTION_JOB_STATUS_UNSPECIFIED',\n  IN_PROGRESS = 'IN_PROGRESS',\n  COMPLETE = 'COMPLETE',\n  ABANDONED = 'ABANDONED'\n}\n\n/** SDK representation of a Webhook in the Notify API. */\nexport interface Webhook {\n  /** The webhook's unique id. */\n  id: string;\n  /** The network the webhook is on. */\n  network: Network;\n  /** The type of webhook. */\n  type: WebhookType;\n  /** The url that the webhook sends its payload to. */\n  url: string;\n  /** Whether the webhook is currently active */\n  isActive: boolean;\n  /** The creation time of the webhook as an ISO string. */\n  timeCreated: string;\n  /** The signing key used to verify payloads for the webhook. */\n  signingKey: string;\n  /** The webhook version. All newly created webhooks default to V2. */\n  version: WebhookVersion;\n  /**\n   * The app id of the app used for the webhook. This field is only present on\n   * {@link MinedTransactionWebhook} and {@link DroppedTransactionWebhook}\n   */\n  appId?: string;\n}\n\n/** The version of the webhook. All newly created webhooks default to V2. */\nexport enum WebhookVersion {\n  V1 = 'V1',\n  V2 = 'V2'\n}\n\n/** The type of {@link Webhook}. */\nexport enum WebhookType {\n  MINED_TRANSACTION = 'MINED_TRANSACTION',\n  DROPPED_TRANSACTION = 'DROPPED_TRANSACTION',\n  ADDRESS_ACTIVITY = 'ADDRESS_ACTIVITY',\n  NFT_ACTIVITY = 'NFT_ACTIVITY',\n  NFT_METADATA_UPDATE = 'NFT_METADATA_UPDATE',\n  GRAPHQL = 'GRAPHQL'\n}\n\n/**\n * A Mined Transaction Webhook is used to notify your app whenever a transaction\n * sent through your API key gets successfully mined. This is useful if you want\n * to notify customers that their transaction went through.\n */\nexport interface MinedTransactionWebhook extends Webhook {\n  type: WebhookType.MINED_TRANSACTION;\n}\n\n/**\n * A Dropped Transaction webhook is used to notify your app whenever a\n * transaction sent through your API key gets dropped. This can be useful if you\n * want to notify customers that their transactions were dropped.\n */\nexport interface DroppedTransactionWebhook extends Webhook {\n  type: WebhookType.DROPPED_TRANSACTION;\n}\n\n/**\n * An Address Activity Webhook tracks ETH, ERC20, ERC721, and ERC1155 transfers\n * for the provided addresses. This can be used to notify your app with\n * real-time state changes when your tracked addresses send or receive tokens.\n */\nexport interface AddressActivityWebhook extends Webhook {\n  type: WebhookType.ADDRESS_ACTIVITY;\n}\n\n/**\n * The NFT Activity Webhook tracks all ERC721 and ERC1155 activity. This can be\n * used to notify your app with real time state changes when an NFT is\n * transferred between addresses.\n */\nexport interface NftActivityWebhook extends Webhook {\n  type: WebhookType.NFT_ACTIVITY;\n}\n\n/**\n * The NFT Metadata Update Webhook tracks all ERC721 and ERC1155 metadata updates.\n * This can be used to notify your app with real time state changes when an NFT's\n * metadata changes.\n */\nexport interface NftMetadataUpdateWebhook extends Webhook {\n  type: WebhookType.NFT_METADATA_UPDATE;\n}\n\n/**\n * The Custom Webhook can track any event on every block (think transfers, staking,\n * minting, burning, approvals, etc.)\n * This can be used to notify your app with real time changes whenever an\n * EOA or a smart contract performs any action on-chain.\n */\nexport interface CustomGraphqlWebhook extends Webhook {\n  type: WebhookType.GRAPHQL;\n}\n\n/** The response for a {@link NotifyNamespace.getAllWebhooks} method. */\nexport interface GetAllWebhooksResponse {\n  /** All webhooks attached to the provided auth token. */\n  webhooks: Webhook[];\n  /** The total number of webhooks. */\n  totalCount: number;\n}\n\n/** Options object for the {@link NotifyNamespace.getAddresses} method. */\nexport interface GetAddressesOptions {\n  /** Number of addresses to fetch. */\n  limit?: number;\n\n  /** Page */\n  pageKey?: string;\n}\n\n/** Response object for the {@link NotifyNamespace.getAddresses} method. */\nexport interface AddressActivityResponse {\n  /** The addresses for the webhook. */\n  addresses: string[];\n  /** The total number of addresses. */\n  totalCount: number;\n  /** Optional page key used to fetch the remaining addresses. */\n  pageKey?: string;\n}\n\n/** Response object for the {@link NotifyNamespace.getGraphqlQuery} method. */\nexport interface CustomGraphqlWebhookConfig {\n  /** The graphql query for the webhook. */\n  graphqlQuery: string;\n}\n\n/**\n * Params to pass in when calling {@link NotifyNamespace.createWebhook} in order\n * to create a {@link MinedTransactionWebhook} or {@link DroppedTransactionWebhook}.\n *\n * The webhook will be created on the app and network associated with the appId.\n * To find the app id of a project, go to the Alchemy Dashboard in the Apps tab.\n * After clicking on an app, the app id is the string in the URL following 'apps/'.\n *\n * This is a temporary workaround for now. We're planning on detecting the app\n * id from the provided api key directly. Stay tuned!\n */\nexport interface TransactionWebhookParams {\n  /** The app id of the project to create the webhook on. */\n  appId: string;\n}\n\n/**\n * Params to pass in when calling {@link NotifyNamespace.createWebhook} in order\n * to create a {@link NftActivityWebhook} or {@link NftMetadataUpdateWebhook}.\n */\nexport interface NftWebhookParams {\n  /** Array of NFT filters the webhook should track. */\n  filters: NftFilter[];\n  /**\n   * Optional network to create the webhook on. If omitted, the webhook will be\n   * created on network of the app provided in the api key config.\n   */\n  network?: Network;\n}\n\n/**\n * Params to pass in when calling {@link NotifyNamespace.createWebhook} in order\n * to create a {@link CustomGraphqlWebhook}\n */\nexport interface CustomGraphqlWebhookParams {\n  /** GraphQL query */\n  graphqlQuery: string;\n  /**\n   * Optional network to create the webhook on. If omitted, the webhook will be\n   * created on network of the app provided in the api key config.\n   */\n  network?: Network;\n}\n\n/**\n * Params to pass in when calling {@link NotifyNamespace.createWebhook} in order\n * to create a {@link AddressActivityWebhook}.\n */\nexport interface AddressWebhookParams {\n  /** Array of addresses the webhook should activity for. */\n  addresses: string[];\n  /**\n   * Optional network to create the webhook on. If omitted, the webhook will be\n   * created on network of the app provided in the api key config.\n   */\n  network?: Network;\n}\n\n/** NFT to track on a {@link NftActivityWebhook} or {@link NftMetadataUpdateWebhook}. */\nexport interface NftFilter {\n  /** The contract address of the NFT. */\n  contractAddress: string;\n  /**\n   * The token id of the NFT to track. If this field is omitted, defaults to\n   * tracking all NFTs for the provided contract address.\n   */\n  tokenId?: BigNumberish;\n}\n\n/** Response object for the {@link NotifyNamespace.getNftFilters} method. */\nexport interface NftFiltersResponse {\n  /** The NFT filters on the provided webhook. */\n  filters: NftFilter[];\n  /** The total number of NFT filters on the webhook. */\n  totalCount: number;\n  /** Optional page key used to fetch the remaining filters. */\n  pageKey?: string;\n}\n\n/**\n * Params object when calling {@link NotifyNamespace.updateWebhook} to mark a\n * webhook as active or inactive.\n */\nexport interface WebhookStatusUpdate {\n  /** Whether the webhook is active. */\n  isActive: boolean;\n}\n\n/**\n * Params object when calling {@link NotifyNamespace.updateWebhook} to add and\n * remove NFT filters for a {@link NftActivityWebhook}.\n */\nexport interface WebhookNftFilterUpdate {\n  /** The filters to additionally track. */\n  addFilters: NftFilter[];\n  /** Existing filters to remove. */\n  removeFilters: NftFilter[];\n}\n\n/**\n * Params object when calling {@link NotifyNamespace.updateWebhook} to add and\n * remove NFT filters for a {@link NftMetadataUpdateWebhook}.\n */\nexport interface WebhookNftMetadataFilterUpdate {\n  /** The filters to additionally track. */\n  addMetadataFilters: NftFilter[];\n  /** Existing filters to remove. */\n  removeMetadataFilters: NftFilter[];\n}\n\n/**\n * Params object when calling {@link NotifyNamespace.updateWebhook} to add and\n * remove addresses for a {@link AddressActivityWebhook}.\n */\nexport interface WebhookAddressUpdate {\n  /** The addresses to additionally track. */\n  addAddresses: string[];\n  /** Existing addresses to remove. */\n  removeAddresses: string[];\n}\n\n/**\n * Params object when calling {@link NotifyNamespace.updateWebhook} to replace\n * all existing addresses for a {@link AddressActivityWebhook}.\n */\nexport interface WebhookAddressOverride {\n  /** The new addresses to track. Existing addresses will be removed. */\n  newAddresses: string[];\n}\n\n/**\n * Params object when calling {@link NotifyNamespace.updateWebhook} to update a\n * {@link NftActivityWebhook}.\n */\nexport type NftWebhookUpdate =\n  | WebhookStatusUpdate\n  | RequireAtLeastOne<WebhookNftFilterUpdate>;\n\n/**\n * Params object when calling {@link NotifyNamespace.updateWebhook} to update a\n * {@link NftMetadataUpdateWebhook}.\n */\nexport type NftMetadataWebhookUpdate =\n  | WebhookStatusUpdate\n  | RequireAtLeastOne<WebhookNftMetadataFilterUpdate>;\n\n/**\n * Params object when calling {@link NotifyNamespace.updateWebhook} to update a\n * {@link CustomGraphqlWebhook}.\n */\nexport type CustomGraphqlWebhookUpdate = WebhookStatusUpdate;\n\n/**\n * Params object when calling {@link NotifyNamespace.updateWebhook} to update a\n * {@link AddressActivityWebhook}.\n */\nexport type AddressWebhookUpdate =\n  | WebhookStatusUpdate\n  | RequireAtLeastOne<WebhookAddressUpdate>\n  | WebhookAddressOverride;\n\n/**\n * Transaction object used in {@link DebugNamespace.traceCall}, {@link TransactNamespace.simulateAssetChanges} and {@link TransactNamespace.simulateExecution}.\n */\nexport interface DebugTransaction {\n  /** The address the transaction is directed to. */\n  to?: string;\n  /** The address the transaction is sent from. */\n  from?: string;\n  /** The gas provided for the transaction execution, as a hex string. */\n  gas?: string;\n  /** The gas price to use as a hex string. */\n  gasPrice?: string;\n  /** The value associated with the transaction as a hex string. */\n  value?: string;\n  /** The data associated with the transaction. */\n  data?: string;\n}\n\n/**\n * Commitment level of the target block with using methods in the\n * {@link DebugNamespace}\n */\nexport enum CommitmentLevel {\n  /**\n   * Sample next block inferred by Alchemy built on top of the latest block.\n   * This contains the set of transactions taken from the local mempool and\n   * is a proxy for blocks that have not been mined yet.\n   */\n  PENDING = 'pending',\n  /**\n   * The most recent block in the canonical chain observed by Alchemy. Note that\n   * this block may be re-orged out of the canonical chain.\n   */\n  LATEST = 'latest',\n  /**\n   * The most recent crypto-economically secure block that cannot be re-orged\n   * outside of manual intervention driven by community coordination. This is\n   * only available on {@link Network.ETH_GOERLI} and {@link Network.ETH_SEPOLIA}.\n   */\n  SAFE = 'safe',\n  /**\n   * The most recent secure block that has been accepted by >2/3 of validators.\n   * This block is very unlikely to be re-orged. This is only available on\n   * {@link Network.ETH_GOERLI} and {@link Network.ETH_SEPOLIA}.\n   */\n  FINALIZED = 'finalized',\n  /**\n   * The lowest numbered block available that is usually the first block created.\n   */\n  EARLIEST = 'earliest'\n}\n\n/**\n * The block identifier to specify which block to run a debug call in, used for\n * methods in the {@link DebugNamespace}.\n */\nexport type BlockIdentifier = string | CommitmentLevel;\n\n/**\n * The type of tracer to use when running debug methods in the\n * {@link DebugNamespace}.\n */\nexport enum DebugTracerType {\n  CALL_TRACER = 'callTracer',\n  PRESTATE_TRACER = 'prestateTracer'\n}\n\n/**\n * Tracer used with debug methods in the {@link DebugNamespace}.\n *\n * This tracer tracks all call frames executed during a transaction, including\n * depth 0. The returned result {@link DebugCallTrace} is a nested list of call\n * frames executed as part of the call.\n *\n * Here are some things to note when using the call tracer:\n * - Calls to precompiles are also included in the result.\n * - In case a frame reverts, the field output will contain the raw return data.\n * - In case the top level frame reverts, its `revertReason` field will contain\n *   the parsed reason of revert as returned by the Solidity contract\n */\nexport interface DebugCallTracer {\n  /** Specified type is `CALL_TRACER`. */\n  type: DebugTracerType.CALL_TRACER;\n  /**\n   * Whether to only trace the main (top-level) calls and ignore sub-calls.\n   * Defaults to `false`.\n   */\n  onlyTopCall?: boolean;\n}\n\n/**\n * Tracer used with debug methods in the {@link DebugNamespace}.\n *\n * This tracer replays the transaction and tracks every part of state that was\n * touched during the transaction.\n *\n * Returns a {@link DebugPrestateTrace}. This contains sufficient information to\n * create a local execution of the transaction from a custom assembled genesis\n * block.\n */\nexport interface DebugPrestateTracer {\n  /** Specified type is `PRESTATE_TRACER`. */\n  type: DebugTracerType.PRESTATE_TRACER;\n  /**\n   * Whether to only trace the main (top-level) calls and ignore sub-calls.\n   * Defaults to `false`.\n   */\n  onlyTopCall?: boolean;\n}\n\n/**\n * Debug result returned when using a {@link DebugCallTracer}.\n */\nexport interface DebugCallTrace {\n  /** The type of call: `CALL` or `CREATE` for the top-level call. */\n  type: string;\n  /** From address of the transaction. */\n  from: string;\n  /** To address of the transaction. */\n  to: string;\n  /** Amount of value transfer as a hex string. */\n  value: string;\n  /** Gas provided for call as a hex string. */\n  gas: string;\n  /** Gas used during the call as a hex string. */\n  gasUsed: string;\n  /** Call data. */\n  input: string;\n  /** Return data. */\n  output: string;\n  /** Optional error field. */\n  error?: string;\n  /** Solidity revert reason, if the call reverted. */\n  revertReason?: string;\n  /** Array of sub-calls executed as part of the original call. */\n  calls?: DebugCallTrace[];\n}\n\n/**\n * Filter object used to filter logs by a specific block hash when using\n * {@link CoreNamespace.getLogs}.\n */\nexport interface FilterByBlockHash extends EventFilter {\n  /** The specific block hash to search for logs matching the filter. */\n  blockHash?: string;\n}\n\n/**\n * Filter object used to filter logs by block number range when using\n * {@link CoreNamespace.getLogs}\n */\nexport interface Filter extends EventFilter {\n  /** The starting block (inclusive) to search for logs matching the filter. */\n  fromBlock?: BlockTag;\n  /** The end block (inclusive) to search for logs matching the filter.*/\n  toBlock?: BlockTag;\n}\n\n/**\n * Filter object used to filter logs by when using {@link CoreNamespace.getLogs}\n */\nexport interface EventFilter {\n  /** The address to filter by. If omitted, filters for all addresses. */\n  address?: string | string[];\n  /** The topics to filter by, or null to match any topics. */\n  topics?: Array<string | Array<string> | null>;\n}\n\n/**\n * Debug result returned by a {@link DebugPrestateTracer}.\n *\n * The keys are the addresses of the accounts, mapped to its corresponding state.\n */\nexport type DebugPrestateTrace = Record<string, DebugPrestate>;\n\n/** The */\nexport interface DebugPrestate {\n  /** Balance of the account in wei as a hex string. */\n  balance: string;\n  /** Nonce */\n  nonce: number;\n  /** Hex-encoded bytecode. */\n  code: string;\n  /** Storage slots of the contract. */\n  storage: Record<string, string>;\n}\n\n/**\n * Requires at least one of the properties to be set.\n *\n * Implementation copied over from\n * {@link https://learn.microsoft.com/en-us/javascript/api/@azure/keyvault-certificates/requireatleastone?view=azure-node-latest}\n */\nexport type RequireAtLeastOne<T> = {\n  [K in keyof T]-?: Required<Pick<T, K>> &\n    Partial<Pick<T, Exclude<keyof T, K>>>;\n}[keyof T];\n\n/** Requires an array with at least one value. */\nexport type NonEmptyArray<T> = [T, ...T[]];\n","import { Network as NetworkFromEthers } from '@ethersproject/networks';\n\nimport { Network } from '../types/types';\n\nexport const DEFAULT_ALCHEMY_API_KEY = 'demo';\nexport const DEFAULT_NETWORK = Network.ETH_MAINNET;\nexport const DEFAULT_MAX_RETRIES = 5;\nexport const DEFAULT_REQUEST_TIMEOUT = 0; // 0 = no timeout\n\n/**\n * Returns the base URL for making Alchemy API requests. The `alchemy.com`\n * endpoints only work with non eth json-rpc requests.\n *\n * @internal\n */\nexport function getAlchemyHttpUrl(network: Network, apiKey: string): string {\n  return `https://${network}.g.alchemy.com/v2/${apiKey}`;\n}\n\nexport function getAlchemyNftHttpUrl(network: Network, apiKey: string): string {\n  return `https://${network}.g.alchemy.com/nft/v2/${apiKey}`;\n}\n\nexport function getAlchemyWsUrl(network: Network, apiKey: string): string {\n  return `wss://${network}.g.alchemy.com/v2/${apiKey}`;\n}\n\nexport function getAlchemyWebhookHttpUrl(): string {\n  return 'https://dashboard.alchemy.com/api';\n}\n\nexport enum AlchemyApiType {\n  BASE,\n  NFT,\n  WEBHOOK\n}\n\n/**\n * Mapping of network names to their corresponding Network strings used to\n * create an Ethers.js Provider instance.\n */\nexport const EthersNetwork = {\n  [Network.ETH_MAINNET]: 'mainnet',\n  [Network.ETH_ROPSTEN]: 'ropsten',\n  [Network.ETH_GOERLI]: 'goerli',\n  [Network.ETH_KOVAN]: 'kovan',\n  [Network.ETH_RINKEBY]: 'rinkeby',\n  [Network.ETH_SEPOLIA]: 'sepolia',\n  [Network.OPT_MAINNET]: 'optimism',\n  [Network.OPT_KOVAN]: 'optimism-kovan',\n  [Network.OPT_GOERLI]: 'optimism-goerli',\n  [Network.ARB_MAINNET]: 'arbitrum',\n  [Network.ARB_RINKEBY]: 'arbitrum-rinkeby',\n  [Network.ARB_GOERLI]: 'arbitrum-goerli',\n  [Network.MATIC_MAINNET]: 'matic',\n  [Network.MATIC_MUMBAI]: 'maticmum',\n  [Network.ASTAR_MAINNET]: 'astar-mainnet',\n  [Network.POLYGONZKEVM_MAINNET]: 'polygonzkevm-mainnet',\n  [Network.POLYGONZKEVM_TESTNET]: 'polygonzkevm-testnet',\n  [Network.BASE_MAINNET]: 'base-mainnet',\n  [Network.BASE_GOERLI]: 'base-goerli'\n};\n\n/**\n * Mapping of network names to their corresponding Ethers Network objects. These\n * networks are not yet supported by Ethers and are listed here to be overriden\n * in the provider.\n */\nexport const CustomNetworks: { [key: string]: NetworkFromEthers } = {\n  'arbitrum-goerli': {\n    chainId: 421613,\n    name: 'arbitrum-goerli'\n  },\n  'astar-mainnet': {\n    chainId: 592,\n    name: 'astar-mainnet'\n  },\n  sepolia: {\n    chainId: 11155111,\n    name: 'sepolia'\n  },\n  'polygonzkevm-mainnet': {\n    chainId: 1101,\n    name: 'polygonzkevm-mainnet'\n  },\n  'polygonzkevm-testnet': {\n    chainId: 1442,\n    name: 'polygonzkevm-testnet'\n  },\n  'base-mainnet': {\n    chainId: 8453,\n    name: 'base-mainnet'\n  },\n  'base-goerli': {\n    chainId: 84531,\n    name: 'base-goerli'\n  }\n};\n\nexport function noop(): void {\n  // It's a no-op\n}\n\nexport const ETH_NULL_VALUE = '0x';\n\nexport const ETH_NULL_ADDRESS = '0x0000000000000000000000000000000000000000';\n","import { AlchemySettings, Network } from '../types/types';\nimport {\n  AlchemyApiType,\n  DEFAULT_ALCHEMY_API_KEY,\n  DEFAULT_MAX_RETRIES,\n  DEFAULT_NETWORK,\n  DEFAULT_REQUEST_TIMEOUT,\n  getAlchemyHttpUrl,\n  getAlchemyNftHttpUrl,\n  getAlchemyWebhookHttpUrl\n} from '../util/const';\nimport type { AlchemyProvider } from './alchemy-provider';\nimport type { AlchemyWebSocketProvider } from './alchemy-websocket-provider';\n\n/**\n * This class holds the config information for the SDK client instance and\n * exposes the underlying providers for more advanced use cases.\n *\n * @public\n */\nexport class AlchemyConfig {\n  /** The Alchemy API key. */\n  readonly apiKey: string;\n\n  /** The Network that this SDK is associated with. */\n  readonly network: Network;\n\n  /** The maximum number of retries to perform. */\n  readonly maxRetries: number;\n\n  /** Setting to enable automatic batching on json-rpc requests. Defaults to false.*/\n  readonly batchRequests: boolean;\n\n  /**\n   * The optional hardcoded URL to send requests to instead of using the network\n   * and apiKey.\n   */\n  readonly url?: string;\n\n  /** The optional Alchemy auth token to use when sending requests with the Notify API. */\n  readonly authToken?: string;\n\n  /**\n   * The optional Request timeout provided in `ms` for NFT and NOTIFY API. Defaults to 0.\n   */\n  readonly requestTimeout?: number;\n\n  /**\n   * Dynamically imported provider instance.\n   *\n   * @internal\n   */\n  private _baseAlchemyProvider: Promise<AlchemyProvider> | undefined;\n\n  /**\n   * Dynamically imported provider instance.\n   *\n   * @internal\n   */\n  private _baseAlchemyWssProvider:\n    | Promise<AlchemyWebSocketProvider>\n    | undefined;\n\n  constructor(config?: AlchemySettings) {\n    this.apiKey = config?.apiKey || DEFAULT_ALCHEMY_API_KEY;\n    this.network = config?.network || DEFAULT_NETWORK;\n    this.maxRetries = config?.maxRetries || DEFAULT_MAX_RETRIES;\n    this.url = config?.url;\n    this.authToken = config?.authToken;\n    this.batchRequests = config?.batchRequests || false;\n    this.requestTimeout = config?.requestTimeout || DEFAULT_REQUEST_TIMEOUT;\n  }\n\n  /**\n   * Returns the URL endpoint to send the HTTP request to. If a custom URL was\n   * provided in the config, that URL is returned. Otherwise, the default URL is\n   * from the network and API key.\n   *\n   * @param apiType - The type of API to get the URL for.\n   * @internal\n   */\n  _getRequestUrl(apiType: AlchemyApiType): string {\n    if (this.url !== undefined) {\n      return this.url;\n    } else if (apiType === AlchemyApiType.NFT) {\n      return getAlchemyNftHttpUrl(this.network, this.apiKey);\n    } else if (apiType === AlchemyApiType.WEBHOOK) {\n      return getAlchemyWebhookHttpUrl();\n    } else {\n      return getAlchemyHttpUrl(this.network, this.apiKey);\n    }\n  }\n\n  /**\n   * Returns an AlchemyProvider instance. Only one provider is created per\n   * Alchemy instance.\n   *\n   * The AlchemyProvider is a wrapper around ether's `AlchemyProvider` class and\n   * has been expanded to support Alchemy's Enhanced APIs.\n   *\n   * Most common methods on the provider are available as top-level methods on\n   * the {@link Alchemy} instance, but the provider is exposed here to access\n   * other less-common methods.\n   *\n   * @public\n   */\n  getProvider(): Promise<AlchemyProvider> {\n    if (!this._baseAlchemyProvider) {\n      this._baseAlchemyProvider = (async () => {\n        const { AlchemyProvider } = await import('./alchemy-provider');\n        return new AlchemyProvider(this);\n      })();\n    }\n    return this._baseAlchemyProvider;\n  }\n\n  /**\n   * Returns an AlchemyWebsocketProvider instance. Only one provider is created\n   * per Alchemy instance.\n   *\n   * The AlchemyWebSocketProvider is a wrapper around ether's\n   * `AlchemyWebSocketProvider` class and has been expanded to support Alchemy's\n   * Subscription APIs, automatic backfilling, and other performance improvements.\n   *\n   * Most common methods on the provider are available as top-level methods on\n   * the {@link Alchemy} instance, but the provider is exposed here to access\n   * other less-common methods.\n   */\n  getWebSocketProvider(): Promise<AlchemyWebSocketProvider> {\n    if (!this._baseAlchemyWssProvider) {\n      this._baseAlchemyWssProvider = (async () => {\n        const { AlchemyWebSocketProvider } = await import(\n          './alchemy-websocket-provider'\n        );\n        return new AlchemyWebSocketProvider(this);\n      })();\n    }\n    return this._baseAlchemyWssProvider;\n  }\n}\n","export const version = \"logger/5.7.0\";\n//# sourceMappingURL=_version.js.map","\"use strict\";\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\nconst LogLevels = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\nimport { version } from \"./_version\";\nlet _globalLogger = null;\nfunction _checkNormalize() {\n    try {\n        const missing = [];\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                }\n                ;\n            }\n            catch (error) {\n                missing.push(form);\n            }\n        });\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\");\n        }\n    }\n    catch (error) {\n        return error.message;\n    }\n    return null;\n}\nconst _normalizeError = _checkNormalize();\nexport var LogLevel;\n(function (LogLevel) {\n    LogLevel[\"DEBUG\"] = \"DEBUG\";\n    LogLevel[\"INFO\"] = \"INFO\";\n    LogLevel[\"WARNING\"] = \"WARNING\";\n    LogLevel[\"ERROR\"] = \"ERROR\";\n    LogLevel[\"OFF\"] = \"OFF\";\n})(LogLevel || (LogLevel = {}));\nexport var ErrorCode;\n(function (ErrorCode) {\n    ///////////////////\n    // Generic Errors\n    // Unknown Error\n    ErrorCode[\"UNKNOWN_ERROR\"] = \"UNKNOWN_ERROR\";\n    // Not Implemented\n    ErrorCode[\"NOT_IMPLEMENTED\"] = \"NOT_IMPLEMENTED\";\n    // Unsupported Operation\n    //   - operation\n    ErrorCode[\"UNSUPPORTED_OPERATION\"] = \"UNSUPPORTED_OPERATION\";\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    ErrorCode[\"NETWORK_ERROR\"] = \"NETWORK_ERROR\";\n    // Some sort of bad response from the server\n    ErrorCode[\"SERVER_ERROR\"] = \"SERVER_ERROR\";\n    // Timeout\n    ErrorCode[\"TIMEOUT\"] = \"TIMEOUT\";\n    ///////////////////\n    // Operational  Errors\n    // Buffer Overrun\n    ErrorCode[\"BUFFER_OVERRUN\"] = \"BUFFER_OVERRUN\";\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    ErrorCode[\"NUMERIC_FAULT\"] = \"NUMERIC_FAULT\";\n    ///////////////////\n    // Argument Errors\n    // Missing new operator to an object\n    //  - name: The name of the class\n    ErrorCode[\"MISSING_NEW\"] = \"MISSING_NEW\";\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    ErrorCode[\"INVALID_ARGUMENT\"] = \"INVALID_ARGUMENT\";\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"MISSING_ARGUMENT\"] = \"MISSING_ARGUMENT\";\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"UNEXPECTED_ARGUMENT\"] = \"UNEXPECTED_ARGUMENT\";\n    ///////////////////\n    // Blockchain Errors\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    ErrorCode[\"CALL_EXCEPTION\"] = \"CALL_EXCEPTION\";\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    ErrorCode[\"INSUFFICIENT_FUNDS\"] = \"INSUFFICIENT_FUNDS\";\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    ErrorCode[\"NONCE_EXPIRED\"] = \"NONCE_EXPIRED\";\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    ErrorCode[\"REPLACEMENT_UNDERPRICED\"] = \"REPLACEMENT_UNDERPRICED\";\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    ErrorCode[\"UNPREDICTABLE_GAS_LIMIT\"] = \"UNPREDICTABLE_GAS_LIMIT\";\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    ErrorCode[\"TRANSACTION_REPLACED\"] = \"TRANSACTION_REPLACED\";\n    ///////////////////\n    // Interaction Errors\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ErrorCode[\"ACTION_REJECTED\"] = \"ACTION_REJECTED\";\n})(ErrorCode || (ErrorCode = {}));\n;\nconst HEX = \"0123456789abcdef\";\nexport class Logger {\n    constructor(version) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n    _log(logLevel, args) {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) {\n            return;\n        }\n        console.log.apply(console, args);\n    }\n    debug(...args) {\n        this._log(Logger.levels.DEBUG, args);\n    }\n    info(...args) {\n        this._log(Logger.levels.INFO, args);\n    }\n    warn(...args) {\n        this._log(Logger.levels.WARNING, args);\n    }\n    makeError(message, code, params) {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, {});\n        }\n        if (!code) {\n            code = Logger.errors.UNKNOWN_ERROR;\n        }\n        if (!params) {\n            params = {};\n        }\n        const messageDetails = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                        hex += HEX[value[i] >> 4];\n                        hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                }\n                else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            }\n            catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${code}`);\n        messageDetails.push(`version=${this.version}`);\n        const reason = message;\n        let url = \"\";\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n                switch (fault) {\n                    case \"overflow\":\n                    case \"underflow\":\n                    case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\":\n                    case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n        // @TODO: Any??\n        const error = new Error(message);\n        error.reason = reason;\n        error.code = code;\n        Object.keys(params).forEach(function (key) {\n            error[key] = params[key];\n        });\n        return error;\n    }\n    throwError(message, code, params) {\n        throw this.makeError(message, code, params);\n    }\n    throwArgumentError(message, name, value) {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n    assert(condition, message, code, params) {\n        if (!!condition) {\n            return;\n        }\n        this.throwError(message, code, params);\n    }\n    assertArgument(condition, message, name, value) {\n        if (!!condition) {\n            return;\n        }\n        this.throwArgumentError(message, name, value);\n    }\n    checkNormalize(message) {\n        if (message == null) {\n            message = \"platform missing String.prototype.normalize\";\n        }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n    checkSafeUint53(value, message) {\n        if (typeof (value) !== \"number\") {\n            return;\n        }\n        if (message == null) {\n            message = \"value not safe\";\n        }\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n    checkArgumentCount(count, expectedCount, message) {\n        if (message) {\n            message = \": \" + message;\n        }\n        else {\n            message = \"\";\n        }\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n    checkNew(target, kind) {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n    checkAbstract(target, kind) {\n        if (target === kind) {\n            this.throwError(\"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: \"new\" });\n        }\n        else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n    static globalLogger() {\n        if (!_globalLogger) {\n            _globalLogger = new Logger(version);\n        }\n        return _globalLogger;\n    }\n    static setCensorship(censorship, permanent) {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        if (_permanentCensorErrors) {\n            if (!censorship) {\n                return;\n            }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n    static setLogLevel(logLevel) {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n    static from(version) {\n        return new Logger(version);\n    }\n}\nLogger.errors = ErrorCode;\nLogger.levels = LogLevel;\n//# sourceMappingURL=index.js.map","export const version = \"properties/5.7.0\";\n//# sourceMappingURL=_version.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport function defineReadOnly(object, name, value) {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n// Crawl up the constructor chain to find a static method\nexport function getStatic(ctor, key) {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) {\n            return ctor[key];\n        }\n        if (!ctor.prototype || typeof (ctor.prototype) !== \"object\") {\n            break;\n        }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\nexport function resolveProperties(object) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const promises = Object.keys(object).map((key) => {\n            const value = object[key];\n            return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n        });\n        const results = yield Promise.all(promises);\n        return results.reduce((accum, result) => {\n            accum[(result.key)] = result.value;\n            return accum;\n        }, {});\n    });\n}\nexport function checkProperties(object, properties) {\n    if (!object || typeof (object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\nexport function shallowCopy(object) {\n    const result = {};\n    for (const key in object) {\n        result[key] = object[key];\n    }\n    return result;\n}\nconst opaque = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\nfunction _isFrozen(object) {\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof (object)]) {\n        return true;\n    }\n    if (Array.isArray(object) || typeof (object) === \"object\") {\n        if (!Object.isFrozen(object)) {\n            return false;\n        }\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value = null;\n            try {\n                value = object[keys[i]];\n            }\n            catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n            if (!_isFrozen(value)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return logger.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, \"object\", object);\n}\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object) {\n    if (_isFrozen(object)) {\n        return object;\n    }\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n    if (typeof (object) === \"object\") {\n        const result = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) {\n                continue;\n            }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n        return result;\n    }\n    return logger.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, \"object\", object);\n}\nexport function deepCopy(object) {\n    return _deepCopy(object);\n}\nexport class Description {\n    constructor(info) {\n        for (const key in info) {\n            this[key] = deepCopy(info[key]);\n        }\n    }\n}\n//# sourceMappingURL=index.js.map","import { BigNumber } from '@ethersproject/bignumber';\n\n/**\n * Converts a hex string to a decimal number.\n *\n * @param hexString - The hex string to convert.\n * @public\n */\nexport function fromHex(hexString: string): number {\n  return BigNumber.from(hexString).toNumber();\n}\n\n/**\n * Converts a number to a hex string.\n *\n * @param num - The number to convert to hex.\n * @public\n */\nexport function toHex(num: number): string {\n  return BigNumber.from(num).toHexString();\n}\n\n/**\n * Checks if a value is a hex string.\n *\n * @param possibleHexString - The value to check.\n * @public\n */\nexport function isHex(possibleHexString: string): boolean {\n  return /^0x[0-9a-fA-F]+$/.test(possibleHexString);\n}\n","import { BigNumber } from '@ethersproject/bignumber';\n\nimport { BaseNft, Nft, NftContract } from '../api/nft';\nimport { toHex } from '../api/util';\nimport {\n  RawBaseNft,\n  RawContractBaseNft,\n  RawGetContractsForOwnerResponse,\n  RawGetNftSalesResponse,\n  RawNft,\n  RawNftAttributeRarity,\n  RawNftContract,\n  RawOpenSeaCollectionMetadata,\n  RawSpamInfo\n} from '../internal/raw-interfaces';\nimport {\n  GetContractsForOwnerResponse,\n  GetNftSalesResponse,\n  NftAttributeRarity,\n  NftSaleMarketplace,\n  NftSaleTakerType,\n  NftTokenType,\n  OpenSeaCollectionMetadata,\n  OpenSeaSafelistRequestStatus,\n  SpamInfo,\n  TokenUri\n} from '../types/types';\n\nexport function formatBlock(block: string | number): string {\n  if (typeof block === 'string') {\n    return block;\n  } else if (Number.isInteger(block)) {\n    return toHex(block);\n  }\n  return block.toString();\n}\n\nfunction stringToEnum<T extends string>(\n  x: string,\n  enumb: Record<string, T>\n): T | undefined {\n  return Object.values(enumb).includes(x as T) ? (x as T) : undefined;\n}\n\nexport function getNftContractFromRaw(\n  rawNftContract: RawNftContract\n): NftContract {\n  return {\n    address: rawNftContract.address,\n    name: rawNftContract.contractMetadata.name,\n    symbol: rawNftContract.contractMetadata.symbol,\n    totalSupply: rawNftContract.contractMetadata.totalSupply,\n    tokenType: parseNftTokenType(rawNftContract.contractMetadata.tokenType),\n    openSea: parseOpenSeaMetadata(rawNftContract.contractMetadata.openSea),\n    contractDeployer: rawNftContract.contractMetadata.contractDeployer,\n    deployedBlockNumber: rawNftContract.contractMetadata.deployedBlockNumber\n  };\n}\n\nexport function getBaseNftFromRaw(rawBaseNft: RawBaseNft): BaseNft;\nexport function getBaseNftFromRaw(\n  rawContractBaseNft: RawContractBaseNft,\n  contractAddress: string\n): BaseNft;\nexport function getBaseNftFromRaw(\n  rawBaseNft: RawBaseNft | RawContractBaseNft,\n  contractAddress?: string\n): BaseNft {\n  return {\n    contract: contractAddress\n      ? { address: contractAddress }\n      : (rawBaseNft as RawBaseNft).contract,\n    tokenId: BigNumber.from(rawBaseNft.id.tokenId).toString(),\n    tokenType: parseNftTokenType(rawBaseNft.id.tokenMetadata?.tokenType)\n  };\n}\n\nexport function getNftFromRaw(rawNft: RawNft): Nft {\n  try {\n    const tokenType = parseNftTokenType(rawNft.id.tokenMetadata?.tokenType);\n    const spamInfo = parseSpamInfo(rawNft.spamInfo);\n\n    return {\n      contract: {\n        address: rawNft.contract.address,\n        name: rawNft.contractMetadata?.name,\n        symbol: rawNft.contractMetadata?.symbol,\n        totalSupply: rawNft.contractMetadata?.totalSupply,\n        tokenType,\n        openSea: parseOpenSeaMetadata(rawNft.contractMetadata?.openSea),\n        contractDeployer: rawNft.contractMetadata?.contractDeployer,\n        deployedBlockNumber: rawNft.contractMetadata?.deployedBlockNumber\n      },\n      tokenId: parseNftTokenId(rawNft.id.tokenId),\n      tokenType,\n      title: rawNft.title,\n      description: parseNftDescription(rawNft.description),\n      timeLastUpdated: rawNft.timeLastUpdated,\n      metadataError: rawNft.error,\n      rawMetadata: rawNft.metadata,\n      tokenUri: parseNftTokenUri(rawNft.tokenUri),\n      media: parseNftTokenUriArray(rawNft.media),\n      spamInfo,\n      acquiredAt: rawNft.acquiredAt\n    };\n  } catch (e) {\n    throw new Error('Error parsing the NFT response: ' + e);\n  }\n}\n\nexport function getNftSalesFromRaw(\n  rawNftSales: RawGetNftSalesResponse\n): GetNftSalesResponse {\n  return {\n    nftSales: rawNftSales.nftSales.map(rawNftSale => ({\n      marketplace: parseNftSaleMarketplace(rawNftSale.marketplace),\n      contractAddress: rawNftSale.contractAddress,\n      tokenId: rawNftSale.tokenId,\n      quantity: rawNftSale.quantity,\n      buyerAddress: rawNftSale.buyerAddress,\n      sellerAddress: rawNftSale.sellerAddress,\n      taker: parseNftTaker(rawNftSale.taker),\n      sellerFee: rawNftSale?.sellerFee,\n      marketplaceFee: rawNftSale?.protocolFee,\n      protocolFee: rawNftSale?.protocolFee,\n      royaltyFee: rawNftSale?.royaltyFee,\n      blockNumber: rawNftSale?.blockNumber,\n      logIndex: rawNftSale.logIndex,\n      bundleIndex: rawNftSale.bundleIndex,\n      transactionHash: rawNftSale.transactionHash\n    })),\n    validAt: {\n      blockNumber: rawNftSales.validAt.blockNumber,\n      blockHash: rawNftSales.validAt.blockHash ?? undefined,\n      blockTimestamp: rawNftSales.validAt.blockTimestamp ?? undefined\n    },\n    pageKey: rawNftSales?.pageKey\n  };\n}\n\nfunction parseNftSaleMarketplace(marketplace: string): NftSaleMarketplace {\n  switch (marketplace) {\n    case 'looksrare':\n      return NftSaleMarketplace.LOOKSRARE;\n    case 'seaport':\n      return NftSaleMarketplace.SEAPORT;\n    case 'x2y2':\n      return NftSaleMarketplace.X2Y2;\n    case 'wyvern':\n      return NftSaleMarketplace.WYVERN;\n    case 'cryptopunks':\n      return NftSaleMarketplace.CRYPTOPUNKS;\n    case 'blur':\n      return NftSaleMarketplace.BLUR;\n    default:\n      return NftSaleMarketplace.UNKNOWN;\n  }\n}\n\nfunction parseNftTaker(taker: string): NftSaleTakerType {\n  // The `.toLowerCase()` call is needed because the API returns the capitalized values\n  switch (taker.toLowerCase()) {\n    case 'buyer':\n      return NftSaleTakerType.BUYER;\n    case 'seller':\n      return NftSaleTakerType.SELLER;\n    default:\n      throw new Error(`Unsupported NftSaleTakerType ${taker}`);\n  }\n}\n\nexport function getNftRarityFromRaw(\n  rawNftRarity: RawNftAttributeRarity[]\n): NftAttributeRarity[] {\n  return rawNftRarity.map(({ prevalence, trait_type, value }) => ({\n    prevalence,\n    traitType: trait_type,\n    value\n  }));\n}\n\nexport function getContractsForOwnerFromRaw(\n  rawContractsForOwner: RawGetContractsForOwnerResponse\n): GetContractsForOwnerResponse {\n  return {\n    pageKey: rawContractsForOwner?.pageKey,\n    totalCount: rawContractsForOwner.totalCount,\n    contracts: rawContractsForOwner.contracts.map(contract => {\n      return {\n        address: contract.address,\n        totalSupply: contract.totalSupply,\n        isSpam: contract.isSpam,\n        media: contract.media,\n        numDistinctTokensOwned: contract.numDistinctTokensOwned,\n        tokenId: contract.tokenId,\n        totalBalance: contract.totalBalance,\n        name: contract.name,\n        title: contract.title,\n        openSea: parseOpenSeaMetadata(contract?.opensea),\n        symbol: contract?.symbol,\n        tokenType: parseNftTokenType(contract?.tokenType),\n        contractDeployer: contract.contractDeployer,\n        deployedBlockNumber: contract.deployedBlockNumber\n      };\n    })\n  };\n}\n\nfunction parseNftTokenId(tokenId: string): string {\n  // We have to normalize the token id here since the backend sometimes\n  // returns the token ID as a hex string and sometimes as an integer.\n  return BigNumber.from(tokenId).toString();\n}\n\nfunction parseNftTokenType(tokenType: string | undefined): NftTokenType {\n  switch (tokenType) {\n    case 'erc721':\n    case 'ERC721':\n      return NftTokenType.ERC721;\n    case 'erc1155':\n    case 'ERC1155':\n      return NftTokenType.ERC1155;\n    case 'no_supported_nft_standard':\n    case 'NO_SUPPORTED_NFT_STANDARD':\n      return NftTokenType.NO_SUPPORTED_NFT_STANDARD;\n    case 'not_a_contract':\n    case 'NOT_A_CONTRACT':\n      return NftTokenType.NOT_A_CONTRACT;\n    default:\n      return NftTokenType.UNKNOWN;\n  }\n}\n\nfunction parseSpamInfo(\n  spamInfo: RawSpamInfo | undefined\n): SpamInfo | undefined {\n  if (!spamInfo) {\n    return undefined;\n  }\n  const { isSpam, classifications } = spamInfo;\n  return {\n    isSpam: isSpam === 'true',\n    classifications\n  };\n}\n\nfunction parseNftDescription(description?: string | string[]): string {\n  if (description === undefined) {\n    return '';\n  }\n\n  // TODO: Remove after backend adds JSON stringification.\n  if (!Array.isArray(description) && typeof description === 'object') {\n    return JSON.stringify(description);\n  }\n\n  return typeof description === 'string' ? description : description.join(' ');\n}\n\nfunction parseNftTokenUri(uri: TokenUri | undefined): TokenUri | undefined {\n  if (uri && uri.raw.length === 0 && uri.gateway.length == 0) {\n    return undefined;\n  }\n  return uri;\n}\n\nfunction parseNftTokenUriArray(arr: TokenUri[] | undefined): TokenUri[] {\n  if (arr === undefined) {\n    return [];\n  }\n  return arr.filter(uri => parseNftTokenUri(uri) !== undefined);\n}\n\nexport function parseOpenSeaMetadata(\n  openSea: RawOpenSeaCollectionMetadata | undefined\n): OpenSeaCollectionMetadata | undefined {\n  if (openSea === undefined) {\n    return undefined;\n  }\n  return {\n    floorPrice: openSea.floorPrice,\n    collectionName: openSea.collectionName,\n    safelistRequestStatus:\n      openSea.safelistRequestStatus !== undefined\n        ? stringToEnum(\n            openSea.safelistRequestStatus,\n            OpenSeaSafelistRequestStatus\n          )\n        : undefined,\n    imageUrl: openSea.imageUrl,\n    description: openSea.description,\n    externalUrl: openSea.externalUrl,\n    twitterUsername: openSea.twitterUsername,\n    discordUrl: openSea.discordUrl,\n    lastIngestedAt: openSea.lastIngestedAt\n  };\n}\n\nexport const IS_BROWSER = typeof window !== 'undefined' && window !== null;\n\n/** Recursively converts all `null` fields to `undefined. */\n// TODO: Add typing support so it doesn't return `any`.\nexport function nullsToUndefined<T>(obj: T): any {\n  if (obj === null) {\n    return undefined as any;\n  }\n\n  // if `obj` is an object, recursively convert all `null` fields to `undefined`.\n  if (typeof obj === 'object') {\n    for (const key in obj) {\n      obj[key] = nullsToUndefined(obj[key]) as any;\n    }\n  }\n  return obj as any;\n}\n","import type { Log } from '@ethersproject/abstract-provider';\nimport { resolveProperties } from '@ethersproject/properties';\n\nimport { AlchemyConfig } from '../api/alchemy-config';\nimport { toHex } from '../api/util';\nimport {\n  AssetTransfersParams,\n  AssetTransfersResponse,\n  AssetTransfersWithMetadataParams,\n  AssetTransfersWithMetadataResponse,\n  Filter,\n  FilterByBlockHash,\n  TransactionReceiptsParams,\n  TransactionReceiptsResponse\n} from '../types/types';\nimport { formatBlock } from '../util/util';\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link CoreNamespace}. By moving the methods out into a separate file,\n * other namespaces can access these methods without depending on the entire\n * CoreNamespace, or override the `srcMethod` param used for logging.\n */\n\n/**\n * Gets the asset transfers for the provided params.\n */\nexport async function getAssetTransfers(\n  config: AlchemyConfig,\n  params: AssetTransfersWithMetadataParams | AssetTransfersParams,\n  srcMethod = 'getAssetTransfers'\n): Promise<AssetTransfersResponse | AssetTransfersWithMetadataResponse> {\n  const provider = await config.getProvider();\n  if (params.fromAddress) {\n    params.fromAddress = await provider._getAddress(params.fromAddress);\n  }\n  if (params.toAddress) {\n    params.toAddress = await provider._getAddress(params.toAddress);\n  }\n  return provider._send(\n    'alchemy_getAssetTransfers',\n    [\n      {\n        ...params,\n        fromBlock:\n          params.fromBlock != null ? formatBlock(params.fromBlock) : undefined,\n        toBlock:\n          params.toBlock != null ? formatBlock(params.toBlock) : undefined,\n        maxCount: params.maxCount != null ? toHex(params.maxCount) : undefined\n      }\n    ],\n    srcMethod\n  );\n}\n\nexport async function getTransactionReceipts(\n  config: AlchemyConfig,\n  params: TransactionReceiptsParams,\n  srcMethod = 'getTransactionReceipts'\n): Promise<TransactionReceiptsResponse> {\n  const provider = await config.getProvider();\n  return provider._send('alchemy_getTransactionReceipts', [params], srcMethod);\n}\n\n/**\n * This method is based on the ethers implementation of getLogs, but is expanded\n * to support specifying an address array in the filter.\n *\n * The main modifications made to support an address array are:\n * - Custom `getFilter()` method that supports an address array\n * - Use of `arrayOf()` formatter to format the logs to avoid the `Formatter` import.\n * - Use of `provider.send()` to avoid formatting logic in `provider.perform()`.\n */\nexport async function getLogs(\n  config: AlchemyConfig,\n  filter: Filter | FilterByBlockHash | Promise<Filter | FilterByBlockHash>\n): Promise<Array<Log>> {\n  const provider = await config.getProvider();\n  await provider.getNetwork();\n  const params = await resolveProperties({\n    filter: getFilter(config, filter)\n  });\n\n  const logs: Array<Log> = await provider.send('eth_getLogs', [params.filter]);\n  logs.forEach(log => {\n    if (log.removed == null) {\n      log.removed = false;\n    }\n  });\n  return arrayOf(provider.formatter.filterLog.bind(provider.formatter))(logs);\n}\n\n/**\n * This method is based on and copied from the ethers implementation of\n * `JsonRpcProvider._getFilter()`, but is extended to support an address array.\n *\n * This implementation is a hacky way to get around the ethers formatter. The\n * formatter is used to check the types of the `filter` params, but ethers does\n * not allow an array in the `address` field. To preserve the ethers formatter\n * on the other fields, we use the formatter to check the types of those other\n * fields, and then manually check the `address` field last.\n */\nasync function getFilter(\n  config: AlchemyConfig,\n  filter: Filter | FilterByBlockHash | Promise<Filter | FilterByBlockHash>\n): Promise<Filter | FilterByBlockHash> {\n  // START MODIFIED CODE\n  const provider = await config.getProvider();\n  const resolvedFilter = await filter;\n  let result: any = {};\n  // END MODIFIED CODE\n\n  ['blockHash', 'topics'].forEach(key => {\n    if ((resolvedFilter as any)[key] == null) {\n      return;\n    }\n    result[key] = (resolvedFilter as any)[key];\n  });\n\n  ['fromBlock', 'toBlock'].forEach(key => {\n    if ((resolvedFilter as any)[key] == null) {\n      return;\n    }\n    result[key] = provider._getBlockTag((resolvedFilter as any)[key]);\n  });\n\n  // BEGIN MODIFIED CODE\n  // Format the `result` object using the ethers formatter without the `address`\n  // field.\n  result = provider.formatter.filter(await resolveProperties(result));\n\n  // After formatting the other fields, manually format the `address` field\n  // before adding it to the `result` object.\n  if (Array.isArray(resolvedFilter.address)) {\n    result.address = await Promise.all(\n      resolvedFilter.address.map(async (address: string) =>\n        provider._getAddress(address)\n      )\n    );\n  } else if (resolvedFilter.address != null) {\n    result.address = await provider._getAddress(resolvedFilter.address);\n  }\n\n  return result;\n  // END MODIFIED CODE\n}\n\n/**\n * DO NOT MODIFY.\n *\n * This function is directly copied over from ethers implementation of\n * `Formatter.arrayOf()`. It is copied here to avoid having to import the\n * `Formatter` class or `FormatterFunc` type from ethers, that are not part of\n * the default export.\n *\n * This function returns a function that applies the formatter to an array of\n * values, and is used to format the logs returned by `getLogs()`.\n */\nfunction arrayOf(format: any): any {\n  return function (array: any): Array<any> {\n    if (!Array.isArray(array)) {\n      throw new Error('not an array');\n    }\n\n    const result: any = [];\n\n    array.forEach(value => {\n      result.push(format(value));\n    });\n\n    return result;\n  };\n}\n","import type {\n  Block,\n  BlockTag,\n  BlockWithTransactions,\n  FeeData,\n  Log,\n  TransactionReceipt,\n  TransactionRequest,\n  TransactionResponse\n} from '@ethersproject/abstract-provider';\nimport { BigNumber, BigNumberish } from '@ethersproject/bignumber';\nimport type { Network as EthersNetworkAlias } from '@ethersproject/networks/lib/types';\nimport type { Deferrable } from '@ethersproject/properties';\n\nimport {\n  getAssetTransfers,\n  getLogs,\n  getTransactionReceipts\n} from '../internal/core-api';\nimport {\n  AssetTransfersParams,\n  AssetTransfersResponse,\n  AssetTransfersWithMetadataParams,\n  AssetTransfersWithMetadataResponse,\n  DeployResult,\n  Filter,\n  FilterByBlockHash,\n  GetTokensForOwnerOptions,\n  GetTokensForOwnerResponse,\n  TokenBalanceType,\n  TokenBalancesOptionsDefaultTokens,\n  TokenBalancesOptionsErc20,\n  TokenBalancesResponse,\n  TokenBalancesResponseErc20,\n  TokenMetadataResponse,\n  TransactionReceiptsParams,\n  TransactionReceiptsResponse\n} from '../types/types';\nimport { ETH_NULL_VALUE } from '../util/const';\nimport { nullsToUndefined } from '../util/util';\nimport { AlchemyConfig } from './alchemy-config';\nimport { toHex } from './util';\nimport { formatUnits } from './utils';\n\n/**\n * The core namespace contains all commonly-used [Ethers.js\n * Provider](https://docs.ethers.io/v5/api/providers/api-providers/#AlchemyProvider)\n * methods. If you are already using Ethers.js, you should be simply able to\n * replace the Ethers.js Provider object with `alchemy.core` when accessing\n * provider methods and it should just work.\n *\n * Do not call this constructor directly. Instead, instantiate an Alchemy object\n * with `const alchemy = new Alchemy(config)` and then access the core namespace\n * via `alchemy.core`.\n */\nexport class CoreNamespace {\n  /** @internal */\n  constructor(private readonly config: AlchemyConfig) {}\n\n  /**\n   * Returns the balance of a given address as of the provided block.\n   *\n   * @param addressOrName The address or name of the account to get the balance for.\n   * @param blockTag The optional block number or hash to get the balance for.\n   *   Defaults to 'latest' if unspecified.\n   * @public\n   */\n  async getBalance(\n    addressOrName: string | Promise<string>,\n    blockTag?: BlockTag | Promise<BlockTag>\n  ): Promise<BigNumber> {\n    const provider = await this.config.getProvider();\n    return provider.getBalance(addressOrName, blockTag);\n  }\n\n  /**\n   * Checks if the provided address is a smart contract.\n   *\n   * @param address The address to check type for.\n   * @public\n   */\n  async isContractAddress(address: string): Promise<boolean> {\n    const provider = await this.config.getProvider();\n    const code = await provider.getCode(address);\n    return code !== '0x';\n  }\n\n  /**\n   * Returns the contract code of the provided address at the block. If there is\n   * no contract deployed, the result is `0x`.\n   *\n   * @param addressOrName The address or name of the account to get the code for.\n   * @param blockTag The optional block number or hash to get the code for.\n   *   Defaults to 'latest' if unspecified.\n   * @public\n   */\n  async getCode(\n    addressOrName: string | Promise<string>,\n    blockTag?: BlockTag | Promise<BlockTag>\n  ): Promise<string> {\n    const provider = await this.config.getProvider();\n    return provider.getCode(addressOrName, blockTag);\n  }\n\n  /**\n   * Return the value of the provided position at the provided address, at the\n   * provided block in `Bytes32` format.\n   *\n   * @param addressOrName The address or name of the account to get the code for.\n   * @param position The position of the storage slot to get.\n   * @param blockTag The optional block number or hash to get the code for.\n   *   Defaults to 'latest' if unspecified.\n   * @public\n   */\n  async getStorageAt(\n    addressOrName: string | Promise<string>,\n    position: BigNumberish | Promise<BigNumberish>,\n    blockTag?: BlockTag | Promise<BlockTag>\n  ): Promise<string> {\n    const provider = await this.config.getProvider();\n    return provider.getStorageAt(addressOrName, position, blockTag);\n  }\n\n  /**\n   * Returns the number of transactions ever sent from the provided address, as\n   * of the provided block tag. This value is used as the nonce for the next\n   * transaction from the address sent to the network.\n   *\n   * @param addressOrName The address or name of the account to get the nonce for.\n   * @param blockTag The optional block number or hash to get the nonce for.\n   * @public\n   */\n  async getTransactionCount(\n    addressOrName: string | Promise<string>,\n    blockTag?: BlockTag | Promise<BlockTag>\n  ): Promise<number> {\n    const provider = await this.config.getProvider();\n    return provider.getTransactionCount(addressOrName, blockTag);\n  }\n\n  /**\n   * Returns the block from the network based on the provided block number or\n   * hash. Transactions on the block are represented as an array of transaction\n   * hashes. To get the full transaction details on the block, use\n   * {@link getBlockWithTransactions} instead.\n   *\n   * @param blockHashOrBlockTag The block number or hash to get the block for.\n   * @public\n   */\n  async getBlock(\n    blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>\n  ): Promise<Block> {\n    const provider = await this.config.getProvider();\n    return provider.getBlock(blockHashOrBlockTag);\n  }\n\n  /**\n   * Returns the block from the network based on the provided block number or\n   * hash. Transactions on the block are represented as an array of\n   * {@link TransactionResponse} objects.\n   *\n   * @param blockHashOrBlockTag The block number or hash to get the block for.\n   * @public\n   */\n  async getBlockWithTransactions(\n    blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>\n  ): Promise<BlockWithTransactions> {\n    const provider = await this.config.getProvider();\n    return provider.getBlockWithTransactions(blockHashOrBlockTag);\n  }\n\n  /**\n   * Returns the {@link EthersNetworkAlias} Alchemy is connected to.\n   *\n   * @public\n   */\n  async getNetwork(): Promise<EthersNetworkAlias> {\n    const provider = await this.config.getProvider();\n    return provider.getNetwork();\n  }\n\n  /**\n   * Returns the block number of the most recently mined block.\n   *\n   * @public\n   */\n  async getBlockNumber(): Promise<number> {\n    const provider = await this.config.getProvider();\n    return provider.getBlockNumber();\n  }\n\n  /**\n   * Returns the best guess of the current gas price to use in a transaction.\n   *\n   * @public\n   */\n  async getGasPrice(): Promise<BigNumber> {\n    const provider = await this.config.getProvider();\n    return provider.getGasPrice();\n  }\n\n  /**\n   * Returns the recommended fee data to use in a transaction.\n   *\n   * For an EIP-1559 transaction, the maxFeePerGas and maxPriorityFeePerGas\n   * should be used.\n   *\n   * For legacy transactions and networks which do not support EIP-1559, the\n   * gasPrice should be used.\n   *\n   * @public\n   */\n  async getFeeData(): Promise<FeeData> {\n    const provider = await this.config.getProvider();\n    return provider.getFeeData();\n  }\n\n  /**\n   * Returns a Promise which will stall until the network has heen established,\n   * ignoring errors due to the target node not being active yet.\n   *\n   * This can be used for testing or attaching scripts to wait until the node is\n   * up and running smoothly.\n   *\n   * @public\n   */\n  async ready(): Promise<EthersNetworkAlias> {\n    const provider = await this.config.getProvider();\n    return provider.ready;\n  }\n\n  /**\n   * Returns the result of executing the transaction, using call. A call does\n   * not require any ether, but cannot change any state. This is useful for\n   * calling getters on Contracts.\n   *\n   * @param transaction The transaction to execute.\n   * @param blockTag The optional block number or hash to get the call for.\n   * @public\n   */\n  async call(\n    transaction: Deferrable<TransactionRequest>,\n    blockTag?: BlockTag | Promise<BlockTag>\n  ): Promise<string> {\n    const provider = await this.config.getProvider();\n    return provider.call(transaction, blockTag);\n  }\n\n  /**\n   * Returns an estimate of the amount of gas that would be required to submit\n   * transaction to the network.\n   *\n   * An estimate may not be accurate since there could be another transaction on\n   * the network that was not accounted for, but after being mined affects the\n   * relevant state.\n   *\n   * This is an alias for {@link TransactNamespace.estimateGas}.\n   *\n   * @param transaction The transaction to estimate gas for.\n   * @public\n   */\n  async estimateGas(\n    transaction: Deferrable<TransactionRequest>\n  ): Promise<BigNumber> {\n    const provider = await this.config.getProvider();\n    return provider.estimateGas(transaction);\n  }\n\n  /**\n   * Returns the transaction with hash or null if the transaction is unknown.\n   *\n   * If a transaction has not been mined, this method will search the\n   * transaction pool. Various backends may have more restrictive transaction\n   * pool access (e.g. if the gas price is too low or the transaction was only\n   * recently sent and not yet indexed) in which case this method may also return null.\n   *\n   * NOTE: This is an alias for {@link TransactNamespace.getTransaction}.\n   *\n   * @param transactionHash The hash of the transaction to get.\n   * @public\n   */\n  async getTransaction(\n    transactionHash: string | Promise<string>\n  ): Promise<TransactionResponse | null> {\n    const provider = await this.config.getProvider();\n    return provider.getTransaction(transactionHash);\n  }\n\n  /**\n   * Returns the transaction receipt for hash or null if the transaction has not\n   * been mined.\n   *\n   * To stall until the transaction has been mined, consider the\n   * waitForTransaction method below.\n   *\n   * @param transactionHash The hash of the transaction to get.\n   * @public\n   */\n  async getTransactionReceipt(\n    transactionHash: string | Promise<string>\n  ): Promise<TransactionReceipt | null> {\n    const provider = await this.config.getProvider();\n    return provider.getTransactionReceipt(transactionHash);\n  }\n\n  /**\n   * Submits transaction to the network to be mined. The transaction must be\n   * signed, and be valid (i.e. the nonce is correct and the account has\n   * sufficient balance to pay for the transaction).\n   *\n   * NOTE: This is an alias for {@link TransactNamespace.getTransaction}.\n   *\n   * @param signedTransaction The signed transaction to send.\n   * @public\n   */\n  async sendTransaction(\n    signedTransaction: string | Promise<string>\n  ): Promise<TransactionResponse> {\n    const provider = await this.config.getProvider();\n    return provider.sendTransaction(signedTransaction);\n  }\n\n  /**\n   * Returns a promise which will not resolve until specified transaction hash is mined.\n   *\n   * If {@link confirmations} is 0, this method is non-blocking and if the\n   * transaction has not been mined returns null. Otherwise, this method will\n   * block until the transaction has confirmed blocks mined on top of the block\n   * in which it was mined.\n   *\n   * NOTE: This is an alias for {@link TransactNamespace.getTransaction}.\n   *\n   * @param transactionHash The hash of the transaction to wait for.\n   * @param confirmations The number of blocks to wait for.\n   * @param timeout The maximum time to wait for the transaction to confirm.\n   * @public\n   */\n  async waitForTransaction(\n    transactionHash: string,\n    confirmations?: number,\n    timeout?: number\n  ): Promise<TransactionReceipt | null> {\n    const provider = await this.config.getProvider();\n    return provider.waitForTransaction(transactionHash, confirmations, timeout);\n  }\n\n  /**\n   * Returns an array of logs that match the provided filter.\n   *\n   * @param filter The filter object to use.\n   * @public\n   */\n  async getLogs(\n    filter: Filter | FilterByBlockHash | Promise<Filter | FilterByBlockHash>\n  ): Promise<Array<Log>> {\n    return getLogs(this.config, filter);\n  }\n\n  /**\n   * Allows sending a raw message to the Alchemy backend.\n   *\n   * @param method The method to call.\n   * @param params The parameters to pass to the method.\n   * @public\n   */\n  async send(method: string, params: Array<any>): Promise<any> {\n    const provider = await this.config.getProvider();\n    return provider.send(method, params);\n  }\n\n  /**\n   * Finds the address that deployed the provided contract and block number it\n   * was deployed in.\n   *\n   * NOTE: This method performs a binary search across all blocks since genesis\n   * and can take a long time to complete. This method is a convenience method\n   * that will eventually be replaced by a single call to an Alchemy endpoint\n   * with this information cached.\n   *\n   * @param contractAddress - The contract address to find the deployer for.\n   * @beta\n   */\n  async findContractDeployer(contractAddress: string): Promise<DeployResult> {\n    const provider = await this.config.getProvider();\n    const currentBlockNum = await provider.getBlockNumber();\n    if (\n      (await provider.getCode(contractAddress, currentBlockNum)) ===\n      ETH_NULL_VALUE\n    ) {\n      throw new Error(`Contract '${contractAddress}' does not exist`);\n    }\n\n    // Binary search for the block number that the contract was deployed in.\n    const firstBlock = await binarySearchFirstBlock(\n      0,\n      currentBlockNum + 1,\n      contractAddress,\n      this.config\n    );\n\n    // Find the first transaction in the block that matches the provided address.\n    const txReceipts = await getTransactionReceipts(\n      this.config,\n      {\n        blockNumber: toHex(firstBlock)\n      },\n      'findContractDeployer'\n    );\n    const matchingReceipt = txReceipts.receipts?.find(\n      receipt => receipt.contractAddress === contractAddress.toLowerCase()\n    );\n    return {\n      deployerAddress: matchingReceipt?.from,\n      blockNumber: firstBlock\n    };\n  }\n\n  /**\n   * Returns the ERC-20 token balances for a specific owner address.\n   *\n   * @param addressOrName The owner address to get the token balances for.\n   * @public\n   */\n  async getTokenBalances(\n    addressOrName: string\n  ): Promise<TokenBalancesResponseErc20>;\n\n  /**\n   * Returns the token balances for a specific owner address given a list of contracts.\n   *\n   * @param addressOrName The owner address to get the token balances for.\n   * @param contractAddresses A list of contract addresses to check. If omitted,\n   *   all ERC-20 tokens will be checked.\n   * @public\n   */\n  async getTokenBalances(\n    addressOrName: string,\n    contractAddresses?: string[]\n  ): Promise<TokenBalancesResponse>;\n\n  /**\n   * Returns the ERC-20 token balances for a specific owner.\n   *\n   * This overload covers the erc-20 token type which includes a page key in the response.\n   *\n   * @param addressOrName The owner address to get the token balances for.\n   * @param options Token type options set to ERC-20 with optional page key.\n   * @public\n   */\n  async getTokenBalances(\n    addressOrName: string,\n    options: TokenBalancesOptionsErc20\n  ): Promise<TokenBalancesResponseErc20>;\n\n  /**\n   * Returns the token balances for a specific owner, fetching from the top 100\n   * tokens by 24 hour volume.\n   *\n   * This overload covers the default token type which includes a page key in\n   * the response.\n   *\n   * @param addressOrName The owner address to get the token balances for.\n   * @param options Token type options set to ERC-20 with optional page key.\n   * @public\n   */\n  async getTokenBalances(\n    addressOrName: string,\n    options: TokenBalancesOptionsDefaultTokens\n  ): Promise<TokenBalancesResponse>;\n\n  async getTokenBalances(\n    addressOrName: string,\n    contractAddressesOrOptions?:\n      | string[]\n      | TokenBalancesOptionsDefaultTokens\n      | TokenBalancesOptionsErc20\n  ) {\n    const provider = await this.config.getProvider();\n    const address = await provider._getAddress(addressOrName);\n    if (Array.isArray(contractAddressesOrOptions)) {\n      if (contractAddressesOrOptions.length > 1500) {\n        throw new Error(\n          'You cannot pass in more than 1500 contract addresses to getTokenBalances()'\n        );\n      }\n      if (contractAddressesOrOptions.length === 0) {\n        throw new Error(\n          'getTokenBalances() requires at least one contractAddress when using an array'\n        );\n      }\n      return provider._send(\n        'alchemy_getTokenBalances',\n        [address, contractAddressesOrOptions],\n        'getTokenBalances'\n      );\n    } else {\n      const tokenType =\n        contractAddressesOrOptions === undefined\n          ? TokenBalanceType.ERC20\n          : contractAddressesOrOptions.type;\n      const params: Array<string | { pageKey: string }> = [address, tokenType];\n      if (\n        contractAddressesOrOptions?.type === TokenBalanceType.ERC20 &&\n        contractAddressesOrOptions.pageKey\n      ) {\n        params.push({ pageKey: contractAddressesOrOptions.pageKey });\n      }\n      return provider._send(\n        'alchemy_getTokenBalances',\n        params,\n        'getTokenBalances'\n      );\n    }\n  }\n\n  /**\n   * Returns the tokens that the specified address owns, along with the amount\n   * of each token and the relevant metadata.\n   *\n   * @param addressOrName The owner address to get the tokens with balances for.\n   * @param options Additional options to pass to the request.\n   * @public\n   */\n  async getTokensForOwner(\n    addressOrName: string,\n    options?: GetTokensForOwnerOptions\n  ): Promise<GetTokensForOwnerResponse> {\n    const provider = await this.config.getProvider();\n    const address = await provider._getAddress(addressOrName);\n    const params: any[] = [\n      address,\n      options?.contractAddresses ?? TokenBalanceType.ERC20\n    ];\n    if (options?.pageKey) {\n      params.push({ pageKey: options.pageKey });\n    }\n    const response = (await provider._send(\n      'alchemy_getTokenBalances',\n      params,\n      'getTokensForOwner'\n    )) as TokenBalancesResponseErc20;\n\n    const formattedBalances = response.tokenBalances.map(balance => ({\n      contractAddress: balance.contractAddress,\n      rawBalance: BigNumber.from(balance.tokenBalance!).toString()\n    }));\n\n    const metadataPromises = await Promise.allSettled(\n      response.tokenBalances.map(token =>\n        provider._send(\n          'alchemy_getTokenMetadata',\n          [token.contractAddress],\n          'getTokensForOwner',\n          /* forceBatch= */ true\n        )\n      )\n    );\n    const metadata: TokenMetadataResponse[] = metadataPromises.map(p =>\n      p.status === 'fulfilled'\n        ? p.value\n        : {\n            name: null,\n            symbol: null,\n            decimals: null,\n            logo: null\n          }\n    );\n    const ownedTokens = formattedBalances.map((balance, index) => ({\n      ...balance,\n      ...metadata[index],\n      balance:\n        metadata[index].decimals !== null\n          ? formatUnits(balance.rawBalance, metadata[index].decimals!)\n          : undefined\n    }));\n\n    return {\n      tokens: ownedTokens.map(nullsToUndefined),\n      pageKey: response.pageKey\n    };\n  }\n\n  /**\n   * Returns metadata for a given token contract address.\n   *\n   * @param address The contract address to get metadata for.\n   * @public\n   */\n  async getTokenMetadata(address: string): Promise<TokenMetadataResponse> {\n    const provider = await this.config.getProvider();\n    return provider._send(\n      'alchemy_getTokenMetadata',\n      [address],\n      'getTokenMetadata'\n    );\n  }\n\n  /**\n   * Get transactions for specific addresses. See the web documentation for the\n   * full details:\n   * https://docs.alchemy.com/alchemy/enhanced-apis/transfers-api#alchemy_getassettransfers\n   *\n   * This overload requires {@link AssetTransfersWithMetadataParams.withMetadata}\n   * to be set to `true`, which results in additional metadata returned in the\n   * response object.\n   *\n   * @param params An object containing fields for the asset transfer query\n   * @public\n   */\n  async getAssetTransfers(\n    params: AssetTransfersWithMetadataParams\n  ): Promise<AssetTransfersWithMetadataResponse>;\n\n  /**\n   * Get transactions for specific addresses. See the web documentation for the\n   * full details:\n   * https://docs.alchemy.com/alchemy/enhanced-apis/transfers-api#alchemy_getassettransfers\n   *\n   * @param params An object containing fields for the asset transfer query.\n   * @public\n   */\n  async getAssetTransfers(\n    params: AssetTransfersParams\n  ): Promise<AssetTransfersResponse>;\n  async getAssetTransfers(\n    params: AssetTransfersWithMetadataParams | AssetTransfersParams\n  ): Promise<AssetTransfersResponse | AssetTransfersWithMetadataResponse> {\n    return getAssetTransfers(this.config, params);\n  }\n\n  /**\n   * Gets all transaction receipts for a given block by number or block hash.\n   *\n   * @param params An object containing fields for the transaction receipt query.\n   * @public\n   */\n  async getTransactionReceipts(\n    params: TransactionReceiptsParams\n  ): Promise<TransactionReceiptsResponse> {\n    return getTransactionReceipts(this.config, params);\n  }\n\n  /**\n   * Returns the underlying owner address for the provided ENS address, or `null`\n   * if the ENS name does not have an underlying address.\n   *\n   * @param name The ENS address name to resolve.\n   */\n  async resolveName(name: string): Promise<string | null> {\n    const provider = await this.config.getProvider();\n    return provider.resolveName(name);\n  }\n\n  /**\n   * Performs a reverse lookup of the address in ENS using the Reverse Registrar. If the name does not exist, or the forward lookup does not match, null is returned.\n   *\n   * An ENS name requires additional configuration to setup a reverse record, so not all ENS addresses will map back to the original ENS domain.\n   *\n   * @param address The address to look up the ENS domain name for.\n   */\n  async lookupAddress(address: string): Promise<string | null> {\n    const provider = await this.config.getProvider();\n    return provider.lookupAddress(address);\n  }\n}\n\n/**\n * Perform a binary search between an integer range of block numbers to find the\n * block number where the contract was deployed.\n *\n * @internal\n */\nasync function binarySearchFirstBlock(\n  start: number,\n  end: number,\n  address: string,\n  config: AlchemyConfig\n): Promise<number> {\n  if (start >= end) {\n    return end;\n  }\n\n  const mid = Math.floor((start + end) / 2);\n  const provider = await config.getProvider();\n  const code = await provider.getCode(address, mid);\n  if (code === ETH_NULL_VALUE) {\n    return binarySearchFirstBlock(mid + 1, end, address, config);\n  }\n  return binarySearchFirstBlock(start, mid, address, config);\n}\n","import {\n  BlockIdentifier,\n  DebugCallTrace,\n  DebugCallTracer,\n  DebugPrestateTrace,\n  DebugPrestateTracer,\n  DebugTransaction\n} from '../types/types';\nimport { AlchemyConfig } from './alchemy-config';\nimport { hexStripZeros, hexValue, isHexString } from './utils';\n\n/**\n * The Debug namespace contains methods to access the non-standard RPC methods\n * for inspecting and debugging transactions.\n *\n * For more information on the different methods and use cases please read our\n * [documentation](https://docs.alchemy.com/reference/debug-api-quickstart).\n *\n * Do not call this constructor directly. Instead, instantiate an Alchemy object\n * with `const alchemy = new Alchemy(config)` and then access the debug namespace\n * via `alchemy.debug`.\n */\nexport class DebugNamespace {\n  /** @internal */\n  constructor(private readonly config: AlchemyConfig) {}\n\n  /**\n   * Runs an `eth_call` with the context of the provided block execution using the\n   * final state of the parent block as the base.\n   *\n   * @param transaction The transaction to debug trace.\n   * @param blockIdentifier The block to debug the transaction in. Can be a\n   * block hash, block number hex string, or commitment level.\n   * @param tracer Tracer type and configuration.\n   */\n  traceCall(\n    transaction: DebugTransaction,\n    blockIdentifier: BlockIdentifier,\n    tracer: DebugCallTracer\n  ): Promise<DebugCallTrace>;\n\n  /**\n   * Runs an `eth_call` with the context of the provided block execution using the\n   * final state of the parent block as the base.\n   *\n   * @param transaction The transaction to debug trace.\n   * @param blockIdentifier The block to debug the transaction in. Can be a\n   * block hash, block number hex string, or commitment level.\n   * @param tracer Tracer type and configuration.\n   */\n  traceCall(\n    transaction: DebugTransaction,\n    blockIdentifier: BlockIdentifier,\n    tracer: DebugPrestateTracer\n  ): Promise<DebugPrestateTrace>;\n  async traceCall(\n    transaction: DebugTransaction,\n    blockIdentifier: BlockIdentifier,\n    tracer: DebugCallTracer | DebugPrestateTracer\n  ): Promise<DebugCallTrace | DebugPrestateTrace> {\n    const provider = await this.config.getProvider();\n    const params = [transaction, blockIdentifier, parseTracerParams(tracer)];\n    return provider._send('debug_traceCall', params, 'traceCall');\n  }\n\n  /**\n   * Attempts to run the transaction in the exact same manner as it was executed\n   * on the network. It will replay any transaction that may have been executed\n   * prior to this one before it and will then attempt to execute the transaction\n   * that corresponds to the given hash.\n   *\n   * @param transactionHash The transaction hash of the transaction to trace.\n   * @param tracer Tracer type and configuration.\n   * @param timeout  A duration string of decimal numbers that overrides the\n   * default timeout of 5 seconds for JavaScript-based tracing calls. Max\n   * timeout is \"10s\". Valid time units are \"ns\", \"us\", \"ms\", \"s\" each with\n   * optional fraction, such as \"300ms\" or \"2s45ms\".\n   */\n  async traceTransaction(\n    transactionHash: string,\n    tracer: DebugCallTracer,\n    timeout?: string\n  ): Promise<DebugCallTrace>;\n\n  /**\n   * Attempts to run the transaction in the exact same manner as it was executed\n   * on the network. It will replay any transaction that may have been executed\n   * prior to this one before it and will then attempt to execute the transaction\n   * that corresponds to the given hash.\n   *\n   * @param transactionHash The transaction hash of the transaction to trace.\n   * @param tracer Tracer type and configuration.\n   * @param timeout  A duration string of decimal numbers that overrides the\n   * default timeout of 5 seconds for JavaScript-based tracing calls. Max\n   * timeout is \"10s\". Valid time units are \"ns\", \"us\", \"ms\", \"s\" each with\n   * optional fraction, such as \"300ms\" or \"2s45ms\".\n   */\n  async traceTransaction(\n    transactionHash: string,\n    tracer: DebugPrestateTracer,\n    timeout?: string\n  ): Promise<DebugPrestateTrace>;\n  async traceTransaction(\n    transactionHash: string,\n    tracer: DebugCallTracer | DebugPrestateTracer,\n    timeout?: string\n  ): Promise<DebugCallTrace | DebugPrestateTrace> {\n    const provider = await this.config.getProvider();\n    const params = [transactionHash, parseTracerParams(tracer, timeout)];\n    return provider._send('debug_traceTransaction', params, 'traceTransaction');\n  }\n\n  /**\n   * Replays a block that has already been mined.\n   *\n   * @param blockIdentifier The block to debug the transaction in. Can be a\n   * block hash, block number hex string, or commitment level.\n   * @param tracer Tracer type and configuration.\n   */\n  traceBlock(\n    blockIdentifier: BlockIdentifier | number,\n    tracer: DebugCallTracer\n  ): Promise<DebugCallTrace>;\n  /**\n   * Replays a block that has already been mined.\n   *\n   * @param blockIdentifier The block to debug the transaction in. Can be a\n   * block hash, block number hex string, or commitment level.\n   * @param tracer Tracer type and configuration.\n   */\n  traceBlock(\n    blockIdentifier: BlockIdentifier | number,\n    tracer: DebugPrestateTracer\n  ): Promise<DebugPrestateTrace>;\n  async traceBlock(\n    blockIdentifier: BlockIdentifier | number,\n    tracer: DebugCallTracer | DebugPrestateTracer\n  ): Promise<DebugCallTrace | DebugPrestateTrace> {\n    const provider = await this.config.getProvider();\n    let method: string;\n    let params: [string, RawTracer];\n    if (isHexString(blockIdentifier, 32)) {\n      method = 'debug_traceBlockByHash';\n      params = [blockIdentifier as string, parseTracerParams(tracer)];\n    } else {\n      method = 'debug_traceBlockByNumber';\n      const block =\n        typeof blockIdentifier === 'number'\n          ? hexStripZeros(hexValue(blockIdentifier))\n          : blockIdentifier;\n      params = [block as string, parseTracerParams(tracer)];\n    }\n    return provider._send(method, params, 'traceBlock');\n  }\n}\n\ninterface RawTracer {\n  tracer: string;\n  tracerConfig?: {\n    onlyTopCall?: boolean;\n    timeout?: string;\n  };\n}\n\nfunction parseTracerParams(\n  tracer: DebugCallTracer | DebugPrestateTracer,\n  timeout?: string\n): RawTracer {\n  return {\n    tracer: tracer.type,\n    ...(tracer.onlyTopCall !== undefined && {\n      tracerConfig: {\n        onlyTopCall: tracer.onlyTopCall,\n        timeout\n      }\n    })\n  };\n}\n","import { InputNftTokenType } from '../internal/nft-api';\nimport { NftTokenType } from '../types/types';\n\nexport function sanitizeTokenType(tokenType?: NftTokenType): InputNftTokenType {\n  if (tokenType === NftTokenType.ERC1155 || tokenType === NftTokenType.ERC721) {\n    return tokenType;\n  }\n  return undefined;\n}\n","/**\n * The SDK has 4 log levels and a 5th option for disabling all logging. By\n * default, the log level is set to INFO.\n *\n * The order is a follows: DEBUG < INFO < WARN < ERROR\n *\n * All log types above the current log level will be outputted.\n */\nexport enum LogLevel {\n  DEBUG,\n  INFO,\n  WARN,\n  ERROR,\n  SILENT\n}\n\n/**\n * The level of verbosity for the logger.\n *\n * @public\n */\nexport type LogLevelString = 'debug' | 'info' | 'warn' | 'error' | 'silent';\n\nconst logLevelStringToEnum: { [key in LogLevelString]: LogLevel } = {\n  debug: LogLevel.DEBUG,\n  info: LogLevel.INFO,\n  warn: LogLevel.WARN,\n  error: LogLevel.ERROR,\n  silent: LogLevel.SILENT\n};\n\n// HACKY: Use the console method as a string rather than the function itself\n// in order to allow for mocking in tests.\nconst logLevelToConsoleFn = {\n  [LogLevel.DEBUG]: 'log',\n  [LogLevel.INFO]: 'info',\n  [LogLevel.WARN]: 'warn',\n  [LogLevel.ERROR]: 'error'\n};\n\nconst DEFAULT_LOG_LEVEL = LogLevel.INFO;\n\n/**\n * Configures the verbosity of logging. The default log level is `info`.\n *\n * @param logLevel - The verbosity of logging. Can be any of the following values:\n *\n *   - `debug`: The most verbose logging level.\n *   - `info`: The default logging level.\n *   - `warn`: A logging level for non-critical issues.\n *   - `error`: A logging level for critical issues.\n *   - `silent`: Turn off all logging.\n *\n * @public\n */\nexport function setLogLevel(logLevel: LogLevelString): void {\n  loggerClient.logLevel = logLevelStringToEnum[logLevel];\n}\n\nexport function logDebug(message: string, ...args: unknown[]): void {\n  loggerClient.debug(message, args);\n}\n\nexport function logInfo(message: string, ...args: unknown[]): void {\n  loggerClient.info(message, args);\n}\n\nexport function logWarn(message: string, ...args: unknown[]): void {\n  loggerClient.warn(message, args);\n}\n\nexport function logError(message: string, ...args: unknown[]): void {\n  loggerClient.error(message, args);\n}\n\nexport class Logger {\n  /** The log level of the given Logger instance. */\n  private _logLevel = DEFAULT_LOG_LEVEL;\n\n  constructor() {}\n\n  get logLevel(): LogLevel {\n    return this._logLevel;\n  }\n\n  set logLevel(val: LogLevel) {\n    if (!(val in LogLevel)) {\n      throw new TypeError(`Invalid value \"${val}\" assigned to \\`logLevel\\``);\n    }\n    this._logLevel = val;\n  }\n\n  debug(...args: unknown[]): void {\n    this._log(LogLevel.DEBUG, ...args);\n  }\n\n  info(...args: unknown[]): void {\n    this._log(LogLevel.INFO, ...args);\n  }\n\n  warn(...args: unknown[]): void {\n    this._log(LogLevel.WARN, ...args);\n  }\n\n  error(...args: unknown[]): void {\n    this._log(LogLevel.ERROR, ...args);\n  }\n\n  /**\n   * Forwards log messages to their corresponding console counterparts if the\n   * log level allows it.\n   */\n  private _log(logLevel: LogLevel, ...args: unknown[]): void {\n    if (logLevel < this._logLevel) {\n      return;\n    }\n    const now = new Date().toISOString();\n    const method =\n      logLevelToConsoleFn[logLevel as keyof typeof logLevelToConsoleFn];\n    if (method) {\n      console[method as 'log' | 'info' | 'warn' | 'error'](\n        `[${now}] Alchemy:`,\n        ...args.map(stringify)\n      );\n    } else {\n      throw new Error(\n        `Logger received an invalid logLevel (value: ${logLevel})`\n      );\n    }\n  }\n}\n\nfunction stringify(obj: unknown): string | unknown {\n  if (typeof obj === 'string') {\n    return obj;\n  } else {\n    try {\n      return JSON.stringify(obj);\n    } catch (e) {\n      // Failed to convert to JSON, log the object directly.\n      return obj;\n    }\n  }\n}\n\n// Instantiate default logger for the SDK.\nconst loggerClient: Logger = new Logger();\n","// This file is autogenerated by injectVersion.js. Any changes will be\n// overwritten on commit!\nexport const VERSION = '2.10.0';\n","/**\n * Given a REST endpoint, method, and params, sends the request with axios and\n * returns the response.\n */\nimport axios, { AxiosRequestConfig, AxiosResponse } from 'axios';\n\nimport { VERSION } from '../version';\nimport { IS_BROWSER } from './util';\n\n/**\n * Helper function to send http requests using Axis.\n *\n * @private\n */\nexport function sendAxiosRequest<Req, Res>(\n  baseUrl: string,\n  restApiName: string,\n  methodName: string,\n  params: Req,\n  overrides?: AxiosRequestConfig\n): Promise<AxiosResponse<Res>> {\n  const requestUrl = baseUrl + '/' + restApiName;\n  const config: AxiosRequestConfig = {\n    ...overrides,\n    headers: {\n      ...overrides?.headers,\n      ...(!IS_BROWSER && { 'Accept-Encoding': 'gzip' }),\n      'Alchemy-Ethers-Sdk-Version': VERSION,\n      'Alchemy-Ethers-Sdk-Method': methodName\n    },\n    method: overrides?.method ?? 'GET',\n    url: requestUrl,\n    params\n  };\n  return axios(config);\n}\n","import { logDebug } from '../util/logger';\n\nexport const DEFAULT_BACKOFF_INITIAL_DELAY_MS = 1000;\nexport const DEFAULT_BACKOFF_MULTIPLIER = 1.5;\nexport const DEFAULT_BACKOFF_MAX_DELAY_MS = 30 * 1000;\nexport const DEFAULT_BACKOFF_MAX_ATTEMPTS = 5;\n\n/**\n * Helper class for implementing exponential backoff and max retry attempts.\n *\n * @private\n * @internal\n */\nexport class ExponentialBackoff {\n  private readonly initialDelayMs = DEFAULT_BACKOFF_INITIAL_DELAY_MS;\n  private readonly backoffMultiplier = DEFAULT_BACKOFF_MULTIPLIER;\n  private readonly maxDelayMs = DEFAULT_BACKOFF_MAX_DELAY_MS;\n\n  private numAttempts = 0;\n  private currentDelayMs = 0;\n  private isInBackoff = false;\n\n  constructor(private readonly maxAttempts = DEFAULT_BACKOFF_MAX_ATTEMPTS) {}\n\n  /**\n   * Returns a promise that resolves after the the backoff delay. The delay is\n   * increased for each attempt. The promise is rejected if the maximum number\n   * of attempts is exceeded.\n   */\n  // TODO: beautify this into an async iterator.\n  backoff(): Promise<void> {\n    if (this.numAttempts >= this.maxAttempts) {\n      return Promise.reject(\n        new Error(`Exceeded maximum number of attempts: ${this.maxAttempts}`)\n      );\n    }\n    if (this.isInBackoff) {\n      return Promise.reject(\n        new Error('A backoff operation is already in progress')\n      );\n    }\n\n    const backoffDelayWithJitterMs = this.withJitterMs(this.currentDelayMs);\n    if (backoffDelayWithJitterMs > 0) {\n      logDebug(\n        'ExponentialBackoff.backoff',\n        `Backing off for ${backoffDelayWithJitterMs}ms`\n      );\n    }\n\n    // Calculate the next delay.\n    this.currentDelayMs *= this.backoffMultiplier;\n    this.currentDelayMs = Math.max(this.currentDelayMs, this.initialDelayMs);\n    this.currentDelayMs = Math.min(this.currentDelayMs, this.maxDelayMs);\n    this.numAttempts += 1;\n\n    return new Promise(resolve => {\n      this.isInBackoff = true;\n      setTimeout(() => {\n        this.isInBackoff = false;\n        resolve();\n      }, backoffDelayWithJitterMs);\n    });\n  }\n\n  /**\n   * Applies +/- 50% jitter to the backoff delay, up to the max delay cap.\n   *\n   * @private\n   * @param delayMs\n   */\n  private withJitterMs(delayMs: number): number {\n    return Math.min(delayMs + (Math.random() - 0.5) * delayMs, this.maxDelayMs);\n  }\n}\n","import axios, { AxiosError, AxiosRequestConfig } from 'axios';\n\nimport { AlchemyConfig } from '../api/alchemy-config';\nimport { AlchemyApiType } from '../util/const';\nimport { logDebug, logInfo } from '../util/logger';\nimport { sendAxiosRequest } from '../util/sendRest';\nimport { ExponentialBackoff } from './backoff';\n\n/**\n * A wrapper function to make http requests and retry if the request fails.\n *\n * @internal\n */\n// TODO: Wrap Axios error in AlchemyError.\nexport async function requestHttpWithBackoff<Req, Res>(\n  config: AlchemyConfig,\n  apiType: AlchemyApiType,\n  restApiName: string,\n  methodName: string,\n  params: Req,\n  overrides?: AxiosRequestConfig\n): Promise<Res> {\n  let lastError: Error | undefined = undefined;\n  const backoff = new ExponentialBackoff(config.maxRetries);\n  for (let attempt = 0; attempt < config.maxRetries + 1; attempt++) {\n    try {\n      if (lastError !== undefined) {\n        logInfo('requestHttp', `Retrying after error: ${lastError.message}`);\n      }\n\n      try {\n        await backoff.backoff();\n      } catch (err) {\n        // Backoff errors when the maximum number of attempts is reached. Break\n        // out of the loop to preserve the last error.\n        break;\n      }\n\n      const response = await sendAxiosRequest<Req, Res>(\n        config._getRequestUrl(apiType),\n        restApiName,\n        methodName,\n        params,\n        {\n          ...overrides,\n          timeout: config.requestTimeout\n        }\n      );\n\n      if (response.status === 200) {\n        logDebug(restApiName, `Successful request: ${restApiName}`);\n        return response.data;\n      } else {\n        logInfo(\n          restApiName,\n          `Request failed: ${restApiName}, ${response.status}, ${response.data}`\n        );\n        lastError = new Error(response.status + ': ' + response.data);\n      }\n    } catch (err) {\n      if (!axios.isAxiosError(err) || err.response === undefined) {\n        throw err;\n      }\n      // TODO: Standardize all errors into AlchemyError\n      lastError = new Error(err.response.status + ': ' + err.response.data);\n      if (!isRetryableHttpError(err, apiType)) {\n        break;\n      }\n    }\n  }\n  return Promise.reject(lastError);\n}\n\nfunction isRetryableHttpError(\n  err: AxiosError,\n  apiType: AlchemyApiType\n): boolean {\n  // TODO: remove 500s after webhooks are more stable.\n  const retryableCodes =\n    apiType === AlchemyApiType.WEBHOOK ? [429, 500] : [429];\n  return (\n    err.response !== undefined && retryableCodes.includes(err.response.status)\n  );\n}\n\n/**\n * Fetches all pages in a paginated endpoint, given a `pageKey` field that\n * represents the property name containing the next page token.\n *\n * @internal\n */\nexport async function* paginateEndpoint<\n  ReqPageKey extends string,\n  ResPageKey extends string,\n  Req extends Partial<Record<string, any> & Record<ReqPageKey, string>>,\n  Res extends Partial<Record<string, any> & Record<ResPageKey, string>>\n>(\n  config: AlchemyConfig,\n  apiType: AlchemyApiType,\n  restApiName: string,\n  methodName: string,\n  reqPageKey: ReqPageKey,\n  resPageKey: ResPageKey,\n  params: Req\n): AsyncIterable<Res> {\n  let hasNext = true;\n  const requestParams = { ...params };\n  while (hasNext) {\n    const response = await requestHttpWithBackoff<Req, Res>(\n      config,\n      apiType,\n      restApiName,\n      methodName,\n      requestParams\n    );\n    yield response;\n    if (response[resPageKey] !== undefined) {\n      requestParams[reqPageKey] = response[resPageKey] as any;\n    } else {\n      hasNext = false;\n    }\n  }\n}\n","import { BigNumber, BigNumberish } from '@ethersproject/bignumber';\n\nimport { AlchemyConfig } from '../api/alchemy-config';\nimport { BaseNft, Nft, NftContract } from '../api/nft';\nimport {\n  AssetTransfersCategory,\n  AssetTransfersParams,\n  AssetTransfersResponse,\n  AssetTransfersResult,\n  GetBaseNftsForContractOptions,\n  GetBaseNftsForOwnerOptions,\n  GetContractsForOwnerOptions,\n  GetContractsForOwnerResponse,\n  GetFloorPriceResponse,\n  GetMintedNftsOptions,\n  GetNftMetadataOptions,\n  GetNftSalesOptions,\n  GetNftSalesOptionsByContractAddress,\n  GetNftSalesResponse,\n  GetNftsForContractOptions,\n  GetNftsForOwnerOptions,\n  GetOwnersForContractOptions,\n  GetOwnersForContractResponse,\n  GetOwnersForContractWithTokenBalancesOptions,\n  GetOwnersForContractWithTokenBalancesResponse,\n  GetOwnersForNftResponse,\n  GetTransfersForContractOptions,\n  GetTransfersForOwnerOptions,\n  GetTransfersForOwnerTransferType,\n  NftAttributeRarity,\n  NftAttributesResponse,\n  NftContractBaseNftsResponse,\n  NftContractNftsResponse,\n  NftFilters,\n  NftMetadataBatchOptions,\n  NftMetadataBatchToken,\n  NftOrdering,\n  NftSaleMarketplace,\n  NftSaleTakerType,\n  NftTokenType,\n  OwnedBaseNft,\n  OwnedBaseNftsResponse,\n  OwnedNft,\n  OwnedNftsResponse,\n  RefreshContractResult,\n  RefreshState,\n  SortingOrder,\n  TransfersNftResponse\n} from '../types/types';\nimport { AlchemyApiType, ETH_NULL_ADDRESS } from '../util/const';\nimport { sanitizeTokenType } from '../util/inputSanitization';\nimport {\n  getBaseNftFromRaw,\n  getContractsForOwnerFromRaw,\n  getNftContractFromRaw,\n  getNftFromRaw,\n  getNftRarityFromRaw,\n  getNftSalesFromRaw\n} from '../util/util';\nimport { getAssetTransfers } from './core-api';\nimport { paginateEndpoint, requestHttpWithBackoff } from './dispatch';\nimport {\n  RawBaseNft,\n  RawContractBaseNft,\n  RawGetBaseNftsForContractResponse,\n  RawGetBaseNftsResponse,\n  RawGetContractsForOwnerResponse,\n  RawGetNftSalesResponse,\n  RawGetNftsForContractResponse,\n  RawGetNftsResponse,\n  RawGetOwnersForContractResponse,\n  RawNft,\n  RawNftAttributeRarity,\n  RawNftContract,\n  RawOwnedBaseNft,\n  RawOwnedNft,\n  RawReingestContractResponse\n} from './raw-interfaces';\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link NftNamespace}. By moving the methods out into a separate file,\n * other namespaces can access these methods without depending on the entire\n * NftNamespace.\n */\n\n/**\n * Get the NFT metadata for the provided contract address.\n */\nexport async function getNftMetadata(\n  config: AlchemyConfig,\n  contractAddress: string,\n  tokenId: BigNumberish,\n  options?: GetNftMetadataOptions,\n  srcMethod = 'getNftMetadata'\n): Promise<Nft> {\n  const response = await requestHttpWithBackoff<GetNftMetadataParams, RawNft>(\n    config,\n    AlchemyApiType.NFT,\n    'getNFTMetadata',\n    srcMethod,\n    {\n      contractAddress,\n      tokenId: BigNumber.from(tokenId!).toString(),\n      tokenType: sanitizeTokenType(options?.tokenType),\n      tokenUriTimeoutInMs: options?.tokenUriTimeoutInMs,\n      refreshCache: options?.refreshCache\n    }\n  );\n  return getNftFromRaw(response);\n}\n\nexport async function getNftMetadataBatch(\n  config: AlchemyConfig,\n  tokens: Array<NftMetadataBatchToken>,\n  options?: NftMetadataBatchOptions\n): Promise<Nft[]> {\n  const data = {\n    tokens,\n    tokenUriTimeoutInMs: options?.tokenUriTimeoutInMs,\n    refreshCache: options?.refreshCache\n  };\n  const response = await requestHttpWithBackoff<{}, RawNft[]>(\n    config,\n    AlchemyApiType.NFT,\n    'getNFTMetadataBatch',\n    'getNftMetadataBatch',\n    {},\n    {\n      method: 'POST',\n      data\n    }\n  );\n  return response.map(getNftFromRaw);\n}\n\nexport async function getContractMetadata(\n  config: AlchemyConfig,\n  contractAddress: string,\n  srcMethod = 'getContractMetadata'\n): Promise<NftContract> {\n  const response = await requestHttpWithBackoff<\n    GetContractMetadataParams,\n    RawNftContract\n  >(config, AlchemyApiType.NFT, 'getContractMetadata', srcMethod, {\n    contractAddress\n  });\n\n  return getNftContractFromRaw(response);\n}\n\nexport async function getContractMetadataBatch(\n  config: AlchemyConfig,\n  contractAddresses: string[]\n): Promise<NftContract[]> {\n  const response = await requestHttpWithBackoff<{}, RawNftContract[]>(\n    config,\n    AlchemyApiType.NFT,\n    'getContractMetadataBatch',\n    'getContractMetadataBatch',\n    {},\n    {\n      method: 'POST',\n      data: { contractAddresses }\n    }\n  );\n\n  return response.map(getNftContractFromRaw);\n}\n\nexport async function* getNftsForOwnerIterator(\n  config: AlchemyConfig,\n  owner: string,\n  options?: GetNftsForOwnerOptions | GetBaseNftsForOwnerOptions,\n  srcMethod = 'getNftsForOwnerIterator'\n): AsyncIterable<OwnedBaseNft | OwnedNft> {\n  const withMetadata = omitMetadataToWithMetadata(options?.omitMetadata);\n  for await (const response of paginateEndpoint(\n    config,\n    AlchemyApiType.NFT,\n    'getNFTs',\n    srcMethod,\n    'pageKey',\n    'pageKey',\n    {\n      contractAddresses: options?.contractAddresses,\n      pageKey: options?.pageKey,\n      filters: options?.excludeFilters,\n      owner,\n      withMetadata\n    }\n  )) {\n    for (const ownedNft of response.ownedNfts as\n      | RawOwnedNft[]\n      | RawOwnedBaseNft[]) {\n      yield {\n        ...nftFromGetNftResponse(ownedNft),\n        balance: parseInt(ownedNft.balance)\n      };\n    }\n  }\n}\n\nexport async function getNftsForOwner(\n  config: AlchemyConfig,\n  owner: string,\n  options?: GetNftsForOwnerOptions | GetBaseNftsForOwnerOptions,\n  srcMethod = 'getNftsForOwner'\n): Promise<OwnedNftsResponse | OwnedBaseNftsResponse> {\n  const withMetadata = omitMetadataToWithMetadata(options?.omitMetadata);\n  const response = await requestHttpWithBackoff<\n    GetNftsAlchemyParams,\n    RawGetBaseNftsResponse | RawGetNftsResponse\n  >(config, AlchemyApiType.NFT, 'getNFTs', srcMethod, {\n    contractAddresses: options?.contractAddresses,\n    pageKey: options?.pageKey,\n    filters: options?.excludeFilters,\n    excludeFilters: options?.excludeFilters,\n    includeFilters: options?.includeFilters,\n    owner,\n    pageSize: options?.pageSize,\n    withMetadata,\n    tokenUriTimeoutInMs: options?.tokenUriTimeoutInMs,\n    orderBy: options?.orderBy\n  });\n  return {\n    ownedNfts: response.ownedNfts.map(res => ({\n      ...nftFromGetNftResponse(res),\n      balance: parseInt(res.balance)\n    })),\n    pageKey: response.pageKey,\n    totalCount: response.totalCount,\n    blockHash: response.blockHash\n  };\n}\n\nexport async function getNftsForContract(\n  config: AlchemyConfig,\n  contractAddress: string,\n  options?: GetBaseNftsForContractOptions | GetNftsForContractOptions,\n  srcMethod = 'getNftsForContract'\n): Promise<NftContractNftsResponse | NftContractBaseNftsResponse> {\n  const withMetadata = omitMetadataToWithMetadata(options?.omitMetadata);\n  const response = await requestHttpWithBackoff<\n    GetNftsForContractAlchemyParams,\n    RawGetBaseNftsForContractResponse | RawGetNftsForContractResponse\n  >(config, AlchemyApiType.NFT, 'getNFTsForCollection', srcMethod, {\n    contractAddress,\n    startToken: options?.pageKey,\n    withMetadata,\n    limit: options?.pageSize ?? undefined,\n    tokenUriTimeoutInMs: options?.tokenUriTimeoutInMs\n  });\n\n  return {\n    nfts: response.nfts.map(res =>\n      nftFromGetNftContractResponse(res, contractAddress)\n    ),\n    pageKey: response.nextToken\n  };\n}\n\nexport async function* getNftsForContractIterator(\n  config: AlchemyConfig,\n  contractAddress: string,\n  options?: GetBaseNftsForContractOptions | GetNftsForContractOptions,\n  srcMethod = 'getNftsForContractIterator'\n): AsyncIterable<BaseNft | Nft> {\n  const withMetadata = omitMetadataToWithMetadata(options?.omitMetadata);\n  for await (const response of paginateEndpoint(\n    config,\n    AlchemyApiType.NFT,\n    'getNFTsForCollection',\n    srcMethod,\n    'startToken',\n    'nextToken',\n    {\n      contractAddress,\n      startToken: options?.pageKey,\n      withMetadata\n    }\n  )) {\n    for (const nft of response.nfts as RawContractBaseNft[] | RawNft[]) {\n      yield nftFromGetNftContractResponse(nft, contractAddress);\n    }\n  }\n}\n\nexport async function getOwnersForContract(\n  config: AlchemyConfig,\n  contractAddress: string,\n  options?:\n    | GetOwnersForContractWithTokenBalancesOptions\n    | GetOwnersForContractOptions,\n  srcMethod = 'getOwnersForContract'\n): Promise<\n  GetOwnersForContractResponse | GetOwnersForContractWithTokenBalancesResponse\n> {\n  // Cast to `any` to avoid more type wrangling.\n  const response: any = await requestHttpWithBackoff<\n    GetOwnersForNftContractAlchemyParams,\n    RawGetOwnersForContractResponse\n  >(config, AlchemyApiType.NFT, 'getOwnersForCollection', srcMethod, {\n    ...options,\n    contractAddress\n  });\n\n  return {\n    owners: response.ownerAddresses,\n    totalCount: response.totalCount,\n\n    // Only include the pageKey in the final response if it's defined\n    ...(response.pageKey !== undefined && { pageKey: response.pageKey })\n  };\n}\n\nexport async function getContractsForOwner(\n  config: AlchemyConfig,\n  owner: string,\n  options?: GetContractsForOwnerOptions,\n  srcMethod = 'getContractsForOwner'\n): Promise<GetContractsForOwnerResponse> {\n  const response = await requestHttpWithBackoff<\n    GetContractsForOwnerParams,\n    RawGetContractsForOwnerResponse\n  >(config, AlchemyApiType.NFT, 'getContractsForOwner', srcMethod, {\n    owner,\n    excludeFilters: options?.excludeFilters,\n    includeFilters: options?.includeFilters,\n    pageKey: options?.pageKey,\n    pageSize: options?.pageSize,\n    orderBy: options?.orderBy\n  });\n\n  return getContractsForOwnerFromRaw(response);\n}\n\nexport async function getOwnersForNft(\n  config: AlchemyConfig,\n  contractAddress: string,\n  tokenId: BigNumberish,\n  options?: GetOwnersForContractOptions,\n  srcMethod = 'getOwnersForNft'\n): Promise<GetOwnersForNftResponse> {\n  return requestHttpWithBackoff(\n    config,\n    AlchemyApiType.NFT,\n    'getOwnersForToken',\n    srcMethod,\n    {\n      contractAddress,\n      tokenId: BigNumber.from(tokenId!).toString(),\n      ...options\n    }\n  );\n}\n\nexport async function getMintedNfts(\n  config: AlchemyConfig,\n  owner: string,\n  options?: GetMintedNftsOptions\n): Promise<TransfersNftResponse> {\n  const provider = await config.getProvider();\n  const ownerAddress = await provider._getAddress(owner);\n  const category = nftTokenTypeToCategory(options?.tokenType);\n  const params: AssetTransfersParams = {\n    fromBlock: '0x0',\n    fromAddress: ETH_NULL_ADDRESS,\n    toAddress: ownerAddress,\n    excludeZeroValue: true,\n    contractAddresses: options?.contractAddresses,\n    category,\n    maxCount: 100,\n    pageKey: options?.pageKey\n  };\n  const response = await getAssetTransfers(config, params, 'getMintedNfts');\n  return getNftsForTransfers(config, response);\n}\n\nexport async function getTransfersForOwner(\n  config: AlchemyConfig,\n  owner: string,\n  transferType: GetTransfersForOwnerTransferType,\n  options?: GetTransfersForOwnerOptions\n): Promise<TransfersNftResponse> {\n  const provider = await config.getProvider();\n  const ownerAddress = await provider._getAddress(owner);\n  const category = nftTokenTypeToCategory(options?.tokenType);\n  const params: AssetTransfersParams = {\n    fromBlock: '0x0',\n    excludeZeroValue: true,\n    contractAddresses: options?.contractAddresses,\n    category,\n    maxCount: 100,\n    pageKey: options?.pageKey\n  };\n\n  if (transferType === GetTransfersForOwnerTransferType.TO) {\n    params.toAddress = ownerAddress;\n  } else {\n    params.fromAddress = ownerAddress;\n  }\n  const transfersResponse = await getAssetTransfers(\n    config,\n    params,\n    'getTransfersForOwner'\n  );\n\n  return getNftsForTransfers(config, transfersResponse);\n}\n\nexport async function getTransfersForContract(\n  config: AlchemyConfig,\n  contract: string,\n  options?: GetTransfersForContractOptions\n): Promise<TransfersNftResponse> {\n  const category = [\n    AssetTransfersCategory.ERC721,\n    AssetTransfersCategory.ERC1155,\n    AssetTransfersCategory.SPECIALNFT\n  ];\n  const provider = await config.getProvider();\n  const fromBlock = options?.fromBlock\n    ? provider.formatter.blockTag(\n        await provider._getBlockTag(options.fromBlock)\n      )\n    : '0x0';\n  const toBlock = options?.toBlock\n    ? provider.formatter.blockTag(await provider._getBlockTag(options.toBlock))\n    : undefined;\n  const params: AssetTransfersParams = {\n    fromBlock,\n    toBlock,\n    excludeZeroValue: true,\n    contractAddresses: [contract],\n    order: options?.order,\n    category,\n    maxCount: 100,\n    pageKey: options?.pageKey\n  };\n\n  const transfersResponse = await getAssetTransfers(\n    config,\n    params,\n    'getTransfersForContract'\n  );\n\n  return getNftsForTransfers(config, transfersResponse);\n}\n\nfunction nftTokenTypeToCategory(\n  tokenType: NftTokenType | undefined\n): AssetTransfersCategory[] {\n  switch (tokenType) {\n    case NftTokenType.ERC721:\n      return [AssetTransfersCategory.ERC721];\n    case NftTokenType.ERC1155:\n      return [AssetTransfersCategory.ERC1155];\n    default:\n      return [\n        AssetTransfersCategory.ERC721,\n        AssetTransfersCategory.ERC1155,\n        AssetTransfersCategory.SPECIALNFT\n      ];\n  }\n}\n\nfunction parse1155Transfer(\n  transfer: AssetTransfersResult\n): NftMetadataBatchToken[] {\n  return transfer.erc1155Metadata!.map(metadata => ({\n    contractAddress: transfer.rawContract.address!,\n    tokenId: metadata.tokenId,\n    tokenType: NftTokenType.ERC1155\n  }));\n}\n\nexport async function checkNftOwnership(\n  config: AlchemyConfig,\n  owner: string,\n  contractAddresses: string[],\n  srcMethod = 'checkNftOwnership'\n): Promise<boolean> {\n  if (contractAddresses.length === 0) {\n    throw new Error('Must provide at least one contract address');\n  }\n  const response = await getNftsForOwner(\n    config,\n    owner,\n    {\n      contractAddresses,\n      omitMetadata: true\n    },\n    srcMethod\n  );\n  return response.ownedNfts.length > 0;\n}\n\nexport async function verifyNftOwnership(\n  config: AlchemyConfig,\n  owner: string,\n  contractAddresses: string | string[],\n  srcMethod = 'verifyNftOwnership'\n): Promise<boolean | { [contractAddress: string]: boolean }> {\n  if (typeof contractAddresses === 'string') {\n    const response = await getNftsForOwner(\n      config,\n      owner,\n      {\n        contractAddresses: [contractAddresses],\n        omitMetadata: true\n      },\n      srcMethod\n    );\n    return response.ownedNfts.length > 0;\n  } else {\n    if (contractAddresses.length === 0) {\n      throw new Error('Must provide at least one contract address');\n    }\n    const response = await getNftsForOwner(\n      config,\n      owner,\n      {\n        contractAddresses,\n        omitMetadata: true\n      },\n      srcMethod\n    );\n\n    // Create map where all input contract addresses are set to false, then flip\n    // owned nfts to true.\n    const result = contractAddresses.reduce(\n      (acc: { [contractAddress: string]: boolean }, curr) => {\n        acc[curr] = false;\n        return acc;\n      },\n      {}\n    );\n    for (const nft of response.ownedNfts) {\n      result[nft.contract.address] = true;\n    }\n    return result;\n  }\n}\n\nexport async function isSpamContract(\n  config: AlchemyConfig,\n  contractAddress: string,\n  srcMethod = 'isSpamContract'\n): Promise<boolean> {\n  return requestHttpWithBackoff<IsSpamContractParams, boolean>(\n    config,\n    AlchemyApiType.NFT,\n    'isSpamContract',\n    srcMethod,\n    {\n      contractAddress\n    }\n  );\n}\n\nexport async function getSpamContracts(\n  config: AlchemyConfig,\n  srcMethod = 'getSpamContracts'\n): Promise<string[]> {\n  return requestHttpWithBackoff<undefined, string[]>(\n    config,\n    AlchemyApiType.NFT,\n    'getSpamContracts',\n    srcMethod,\n    undefined\n  );\n}\n\nexport async function getFloorPrice(\n  config: AlchemyConfig,\n  contractAddress: string,\n  srcMethod = 'getFloorPrice'\n): Promise<GetFloorPriceResponse> {\n  return requestHttpWithBackoff<GetFloorPriceParams, GetFloorPriceResponse>(\n    config,\n    AlchemyApiType.NFT,\n    'getFloorPrice',\n    srcMethod,\n    {\n      contractAddress\n    }\n  );\n}\n\nexport async function getNftSales(\n  config: AlchemyConfig,\n  options: GetNftSalesOptions | GetNftSalesOptionsByContractAddress = {},\n  srcMethod = 'getNftSales'\n): Promise<GetNftSalesResponse> {\n  // Avoid ts compiler complaining about the contractAddress field.\n  const params: Partial<GetNftSalesOptionsByContractAddress> = {\n    ...options\n  };\n\n  const response = await requestHttpWithBackoff<\n    GetNftSalesParams,\n    RawGetNftSalesResponse\n  >(config, AlchemyApiType.NFT, 'getNFTSales', srcMethod, {\n    fromBlock: params?.fromBlock,\n    toBlock: params?.toBlock,\n    order: params?.order,\n    marketplace: params?.marketplace,\n    contractAddress: params?.contractAddress,\n    tokenId: params?.tokenId\n      ? BigNumber.from(params?.tokenId).toString()\n      : undefined,\n    sellerAddress: params?.sellerAddress,\n    buyerAddress: params?.buyerAddress,\n    taker: params?.taker,\n    limit: params?.limit,\n    pageKey: params?.pageKey\n  });\n\n  return getNftSalesFromRaw(response);\n}\n\nexport async function computeRarity(\n  config: AlchemyConfig,\n  contractAddress: string,\n  tokenId: BigNumberish,\n  refreshCache?: boolean,\n  srcMethod = 'computeRarity'\n): Promise<NftAttributeRarity[]> {\n  const response = await requestHttpWithBackoff<\n    ComputeRarityParams,\n    RawNftAttributeRarity[]\n  >(config, AlchemyApiType.NFT, 'computeRarity', srcMethod, {\n    contractAddress,\n    tokenId: BigNumber.from(tokenId).toString(),\n    refreshCache\n  });\n\n  return getNftRarityFromRaw(response);\n}\n\nexport async function searchContractMetadata(\n  config: AlchemyConfig,\n  query: string,\n  srcMethod = 'searchContractMetadata'\n): Promise<NftContract[]> {\n  const response = await requestHttpWithBackoff<\n    SearchContractMetadataParams,\n    RawNftContract[]\n  >(config, AlchemyApiType.NFT, 'searchContractMetadata', srcMethod, {\n    query\n  });\n\n  return response.map(getNftContractFromRaw);\n}\n\nexport async function summarizeNftAttributes(\n  config: AlchemyConfig,\n  contractAddress: string,\n  refreshCache?: boolean,\n  srcMethod = 'summarizeNftAttributes'\n): Promise<NftAttributesResponse> {\n  return requestHttpWithBackoff<\n    SummarizeNftAttributesParams,\n    NftAttributesResponse\n  >(config, AlchemyApiType.NFT, 'summarizeNftAttributes', srcMethod, {\n    contractAddress,\n    refreshCache\n  });\n}\n\nexport async function refreshNftMetadata(\n  config: AlchemyConfig,\n  contractAddress: string,\n  tokenId: BigNumberish,\n  srcMethod = 'refreshNftMetadata'\n): Promise<boolean> {\n  const tokenIdString = BigNumber.from(tokenId!).toString();\n  const first = await getNftMetadata(\n    config,\n    contractAddress,\n    tokenIdString,\n    undefined,\n    srcMethod\n  );\n  const second = await refresh(\n    config,\n    contractAddress,\n    tokenIdString,\n    srcMethod\n  );\n  return first.timeLastUpdated !== second.timeLastUpdated;\n}\n\nexport async function refreshContract(\n  config: AlchemyConfig,\n  contractAddress: string,\n  srcMethod = 'refreshContract'\n): Promise<RefreshContractResult> {\n  const response = await requestHttpWithBackoff<\n    ReingestContractParams,\n    RawReingestContractResponse\n  >(config, AlchemyApiType.NFT, 'reingestContract', srcMethod, {\n    contractAddress\n  });\n\n  return {\n    contractAddress: response.contractAddress,\n    refreshState: parseReingestionState(response.reingestionState),\n    progress: response.progress\n  };\n}\n\nasync function refresh(\n  config: AlchemyConfig,\n  contractAddress: string,\n  tokenId: BigNumberish,\n  srcMethod: string\n): Promise<Nft> {\n  const response = await requestHttpWithBackoff<GetNftMetadataParams, RawNft>(\n    config,\n    AlchemyApiType.NFT,\n    'getNFTMetadata',\n    srcMethod,\n    {\n      contractAddress,\n      tokenId: BigNumber.from(tokenId!).toString(),\n      refreshCache: true\n    }\n  );\n  return getNftFromRaw(response);\n}\n\n/**\n * Helper method to convert a NFT response received from Alchemy backend to an\n * SDK NFT type.\n *\n * @internal\n */\nfunction nftFromGetNftResponse(\n  ownedNft: RawOwnedBaseNft | RawOwnedNft\n): Nft | BaseNft {\n  if (isNftWithMetadata(ownedNft)) {\n    return getNftFromRaw(ownedNft);\n  } else {\n    return getBaseNftFromRaw(ownedNft);\n  }\n}\n\n/**\n * Helper method to convert a NFT response received from Alchemy backend to an\n * SDK NFT type.\n *\n * @internal\n */\nfunction nftFromGetNftContractResponse(\n  ownedNft: RawContractBaseNft | RawNft,\n  contractAddress: string\n): Nft | BaseNft {\n  if (isNftWithMetadata(ownedNft)) {\n    return getNftFromRaw(ownedNft);\n  } else {\n    return getBaseNftFromRaw(ownedNft, contractAddress);\n  }\n}\n\n/** @internal */\n// TODO: more comprehensive type check\nfunction isNftWithMetadata(\n  response: RawBaseNft | RawContractBaseNft | RawNft\n): response is RawNft {\n  return (response as RawNft).title !== undefined;\n}\n\n/**\n * Given an AssetTransfersResponse, fetches the NFTs associated with the\n * transfers and collates them with transfer metadata.\n *\n * VISIBLE FOR TESTING\n */\nexport async function getNftsForTransfers(\n  config: AlchemyConfig,\n  response: AssetTransfersResponse\n): Promise<TransfersNftResponse> {\n  const metadataTransfers = response.transfers\n    .filter(transfer => transfer.rawContract.address !== null)\n    // Use flatMap to flatten 1155 transfers that contain multiple NFTs.\n    .flatMap(transfer => {\n      const tokens = getTokensFromTransfer(transfer);\n\n      const metadata = {\n        from: transfer.from,\n        to: transfer.to ?? undefined,\n        transactionHash: transfer.hash,\n        blockNumber: transfer.blockNum\n      };\n      return tokens.map(token => ({ metadata, token }));\n    });\n\n  if (metadataTransfers.length === 0) {\n    return { nfts: [] };\n  }\n\n  // If we have more than 100 elements after unrolling 1155 transfers, split\n  // transfers into batches of 100 to stay under endpoint batch size limit.\n  const batchSize = 100;\n  const requestBatches = [];\n  for (let i = 0; i < metadataTransfers.length; i += batchSize) {\n    requestBatches.push(metadataTransfers.slice(i, i + batchSize));\n  }\n  const responseBatches = await Promise.all(\n    requestBatches.map(batch =>\n      getNftMetadataBatch(\n        config,\n        batch.map(transfer => transfer.token)\n      )\n    )\n  );\n  const nfts = responseBatches.flat();\n\n  // The same NFT can be transferred multiple times in the same transfers response.\n  // We want to return one NFT for each transfer, so we create a mapping for\n  // each NFT to pair with the transfer metadata.\n  const nftsByTokenId = new Map<string, Nft>();\n  nfts.forEach(nft => {\n    const key = `${nft.contract.address}-${BigNumber.from(\n      nft.tokenId\n    ).toString()}`;\n    nftsByTokenId.set(key, nft);\n  });\n\n  const transferredNfts = metadataTransfers.map(t => {\n    const key = `${t.token.contractAddress}-${BigNumber.from(\n      t.token.tokenId\n    ).toString()}`;\n    return {\n      ...nftsByTokenId.get(key)!,\n      ...t.metadata\n    };\n  });\n\n  return {\n    nfts: transferredNfts,\n    pageKey: response.pageKey\n  };\n}\n\n/**\n * Returns the underlying NFT tokens from a transfer as the params for a\n * `getNftMetadataBatch` call. Handles the 1155 case where multiple NFTs can be\n * transferred in a single transaction.\n */\nfunction getTokensFromTransfer(\n  transfer: AssetTransfersResult\n): NftMetadataBatchToken[] {\n  // ERC1155 NFTs can contain multiple tokens in a single transfer, which\n  // requires special logic.\n  if (transfer.category === AssetTransfersCategory.ERC1155) {\n    return parse1155Transfer(transfer);\n  } else {\n    return [\n      {\n        contractAddress: transfer.rawContract.address!,\n        tokenId: transfer.tokenId!,\n        tokenType:\n          transfer.category === AssetTransfersCategory.ERC721\n            ? NftTokenType.ERC721\n            : undefined\n      }\n    ];\n  }\n}\n\n/**\n * Flips the `omitMetadata` SDK parameter type to the `withMetadata` parameter\n * required by the Alchemy API. If `omitMetadata` is undefined, the SDK defaults\n * to including metadata.\n *\n * @internal\n */\nfunction omitMetadataToWithMetadata(\n  omitMetadata: boolean | undefined\n): boolean {\n  return omitMetadata === undefined ? true : !omitMetadata;\n}\n\nfunction parseReingestionState(reingestionState: string): RefreshState {\n  switch (reingestionState) {\n    case 'does_not_exist':\n      return RefreshState.DOES_NOT_EXIST;\n    case 'already_queued':\n      return RefreshState.ALREADY_QUEUED;\n    case 'in_progress':\n      return RefreshState.IN_PROGRESS;\n    case 'finished':\n      return RefreshState.FINISHED;\n    case 'queued':\n      return RefreshState.QUEUED;\n    case 'queue_failed':\n      return RefreshState.QUEUE_FAILED;\n    default:\n      throw new Error('Unknown reingestion state: ' + reingestionState);\n  }\n}\n\n/**\n * Interface for the `getNftsForNftContract` endpoint. The main difference is\n * that the endpoint has a `startToken` parameter, but the SDK standardizes all\n * pagination parameters to `pageKey`.\n *\n * @internal\n */\ninterface GetNftsForContractAlchemyParams {\n  contractAddress: string;\n  startToken?: string;\n  withMetadata: boolean;\n  limit?: number;\n  tokenUriTimeoutInMs?: number;\n}\n\n/**\n * Interface for the `getNfts` endpoint. The main difference is that the\n * endpoint has a `withMetadata` parameter, but the SDK exposes the parameter as\n * `omitMetadata`.\n *\n * @internal\n */\ninterface GetNftsAlchemyParams {\n  owner: string;\n  pageKey?: string;\n  contractAddresses?: string[];\n  /** @deprecated - Please use `excludeFilters` instead. */\n  filters?: string[];\n  excludeFilters?: NftFilters[];\n  includeFilters?: NftFilters[];\n  pageSize?: number;\n  withMetadata: boolean;\n  tokenUriTimeoutInMs?: number;\n  orderBy?: string;\n}\n\n/**\n * NftTokenTypes that are allowed as request inputs.\n *\n * @internal\n */\nexport type InputNftTokenType =\n  | NftTokenType.ERC1155\n  | NftTokenType.ERC721\n  | undefined;\n\n/**\n * Interface for the `getNftMetadata` endpoint.\n *\n * @internal\n */\ninterface GetNftMetadataParams {\n  contractAddress: string;\n  tokenId: string;\n  tokenType?: InputNftTokenType;\n  refreshCache?: boolean;\n  tokenUriTimeoutInMs?: number;\n}\n\n/**\n * Interface for the `isSpamContract` endpoint.\n *\n * @internal\n */\ninterface IsSpamContractParams {\n  contractAddress: string;\n}\n\n/**\n * Interface for the `getNftContractMetadata` endpoint.\n *\n * @internal\n */\ninterface GetContractMetadataParams {\n  contractAddress: string;\n}\n\n/**\n * Interface for the `getOwnersForNftContract` endpoint.\n *\n * @internal\n */\ninterface GetOwnersForNftContractAlchemyParams {\n  contractAddress: string;\n}\n\n/**\n * Interface for the `getOwnersForContract` endpoint.\n *\n * @internal\n */\ninterface GetContractsForOwnerParams {\n  owner: string;\n  pageKey?: string;\n  pageSize?: number;\n  includeFilters?: NftFilters[];\n  excludeFilters?: NftFilters[];\n  orderBy?: NftOrdering;\n}\n\n/**\n * Interface for the `getFloorPrice` endpoint.\n *\n * @internal\n */\ninterface GetFloorPriceParams {\n  contractAddress: string;\n}\n\n/**\n * Interface for the `getNftSales` endpoint.\n *\n * @internal\n */\ninterface GetNftSalesParams {\n  fromBlock?: number | 'latest';\n  toBlock?: number | 'latest';\n  order?: SortingOrder;\n  marketplace?: NftSaleMarketplace;\n  contractAddress?: string;\n  tokenId?: string;\n  sellerAddress?: string;\n  buyerAddress?: string;\n  taker?: NftSaleTakerType;\n  limit?: number;\n  pageKey?: string;\n}\n\n/**\n * Interface for the `computeRarity` endpoint.\n *\n * @internal\n */\ninterface ComputeRarityParams {\n  contractAddress: string;\n  tokenId: string;\n  refreshCache?: boolean;\n}\n\n/**\n * Interface for the `searchContractMetadata` endpoint.\n *\n * @internal\n */\ninterface SearchContractMetadataParams {\n  query: string;\n}\n\n/**\n * Interface for the `summarizeNFTAttributes` endpoint.\n *\n * @internal\n */\ninterface SummarizeNftAttributesParams {\n  contractAddress: string;\n  refreshCache?: boolean;\n}\n\ninterface ReingestContractParams {\n  contractAddress: string;\n}\n","import type { BigNumberish } from '@ethersproject/bignumber';\n\nimport {\n  checkNftOwnership,\n  computeRarity,\n  getContractMetadata,\n  getContractMetadataBatch,\n  getContractsForOwner,\n  getFloorPrice,\n  getMintedNfts,\n  getNftMetadata,\n  getNftMetadataBatch,\n  getNftSales,\n  getNftsForContract,\n  getNftsForContractIterator,\n  getNftsForOwner,\n  getNftsForOwnerIterator,\n  getOwnersForContract,\n  getOwnersForNft,\n  getSpamContracts,\n  getTransfersForContract,\n  getTransfersForOwner,\n  isSpamContract,\n  refreshContract,\n  refreshNftMetadata,\n  searchContractMetadata,\n  summarizeNftAttributes,\n  verifyNftOwnership\n} from '../internal/nft-api';\nimport {\n  GetBaseNftsForContractOptions,\n  GetBaseNftsForOwnerOptions,\n  GetContractsForOwnerOptions,\n  GetContractsForOwnerResponse,\n  GetFloorPriceResponse,\n  GetMintedNftsOptions,\n  GetNftMetadataOptions,\n  GetNftSalesOptions,\n  GetNftSalesOptionsByContractAddress,\n  GetNftSalesResponse,\n  GetNftsForContractOptions,\n  GetNftsForOwnerOptions,\n  GetOwnersForContractOptions,\n  GetOwnersForContractResponse,\n  GetOwnersForContractWithTokenBalancesOptions,\n  GetOwnersForContractWithTokenBalancesResponse,\n  GetOwnersForNftOptions,\n  GetOwnersForNftResponse,\n  GetTransfersForContractOptions,\n  GetTransfersForOwnerOptions,\n  GetTransfersForOwnerTransferType,\n  NftAttributeRarity,\n  NftAttributesResponse,\n  NftContractBaseNftsResponse,\n  NftContractNftsResponse,\n  NftMetadataBatchOptions,\n  NftMetadataBatchToken,\n  NftTokenType,\n  OwnedBaseNft,\n  OwnedBaseNftsResponse,\n  OwnedNft,\n  OwnedNftsResponse,\n  RefreshContractResult,\n  TransfersNftResponse\n} from '../types/types';\nimport { AlchemyConfig } from './alchemy-config';\nimport { BaseNft, Nft, NftContract } from './nft';\n\n/**\n * The NFT namespace contains all the functionality related to NFTs.\n *\n * Do not call this constructor directly. Instead, instantiate an Alchemy object\n * with `const alchemy = new Alchemy(config)` and then access the core namespace\n * via `alchemy.nft`.\n */\nexport class NftNamespace {\n  /** @internal */\n  constructor(private readonly config: AlchemyConfig) {}\n\n  /**\n   * Get the NFT metadata associated with the provided parameters.\n   *\n   * @param contractAddress - The contract address of the NFT.\n   * @param tokenId - Token id of the NFT.\n   * @param tokenType - Optionally specify the type of token to speed up the query.\n   * @param tokenUriTimeoutInMs - No set timeout by default - When metadata is\n   *   requested, this parameter is the timeout (in milliseconds) for the\n   *   website hosting the metadata to respond. If you want to only access the\n   *   cache and not live fetch any metadata for cache misses then set this value to 0.\n   * @public\n   * @deprecated Please use the method with the `options` overload. This method\n   * will be removed in a subsequent release.\n   */\n  getNftMetadata(\n    contractAddress: string,\n    tokenId: BigNumberish,\n    tokenType?: NftTokenType,\n    tokenUriTimeoutInMs?: number\n  ): Promise<Nft>;\n\n  /**\n   * Get the NFT metadata associated with the provided parameters.\n   *\n   * @param contractAddress - The contract address of the NFT.\n   * @param tokenId - Token id of the NFT.\n   * @param options - Options for the request.\n   * @public\n   */\n  getNftMetadata(\n    contractAddress: string,\n    tokenId: BigNumberish,\n    options?: GetNftMetadataOptions\n  ): Promise<Nft>;\n  getNftMetadata(\n    contractAddress: string,\n    tokenId: BigNumberish,\n    optionsOrTokenType?: GetNftMetadataOptions | NftTokenType,\n    tokenUriTimeoutInMs?: number\n  ): Promise<Nft> {\n    let options: GetNftMetadataOptions;\n    if (typeof optionsOrTokenType === 'object') {\n      options = {\n        tokenType: optionsOrTokenType.tokenType,\n        tokenUriTimeoutInMs: optionsOrTokenType.tokenUriTimeoutInMs,\n        refreshCache: optionsOrTokenType.refreshCache\n      };\n    } else {\n      options = {\n        tokenType: optionsOrTokenType,\n        tokenUriTimeoutInMs\n      };\n    }\n    return getNftMetadata(this.config, contractAddress, tokenId, options);\n  }\n\n  /**\n   * Gets the NFT metadata for multiple NFT tokens.\n   *\n   * @param tokens An array of NFT tokens to fetch metadata for.\n   * @param options Configuration options for making the request.\n   */\n  getNftMetadataBatch(\n    tokens: Array<NftMetadataBatchToken>,\n    options?: NftMetadataBatchOptions\n  ): Promise<Nft[]> {\n    return getNftMetadataBatch(this.config, tokens, options);\n  }\n\n  /**\n   * Get the NFT contract metadata associated with the provided parameters.\n   *\n   * @param contractAddress - The contract address of the NFT.\n   * @public\n   */\n  getContractMetadata(contractAddress: string): Promise<NftContract> {\n    return getContractMetadata(this.config, contractAddress);\n  }\n\n  /**\n   * Get the NFT contract metadata for multiple NFT contracts in a single request.\n   *\n   * @param contractAddresses - An array of contract addresses to fetch metadata for.\n   */\n  getContractMetadataBatch(\n    contractAddresses: string[]\n  ): Promise<NftContract[]> {\n    return getContractMetadataBatch(this.config, contractAddresses);\n  }\n\n  /**\n   * Fetches all NFTs for a given owner and yields them in an async iterable.\n   *\n   * This method returns the full NFT for the owner and pages through all page\n   * keys until all NFTs have been fetched.\n   *\n   * @param owner - The address of the owner.\n   * @param options - The optional parameters to use for the request.\n   * @public\n   */\n  getNftsForOwnerIterator(\n    owner: string,\n    options?: GetNftsForOwnerOptions\n  ): AsyncIterable<OwnedNft>;\n  /**\n   * Fetches all NFTs for a given owner and yields them in an async iterable.\n   *\n   * This method returns the base NFTs that omit the associated metadata and\n   * pages through all page keys until all NFTs have been fetched.\n   *\n   * @param owner - The address of the owner.\n   * @param options - The optional parameters to use for the request.\n   * @public\n   */\n  getNftsForOwnerIterator(\n    owner: string,\n    options?: GetBaseNftsForOwnerOptions\n  ): AsyncIterable<OwnedBaseNft>;\n  getNftsForOwnerIterator(\n    owner: string,\n    options?: GetNftsForOwnerOptions | GetBaseNftsForOwnerOptions\n  ): AsyncIterable<OwnedBaseNft | OwnedNft> {\n    return getNftsForOwnerIterator(this.config, owner, options);\n  }\n\n  /**\n   * Get all NFTs for an owner.\n   *\n   * This method returns the full NFTs in the contract. To get all NFTs without\n   * their associated metadata, use {@link GetBaseNftsForOwnerOptions}.\n   *\n   * @param owner - The address of the owner.\n   * @param options - The optional parameters to use for the request.\n   * @public\n   */\n  getNftsForOwner(\n    owner: string,\n    options?: GetNftsForOwnerOptions\n  ): Promise<OwnedNftsResponse>;\n  /**\n   * Get all base NFTs for an owner.\n   *\n   * This method returns the base NFTs that omit the associated metadata. To get\n   * all NFTs with their associated metadata, use {@link GetNftsForOwnerOptions}.\n   *\n   * @param owner - The address of the owner.\n   * @param options - The optional parameters to use for the request.\n   * @public\n   */\n  getNftsForOwner(\n    owner: string,\n    options?: GetBaseNftsForOwnerOptions\n  ): Promise<OwnedBaseNftsResponse>;\n  getNftsForOwner(\n    owner: string,\n    options?: GetNftsForOwnerOptions | GetBaseNftsForOwnerOptions\n  ): Promise<OwnedNftsResponse | OwnedBaseNftsResponse> {\n    return getNftsForOwner(this.config, owner, options);\n  }\n\n  /**\n   * Get all NFTs for a given contract address.\n   *\n   * This method returns the full NFTs in the contract. To get all NFTs without\n   * their associated metadata, use {@link GetBaseNftsForContractOptions}.\n   *\n   * @param contractAddress - The contract address of the NFT contract.\n   * @param options - The parameters to use for the request. or\n   *   {@link NftContractNftsResponse} response.\n   * @beta\n   */\n  getNftsForContract(\n    contractAddress: string,\n    options?: GetNftsForContractOptions\n  ): Promise<NftContractNftsResponse>;\n  /**\n   * Get all base NFTs for a given contract address.\n   *\n   * This method returns the base NFTs that omit the associated metadata. To get\n   * all NFTs with their associated metadata, use {@link GetNftsForContractOptions}.\n   *\n   * @param contractAddress - The contract address of the NFT contract.\n   * @param options - The optional parameters to use for the request.\n   * @beta\n   */\n  getNftsForContract(\n    contractAddress: string,\n    options?: GetBaseNftsForContractOptions\n  ): Promise<NftContractBaseNftsResponse>;\n  getNftsForContract(\n    contractAddress: string,\n    options?: GetBaseNftsForContractOptions | GetNftsForContractOptions\n  ): Promise<NftContractNftsResponse | NftContractBaseNftsResponse> {\n    return getNftsForContract(this.config, contractAddress, options);\n  }\n\n  /**\n   * Fetches all NFTs for a given contract address and yields them in an async iterable.\n   *\n   * This method returns the full NFTs in the contract and pages through all\n   * page keys until all NFTs have been fetched. To get all NFTs without their\n   * associated metadata, use {@link GetBaseNftsForContractOptions}.\n   *\n   * @param contractAddress - The contract address of the NFT contract.\n   * @param options - The optional parameters to use for the request.\n   * @beta\n   */\n  getNftsForContractIterator(\n    contractAddress: string,\n    options?: GetNftsForContractOptions\n  ): AsyncIterable<Nft>;\n  /**\n   * Fetches all base NFTs for a given contract address and yields them in an\n   * async iterable.\n   *\n   * This method returns the base NFTs that omit the associated metadata and\n   * pages through all page keys until all NFTs have been fetched. To get all\n   * NFTs with their associated metadata, use {@link GetNftsForContractOptions}.\n   *\n   * @param contractAddress - The contract address of the NFT contract.\n   * @param options - The optional parameters to use for the request.\n   * @beta\n   */\n  getNftsForContractIterator(\n    contractAddress: string,\n    options?: GetBaseNftsForContractOptions\n  ): AsyncIterable<BaseNft>;\n  getNftsForContractIterator(\n    contractAddress: string,\n    options?: GetBaseNftsForContractOptions | GetNftsForContractOptions\n  ): AsyncIterable<BaseNft | Nft> {\n    return getNftsForContractIterator(this.config, contractAddress, options);\n  }\n\n  /**\n   * Gets all the owners for a given NFT contract along with the token balance.\n   *\n   * @param contractAddress - The NFT contract to get the owners for.\n   * @param options Optional parameters to use for the request.\n   * @public\n   */\n  getOwnersForContract(\n    contractAddress: string,\n    options: GetOwnersForContractWithTokenBalancesOptions\n  ): Promise<GetOwnersForContractWithTokenBalancesResponse>;\n\n  /**\n   * Gets all the owners for a given NFT contract.\n   *\n   * Note that token balances are omitted by default. To include token balances\n   * for each owner, use {@link GetOwnersForContractWithTokenBalancesOptions},\n   * which has the `withTokenBalances` field set to `true`.\n   *\n   * @param contractAddress - The NFT contract to get the owners for.\n   * @param options Optional parameters to use for the request.\n   * @public\n   */\n  getOwnersForContract(\n    contractAddress: string,\n    options?: GetOwnersForContractOptions\n  ): Promise<GetOwnersForContractResponse>;\n  getOwnersForContract(\n    contractAddress: string,\n    options?:\n      | GetOwnersForContractOptions\n      | GetOwnersForContractWithTokenBalancesOptions\n  ): Promise<\n    GetOwnersForContractResponse | GetOwnersForContractWithTokenBalancesResponse\n  > {\n    return getOwnersForContract(this.config, contractAddress, options);\n  }\n\n  /**\n   * Gets all the owners for a given NFT contract address and token ID.\n   *\n   * @param contractAddress - The NFT contract address.\n   * @param tokenId - Token id of the NFT.\n   * @param options - Optional parameters to use for the request.\n   * @beta\n   */\n  getOwnersForNft(\n    contractAddress: string,\n    tokenId: BigNumberish,\n    options?: GetOwnersForNftOptions\n  ): Promise<GetOwnersForNftResponse> {\n    return getOwnersForNft(this.config, contractAddress, tokenId, options);\n  }\n\n  /**\n   * Gets all NFT contracts held by the specified owner address.\n   *\n   * @param owner - Address for NFT owner (can be in ENS format!).\n   * @param options - The optional parameters to use for the request.\n   * @public\n   */\n  getContractsForOwner(\n    owner: string,\n    options?: GetContractsForOwnerOptions\n  ): Promise<GetContractsForOwnerResponse> {\n    return getContractsForOwner(this.config, owner, options);\n  }\n\n  /**\n   * Gets all NFT transfers for a given owner's address.\n   *\n   * @param owner The owner to get transfers for.\n   * @param category Whether to get transfers to or from the owner address.\n   * @param options Additional options for the request.\n   */\n  getTransfersForOwner(\n    owner: string,\n    category: GetTransfersForOwnerTransferType,\n    options?: GetTransfersForOwnerOptions\n  ): Promise<TransfersNftResponse> {\n    return getTransfersForOwner(this.config, owner, category, options);\n  }\n\n  /**\n   * Gets all NFT transfers for a given NFT contract address.\n   *\n   * Defaults to all transfers for the contract. To get transfers for a specific\n   * block range, use {@link GetTransfersForContractOptions}.\n   *\n   * @param contract The NFT contract to get transfers for.\n   * @param options Additional options for the request.\n   */\n  getTransfersForContract(\n    contract: string,\n    options?: GetTransfersForContractOptions\n  ): Promise<TransfersNftResponse> {\n    return getTransfersForContract(this.config, contract, options);\n  }\n\n  /**\n   * Get all the NFTs minted by a specified owner address.\n   *\n   * @param owner - Address for the NFT owner (can be in ENS format).\n   * @param options - The optional parameters to use for the request.\n   */\n  async getMintedNfts(\n    owner: string,\n    options?: GetMintedNftsOptions\n  ): Promise<TransfersNftResponse> {\n    return getMintedNfts(this.config, owner, options);\n  }\n\n  /**\n   * DEPRECATED - Checks that the provided owner address owns one of more of the\n   * provided NFTs.\n   *\n   * @deprecated - Use {@link verifyNftOwnership} instead. This method will be\n   *   removed in a future release.\n   * @param owner - The owner address to check.\n   * @param contractAddresses - An array of NFT contract addresses to check ownership for.\n   */\n  checkNftOwnership(\n    owner: string,\n    contractAddresses: string[]\n  ): Promise<boolean> {\n    return checkNftOwnership(this.config, owner, contractAddresses);\n  }\n\n  /**\n   * Checks that the provided owner address owns one of more of the provided\n   * NFT. Returns a boolean indicating whether the owner address owns the provided NFT.\n   *\n   * @param owner - The owner address to check.\n   * @param contractAddress - An NFT contract address to check ownership for.\n   */\n  verifyNftOwnership(owner: string, contractAddress: string): Promise<boolean>;\n\n  /**\n   * Checks which of the provided NFTs the owner address owns. Returns a map of\n   * contract address to a boolean indicating whether the owner address owns the NFT.\n   *\n   * @param owner - The owner address to check.\n   * @param contractAddresses - An array NFT contract address to check ownership for.\n   */\n  verifyNftOwnership(\n    owner: string,\n    contractAddresses: string[]\n  ): Promise<{ [contractAddress: string]: boolean }>;\n  verifyNftOwnership(\n    owner: string,\n    contractAddress: string | string[]\n  ): Promise<boolean | { [contractAddress: string]: boolean }> {\n    return verifyNftOwnership(this.config, owner, contractAddress);\n  }\n\n  /**\n   * Returns whether a contract is marked as spam or not by Alchemy. For more\n   * information on how we classify spam, go to our NFT API FAQ at\n   * https://docs.alchemy.com/alchemy/enhanced-apis/nft-api/nft-api-faq#nft-spam-classification.\n   *\n   * @param contractAddress - The contract address to check.\n   * @beta\n   */\n  isSpamContract(contractAddress: string): Promise<boolean> {\n    return isSpamContract(this.config, contractAddress);\n  }\n\n  /**\n   * Returns a list of all spam contracts marked by Alchemy. For details on how\n   * Alchemy marks spam contracts, go to\n   * https://docs.alchemy.com/alchemy/enhanced-apis/nft-api/nft-api-faq#nft-spam-classification.\n   *\n   * @beta\n   */\n  getSpamContracts(): Promise<string[]> {\n    return getSpamContracts(this.config);\n  }\n\n  /**\n   * Returns the floor prices of a NFT contract by marketplace.\n   *\n   * @param contractAddress - The contract address for the NFT collection.\n   * @beta\n   */\n  getFloorPrice(contractAddress: string): Promise<GetFloorPriceResponse> {\n    return getFloorPrice(this.config, contractAddress);\n  }\n\n  /**\n   * Returns NFT sales that have happened through on-chain marketplaces.\n   *\n   * @param options - The optional parameters to use for the request.\n   * @beta\n   */\n  getNftSales(options?: GetNftSalesOptions): Promise<GetNftSalesResponse>;\n  getNftSales(\n    options?: GetNftSalesOptionsByContractAddress\n  ): Promise<GetNftSalesResponse>;\n  getNftSales(\n    options?: GetNftSalesOptions | GetNftSalesOptionsByContractAddress\n  ): Promise<GetNftSalesResponse> {\n    return getNftSales(this.config, options);\n  }\n\n  /**\n   * Get the rarity of each attribute of an NFT.\n   *\n   * @param contractAddress - Contract address for the NFT collection.\n   * @param tokenId - Token id of the NFT.\n   * @param refreshCache - If true, bypass cache and recompute rarity snapshot.\n   */\n  computeRarity(\n    contractAddress: string,\n    tokenId: BigNumberish,\n    refreshCache?: boolean\n  ): Promise<NftAttributeRarity[]> {\n    return computeRarity(this.config, contractAddress, tokenId, refreshCache);\n  }\n\n  /**\n   * Search for a keyword across metadata of all ERC-721 and ERC-1155 smart contracts.\n   *\n   * @param query - The search string that you want to search for in contract metadata.\n   */\n  searchContractMetadata(query: string): Promise<NftContract[]> {\n    return searchContractMetadata(this.config, query);\n  }\n\n  /**\n   * Get a summary of attribute prevalence for an NFT collection.\n   *\n   * @param contractAddress - Contract address for the NFT collection.\n   * @param refreshCache - If true, bypass cache and recompute rarity snapshot.\n   */\n  summarizeNftAttributes(\n    contractAddress: string,\n    refreshCache?: boolean\n  ): Promise<NftAttributesResponse> {\n    return summarizeNftAttributes(this.config, contractAddress, refreshCache);\n  }\n\n  /**\n   * Refreshes the cached metadata for a provided NFT contract address and token\n   * id. Returns a boolean value indicating whether the metadata was refreshed.\n   *\n   * This method is useful when you want to refresh the metadata for a NFT that\n   * has been updated since the last time it was fetched. Note that the backend\n   * only allows one refresh per token every 15 minutes, globally for all users.\n   * The last refresh time for an NFT can be accessed on the\n   * {@link Nft.timeLastUpdated} field.\n   *\n   * To trigger a refresh for all NFTs in a contract, use {@link refreshContract} instead.\n   *\n   * @param contractAddress - The contract address of the NFT.\n   * @param tokenId - The token id of the NFT.\n   */\n  refreshNftMetadata(\n    contractAddress: string,\n    tokenId: BigNumberish\n  ): Promise<boolean> {\n    return refreshNftMetadata(this.config, contractAddress, tokenId);\n  }\n\n  /**\n   * Triggers a metadata refresh all NFTs in the provided contract address. This\n   * method is useful after an NFT collection is revealed.\n   *\n   * Refreshes are queued on the Alchemy backend and may take time to fully\n   * process. To refresh the metadata for a specific token, use the\n   * {@link refreshNftMetadata} method instead.\n   *\n   * @param contractAddress - The contract address of the NFT collection.\n   * @beta\n   */\n  refreshContract(contractAddress: string): Promise<RefreshContractResult> {\n    return refreshContract(this.config, contractAddress);\n  }\n}\n","import { AxiosRequestConfig, Method } from 'axios';\n\nimport { BigNumber } from '@ethersproject/bignumber';\n\nimport { requestHttpWithBackoff } from '../internal/dispatch';\nimport {\n  RawAddressActivityResponse,\n  RawCreateWebhookResponse,\n  RawCustomGraphqlWebhookConfig,\n  RawGetAllWebhooksResponse,\n  RawNftFilterParam,\n  RawNftFiltersResponse,\n  RawWebhook\n} from '../internal/raw-interfaces';\nimport {\n  AddressActivityResponse,\n  AddressActivityWebhook,\n  AddressWebhookParams,\n  AddressWebhookUpdate,\n  CustomGraphqlWebhook,\n  CustomGraphqlWebhookConfig,\n  CustomGraphqlWebhookParams,\n  CustomGraphqlWebhookUpdate,\n  DroppedTransactionWebhook,\n  GetAddressesOptions,\n  GetAllWebhooksResponse,\n  MinedTransactionWebhook,\n  Network,\n  NftActivityWebhook,\n  NftFilter,\n  NftFiltersResponse,\n  NftMetadataUpdateWebhook,\n  NftMetadataWebhookUpdate,\n  NftWebhookParams,\n  NftWebhookUpdate,\n  TransactionWebhookParams,\n  Webhook,\n  WebhookType,\n  WebhookVersion\n} from '../types/types';\nimport { AlchemyApiType } from '../util/const';\nimport { AlchemyConfig } from './alchemy-config';\n\n/**\n * The Notify namespace contains methods used for creating, reading, updating,\n * and deleting webhooks in the Notify API.\n *\n * To use the methods in the API, you must provide your team's auth token in the\n * {@link AlchemySettings.authToken} field when configuring\n * {@link AlchemySettings}. The auth token can be found in the Alchemy Dashboard\n * on the Notify tab.\n *\n * Note that not all networks are supported in the Notify API. Please consult\n * the documentation for which networks are supported.\n *\n * Do not call this constructor directly. Instead, instantiate an Alchemy object\n * with `const alchemy = new Alchemy(config)` and then access the notify\n * namespace via `alchemy.notify`.\n */\nexport class NotifyNamespace {\n  /** @internal */\n  constructor(private readonly config: AlchemyConfig) {}\n\n  /**\n   * Get all webhooks on your team.\n   *\n   * The team is determined by the `authToken` provided into the {@link AlchemySettings}\n   * object when creating a new {@link Alchemy} instance.\n   *\n   * This method returns a response object containing all the webhooks\n   */\n  async getAllWebhooks(): Promise<GetAllWebhooksResponse> {\n    this.verifyConfig();\n    const response = await this.sendWebhookRequest<RawGetAllWebhooksResponse>(\n      'team-webhooks',\n      'getAllWebhooks',\n      {}\n    );\n    return {\n      webhooks: parseRawWebhookResponse(response),\n      totalCount: response.data.length\n    };\n  }\n\n  /**\n   * Get all addresses tracked for the provided {@link AddressActivityWebhook}.\n   *\n   * @param addressWebhook The Address Activity webhook.\n   * @param options Pagination options when fetching addresses.\n   */\n  getAddresses(\n    addressWebhook: AddressActivityWebhook,\n    options?: GetAddressesOptions\n  ): Promise<AddressActivityResponse>;\n\n  /**\n   * Get all addresses tracked for the provided {@link AddressActivityWebhook}.\n   *\n   * @param webhookId The id of the address activity webhook. Passing in an id\n   *   of a non-address-activity webhook will result in a response object with\n   *   no addresses.\n   * @param options Pagination options when fetching addresses.\n   */\n  getAddresses(\n    webhookId: string,\n    options?: GetAddressesOptions\n  ): Promise<AddressActivityResponse>;\n  async getAddresses(\n    webhookOrId: AddressActivityWebhook | string,\n    options?: GetAddressesOptions\n  ): Promise<AddressActivityResponse> {\n    this.verifyConfig();\n    const webhookId =\n      typeof webhookOrId === 'string' ? webhookOrId : webhookOrId.id;\n    const response = await this.sendWebhookRequest<RawAddressActivityResponse>(\n      'webhook-addresses',\n      'getAddresses',\n      {\n        webhook_id: webhookId,\n        limit: options?.limit,\n        after: options?.pageKey\n      }\n    );\n    return parseRawAddressActivityResponse(response);\n  }\n\n  /**\n   * Get the graphql query used for the provided {@link CustomGraphqlWebhook}.\n   *\n   * @param customGraphqlWebhook The webhook to get the graphql query for.\n   */\n  getGraphqlQuery(\n    customGraphqlWebhook: CustomGraphqlWebhook\n  ): Promise<CustomGraphqlWebhookConfig>;\n\n  /**\n   * Get the graphql query used for the provided {@link CustomGraphqlWebhook}.\n   *\n   * @param webhookId The id of the custom webhook. Passing in an id\n   *   of a non-custom webhook will result in a response object with\n   *   no graphql query.\n   */\n  getGraphqlQuery(webhookId: string): Promise<CustomGraphqlWebhookConfig>;\n  async getGraphqlQuery(\n    webhookOrId: CustomGraphqlWebhook | string\n  ): Promise<CustomGraphqlWebhookConfig> {\n    this.verifyConfig();\n    const webhookId =\n      typeof webhookOrId === 'string' ? webhookOrId : webhookOrId.id;\n    const response =\n      await this.sendWebhookRequest<RawCustomGraphqlWebhookConfig>(\n        'dashboard-webhook-graphql-query',\n        'getGraphqlQuery',\n        {\n          webhook_id: webhookId\n        }\n      );\n    return parseRawCustomGraphqlWebhookResponse(response);\n  }\n\n  /**\n   * Get all NFTs tracked for the provided {@link NftActivityWebhook}.\n   *\n   * @param nftWebhook The NFT Activity webhook.\n   * @param options Pagination options when fetching NFT filters.\n   */\n  getNftFilters(\n    nftWebhook: NftActivityWebhook,\n    options?: GetAddressesOptions\n  ): Promise<NftFiltersResponse>;\n\n  /**\n   * Get all NFT filters tracked for the provided {@link NftActivityWebhook}.\n   *\n   * @param webhookId The id of the NFT activity webhook. Passing in an\n   *   incorrect id of a non-NFT webhook will result in a response object with\n   *   no filters.\n   * @param options Pagination options when fetching nft filters.\n   */\n  getNftFilters(\n    webhookId: string,\n    options?: GetAddressesOptions\n  ): Promise<NftFiltersResponse>;\n  async getNftFilters(\n    webhookOrId: NftActivityWebhook | string,\n    options?: GetAddressesOptions\n  ): Promise<NftFiltersResponse> {\n    this.verifyConfig();\n    const webhookId =\n      typeof webhookOrId === 'string' ? webhookOrId : webhookOrId.id;\n    const response = await this.sendWebhookRequest<RawNftFiltersResponse>(\n      'webhook-nft-filters',\n      'getNftFilters',\n      {\n        webhook_id: webhookId,\n        limit: options?.limit,\n        after: options?.pageKey\n      }\n    );\n    return parseRawNftFiltersResponse(response);\n  }\n\n  /**\n   * Update a {@link NftActivityWebhook}'s active status or NFT filters.\n   *\n   * @param nftWebhook The NFT activity webhook to update.\n   * @param update Object containing the update.\n   */\n  updateWebhook(\n    nftWebhook: NftActivityWebhook,\n    update: NftWebhookUpdate\n  ): Promise<void>;\n\n  /**\n   * Update a {@link NftActivityWebhook}'s active status or NFT filters.\n   *\n   * @param nftWebhookId The id of the NFT activity webhook.\n   * @param update Object containing the update.\n   */\n  updateWebhook(nftWebhookId: string, update: NftWebhookUpdate): Promise<void>;\n\n  /**\n   * Update a {@link NftMetadataUpdateWebhook}'s active status or NFT filters.\n   *\n   * @param nftMetadataWebhookId The id of the NFT activity webhook.\n   * @param update Object containing the update.\n   */\n  updateWebhook(\n    nftMetadataWebhookId: string,\n    update: NftMetadataWebhookUpdate\n  ): Promise<void>;\n\n  /**\n   * Update a {@link CustomGraphqlWebhook}'s active status.\n   * The graphql query associated with the webhook is immutable.\n   *\n   * @param customGraphqlWebhookId The id of the custom webhook.\n   * @param update Object containing the update.\n   */\n  updateWebhook(\n    customGraphqlWebhookId: string,\n    update: CustomGraphqlWebhookUpdate\n  ): Promise<void>;\n\n  /**\n   * Update a {@link AddressActivityWebhook}'s active status or addresses.\n   *\n   * @param addressWebhook The address activity webhook to update.\n   * @param update Object containing the update.\n   */\n  updateWebhook(\n    addressWebhook: AddressActivityWebhook,\n    update: AddressWebhookUpdate\n  ): Promise<void>;\n\n  /**\n   * Update a {@link AddressActivityWebhook}'s active status or addresses.\n   *\n   * @param addressWebhookId The id of the address activity webhook.\n   * @param update Object containing the update.\n   */\n  updateWebhook(\n    addressWebhookId: string,\n    update: AddressWebhookUpdate\n  ): Promise<void>;\n  async updateWebhook(\n    webhookOrId: NftActivityWebhook | AddressActivityWebhook | string,\n    update:\n      | NftWebhookUpdate\n      | AddressWebhookUpdate\n      | NftMetadataWebhookUpdate\n      | CustomGraphqlWebhookUpdate\n  ): Promise<void> {\n    const webhookId =\n      typeof webhookOrId === 'string' ? webhookOrId : webhookOrId.id;\n    let restApiName;\n    let methodName;\n    let method: Method;\n    let data;\n    if ('isActive' in update) {\n      restApiName = 'update-webhook';\n      methodName = 'updateWebhook';\n      method = 'PUT';\n      data = {\n        webhook_id: webhookId,\n        is_active: update.isActive\n      };\n    } else if ('addFilters' in update || 'removeFilters' in update) {\n      restApiName = 'update-webhook-nft-filters';\n      methodName = 'updateWebhookNftFilters';\n      method = 'PATCH';\n      data = {\n        webhook_id: webhookId,\n        nft_filters_to_add: update.addFilters\n          ? update.addFilters.map(nftFilterToParam)\n          : [],\n        nft_filters_to_remove: update.removeFilters\n          ? update.removeFilters.map(nftFilterToParam)\n          : []\n      };\n    } else if (\n      'addMetadataFilters' in update ||\n      'removeMetadataFilters' in update\n    ) {\n      restApiName = 'update-webhook-nft-metadata-filters';\n      methodName = 'updateWebhookNftMetadataFilters';\n      method = 'PATCH';\n      data = {\n        webhook_id: webhookId,\n        nft_metadata_filters_to_add: update.addMetadataFilters\n          ? update.addMetadataFilters.map(nftFilterToParam)\n          : [],\n        nft_metadata_filters_to_remove: update.removeMetadataFilters\n          ? update.removeMetadataFilters.map(nftFilterToParam)\n          : []\n      };\n    } else if ('addAddresses' in update || 'removeAddresses' in update) {\n      restApiName = 'update-webhook-addresses';\n      methodName = 'webhook:updateWebhookAddresses';\n      method = 'PATCH';\n      data = {\n        webhook_id: webhookId,\n        addresses_to_add: await this.resolveAddresses(update.addAddresses),\n        addresses_to_remove: await this.resolveAddresses(update.removeAddresses)\n      };\n    } else if ('newAddresses' in update) {\n      restApiName = 'update-webhook-addresses';\n      methodName = 'webhook:updateWebhookAddress';\n      method = 'PUT';\n      data = {\n        webhook_id: webhookId,\n        addresses: await this.resolveAddresses(update.newAddresses)\n      };\n    } else {\n      throw new Error('Invalid `update` param passed into `updateWebhook`');\n    }\n\n    await this.sendWebhookRequest(\n      restApiName,\n      methodName,\n      {},\n      {\n        method,\n        data\n      }\n    );\n  }\n\n  /**\n   * Create a new {@link MinedTransactionWebhook} to track mined transactions\n   * sent by the app associated with the app id.\n   *\n   * Note that the webhook will be created in the app network of the provided app id.\n   *\n   * @param url The URL that the webhook should send events to.\n   * @param type The type of webhook to create.\n   * @param params Parameters object containing the app id.\n   */\n  // TODO(webhook): Automatically populate app id from api key.\n  createWebhook(\n    url: string,\n    type: WebhookType.MINED_TRANSACTION,\n    params: TransactionWebhookParams\n  ): Promise<MinedTransactionWebhook>;\n\n  /**\n   * Create a new {@link DroppedTransactionWebhook} to track dropped transactions\n   * sent by the app associated with the app id.\n   *\n   * Note that the webhook will be created in the app network of the provided app id.\n   *\n   * @param url The URL that the webhook should send events to.\n   * @param type The type of webhook to create.\n   * @param params Parameters object containing the app id.\n   */\n  // TODO(webhook): Automatically populate app id from api key.\n  createWebhook(\n    url: string,\n    type: WebhookType.DROPPED_TRANSACTION,\n    params: TransactionWebhookParams\n  ): Promise<DroppedTransactionWebhook>;\n\n  /**\n   * Create a new {@link NftActivityWebhook} to track NFT transfers.\n   *\n   * @param url The URL that the webhook should send events to.\n   * @param type The type of webhook to create.\n   * @param params Parameters object containing the NFTs to track and the\n   *   network the webhook should be created on.\n   */\n  createWebhook(\n    url: string,\n    type: WebhookType.NFT_ACTIVITY,\n    params: NftWebhookParams\n  ): Promise<NftActivityWebhook>;\n\n  createWebhook(\n    url: string,\n    type: WebhookType.NFT_METADATA_UPDATE,\n    params: NftWebhookParams\n  ): Promise<NftMetadataUpdateWebhook>;\n\n  /**\n   * Create a new {@link CustomGraphqlWebhook} to track any event on every block.\n   *\n   * @param url The URL that the webhook should send events to.\n   * @param type The type of webhook to create.\n   * @param params Parameters object containing the graphql query to be executed\n   * on every block\n   */\n  createWebhook(\n    url: string,\n    type: WebhookType.GRAPHQL,\n    params: CustomGraphqlWebhookParams\n  ): Promise<CustomGraphqlWebhook>;\n\n  /**\n   * Create a new {@link AddressActivityWebhook} to track address activity.\n   *\n   * @param url The URL that the webhook should send events to.\n   * @param type The type of webhook to create.\n   * @param params Parameters object containing the addresses to track and the\n   *   network the webhook should be created on.\n   */\n  createWebhook(\n    url: string,\n    type: WebhookType.ADDRESS_ACTIVITY,\n    params: AddressWebhookParams\n  ): Promise<AddressActivityWebhook>;\n  async createWebhook(\n    url: string,\n    type: WebhookType,\n    params:\n      | NftWebhookParams\n      | AddressWebhookParams\n      | TransactionWebhookParams\n      | CustomGraphqlWebhookParams\n  ): Promise<\n    | MinedTransactionWebhook\n    | DroppedTransactionWebhook\n    | NftActivityWebhook\n    | AddressActivityWebhook\n    | NftMetadataUpdateWebhook\n    | CustomGraphqlWebhook\n  > {\n    let appId;\n    if (\n      type === WebhookType.MINED_TRANSACTION ||\n      type === WebhookType.DROPPED_TRANSACTION\n    ) {\n      if (!('appId' in params)) {\n        throw new Error('Transaction Webhooks require an app id.');\n      }\n      appId = params.appId;\n    }\n\n    let network = NETWORK_TO_WEBHOOK_NETWORK.get(this.config.network);\n    let nftFilterObj;\n    let addresses;\n    let graphqlQuery;\n    if (\n      type === WebhookType.NFT_ACTIVITY ||\n      type === WebhookType.NFT_METADATA_UPDATE\n    ) {\n      if (!('filters' in params) || params.filters.length === 0) {\n        throw new Error(\n          'Nft Activity Webhooks require a non-empty array input.'\n        );\n      }\n      network = params.network\n        ? NETWORK_TO_WEBHOOK_NETWORK.get(params.network)\n        : network;\n      const filters = (params.filters as NftFilter[]).map(filter =>\n        filter.tokenId\n          ? {\n              contract_address: filter.contractAddress,\n              token_id: BigNumber.from(filter.tokenId).toString()\n            }\n          : {\n              contract_address: filter.contractAddress\n            }\n      );\n      nftFilterObj =\n        type === WebhookType.NFT_ACTIVITY\n          ? { nft_filters: filters }\n          : { nft_metadata_filters: filters };\n    } else if (type === WebhookType.ADDRESS_ACTIVITY) {\n      if (\n        params === undefined ||\n        !('addresses' in params) ||\n        params.addresses.length === 0\n      ) {\n        throw new Error(\n          'Address Activity Webhooks require a non-empty array input.'\n        );\n      }\n      network = params.network\n        ? NETWORK_TO_WEBHOOK_NETWORK.get(params.network)\n        : network;\n      addresses = await this.resolveAddresses(params.addresses);\n    } else if (type == WebhookType.GRAPHQL) {\n      if (\n        params === undefined ||\n        !('graphqlQuery' in params) ||\n        params.graphqlQuery.length === 0\n      ) {\n        throw new Error('Custom Webhooks require a non-empty graphql query.');\n      }\n      network = params.network\n        ? NETWORK_TO_WEBHOOK_NETWORK.get(params.network)\n        : network;\n      graphqlQuery = params.graphqlQuery;\n    }\n\n    const data = {\n      network,\n      webhook_type: type,\n      webhook_url: url,\n      ...(appId && { app_id: appId }),\n\n      // Only include the filters/addresses in the final response if they're defined\n      ...nftFilterObj,\n      ...(addresses && { addresses }),\n      ...(graphqlQuery && { graphql_query: graphqlQuery })\n    };\n\n    const response = await this.sendWebhookRequest<RawCreateWebhookResponse>(\n      'create-webhook',\n      'createWebhook',\n      {},\n      {\n        method: 'POST',\n        data\n      }\n    );\n\n    return parseRawWebhook(response.data);\n  }\n\n  /**\n   * Delete the provided webhook.\n   *\n   * @param webhook The webhook to delete.\n   */\n  deleteWebhook(webhook: Webhook): Promise<void>;\n\n  /**\n   * Delete the provided webhook.\n   *\n   * @param webhookId The id of the webhook to delete.\n   */\n  deleteWebhook(webhookId: string): Promise<void>;\n  async deleteWebhook(webhookOrId: Webhook | string): Promise<void> {\n    this.verifyConfig();\n    const webhookId =\n      typeof webhookOrId === 'string' ? webhookOrId : webhookOrId.id;\n    const response = await this.sendWebhookRequest<RawNftFiltersResponse>(\n      'delete-webhook',\n      'deleteWebhook',\n      {\n        webhook_id: webhookId\n      },\n      {\n        method: 'DELETE'\n      }\n    );\n\n    if ('message' in response) {\n      throw new Error(\n        `Webhook not found. Failed to delete webhook: ${webhookId}`\n      );\n    }\n  }\n\n  private verifyConfig() {\n    if (this.config.authToken === undefined) {\n      throw new Error(\n        'Using the Notify API requires setting the Alchemy Auth Token in ' +\n          'the settings object when initializing Alchemy.'\n      );\n    }\n  }\n\n  private sendWebhookRequest<Response>(\n    restApiName: string,\n    methodName: string,\n    params: {},\n    overrides?: AxiosRequestConfig\n  ): Promise<Response> {\n    return requestHttpWithBackoff(\n      this.config,\n      AlchemyApiType.WEBHOOK,\n      restApiName,\n      methodName,\n      params,\n      {\n        ...overrides,\n        headers: {\n          'X-Alchemy-Token': this.config.authToken!,\n          ...overrides?.headers\n        }\n      }\n    );\n  }\n\n  /** Resolves ENS addresses to the raw address.\n   * @internal */\n  private async resolveAddresses(\n    addresses: string[] | undefined\n  ): Promise<string[]> {\n    if (addresses === undefined) {\n      return [];\n    }\n    const resolvedAddresses: string[] = [];\n    const provider = await this.config.getProvider();\n    for (const address of addresses) {\n      const rawAddress = await provider.resolveName(address);\n      if (rawAddress === null) {\n        throw new Error(`Unable to resolve the ENS address: ${address}`);\n      }\n      resolvedAddresses.push(rawAddress);\n    }\n\n    return resolvedAddresses;\n  }\n}\n\n/**\n * Mapping of webhook network representations to the SDK's network representation.\n *\n * @internal\n */\nconst WEBHOOK_NETWORK_TO_NETWORK: { [key: string]: Network } = {\n  ETH_MAINNET: Network.ETH_MAINNET,\n  ETH_GOERLI: Network.ETH_GOERLI,\n  ETH_SEPOLIA: Network.ETH_SEPOLIA,\n  ETH_ROPSTEN: Network.ETH_ROPSTEN,\n  ETH_RINKEBY: Network.ETH_RINKEBY,\n  ETH_KOVAN: Network.ETH_KOVAN,\n  MATIC_MAINNET: Network.MATIC_MAINNET,\n  MATIC_MUMBAI: Network.MATIC_MUMBAI,\n  ARB_MAINNET: Network.ARB_MAINNET,\n  ARB_GOERLI: Network.ARB_GOERLI,\n  ARB_RINKEBY: Network.ARB_RINKEBY,\n  OPT_MAINNET: Network.OPT_MAINNET,\n  OPT_GOERLI: Network.OPT_GOERLI,\n  OPT_KOVAN: Network.OPT_KOVAN\n};\n\n/** Mapping of the SDK's network representation the webhook API's network representation. */\nconst NETWORK_TO_WEBHOOK_NETWORK: Map<Network, string> = Object.keys(\n  Network\n).reduce((map: Map<Network, string>, key) => {\n  if (key in WEBHOOK_NETWORK_TO_NETWORK) {\n    map.set(WEBHOOK_NETWORK_TO_NETWORK[key], key);\n  }\n  return map;\n}, new Map());\n\nfunction parseRawWebhookResponse(\n  response: RawGetAllWebhooksResponse\n): Webhook[] {\n  return response.data.map(parseRawWebhook);\n}\n\nfunction parseRawWebhook(rawWebhook: RawWebhook): Webhook {\n  return {\n    id: rawWebhook.id,\n    network: WEBHOOK_NETWORK_TO_NETWORK[rawWebhook.network],\n    type: rawWebhook.webhook_type as WebhookType,\n    url: rawWebhook.webhook_url,\n    isActive: rawWebhook.is_active,\n    timeCreated: new Date(rawWebhook.time_created).toISOString(),\n    signingKey: rawWebhook.signing_key,\n    version: rawWebhook.version as WebhookVersion,\n    // Only include the appId in the final response if it's defined\n    ...(rawWebhook.app_id !== undefined && { appId: rawWebhook.app_id })\n  };\n}\n\nfunction parseRawAddressActivityResponse(\n  response: RawAddressActivityResponse\n): AddressActivityResponse {\n  return {\n    addresses: response.data,\n    totalCount: response.pagination.total_count,\n    pageKey: response.pagination.cursors.after\n  };\n}\n\nfunction parseRawCustomGraphqlWebhookResponse(\n  response: RawCustomGraphqlWebhookConfig\n): CustomGraphqlWebhookConfig {\n  return {\n    graphqlQuery: response.data.graphql_query\n  };\n}\n\nfunction parseRawNftFiltersResponse(\n  response: RawNftFiltersResponse\n): NftFiltersResponse {\n  return {\n    filters: response.data.map(f =>\n      f.token_id\n        ? {\n            contractAddress: f.contract_address,\n            tokenId: BigNumber.from(f.token_id).toString()\n          }\n        : {\n            contractAddress: f.contract_address\n          }\n    ),\n    totalCount: response.pagination.total_count,\n    pageKey: response.pagination.cursors.after\n  };\n}\n\nfunction nftFilterToParam(filter: NftFilter): RawNftFilterParam {\n  return filter.tokenId\n    ? {\n        contract_address: filter.contractAddress,\n        token_id: BigNumber.from(filter.tokenId).toString()\n      }\n    : {\n        contract_address: filter.contractAddress\n      };\n}\n","import {\n  TransactionReceipt,\n  TransactionRequest,\n  TransactionResponse\n} from '@ethersproject/abstract-provider';\nimport type { BigNumber } from '@ethersproject/bignumber';\nimport { Deferrable } from '@ethersproject/properties';\n\nimport {\n  BlockIdentifier,\n  DebugTransaction,\n  GasOptimizedTransactionResponse,\n  GasOptimizedTransactionStatusResponse,\n  SendPrivateTransactionOptions,\n  SimulateAssetChangesResponse,\n  SimulateExecutionResponse\n} from '../types/types';\nimport { nullsToUndefined } from '../util/util';\nimport { AlchemyConfig } from './alchemy-config';\nimport { Wallet } from './alchemy-wallet';\nimport { fromHex, toHex } from './util';\n\n/**\n * Multiples to increment fee per gas when using\n * {@link TransactNamespace.sendGasOptimizedTransaction}.\n *\n * @internal\n */\nexport const GAS_OPTIMIZED_TX_FEE_MULTIPLES = [0.9, 1, 1.1, 1.2, 1.3];\n\n/**\n * The Transact namespace contains methods used for sending transactions and\n * checking on the state of submitted transactions.\n *\n * Do not call this constructor directly. Instead, instantiate an Alchemy object\n * with `const alchemy = new Alchemy(config)` and then access the transact\n * namespace via `alchemy.transact`.\n */\nexport class TransactNamespace {\n  /** @internal */\n  constructor(private readonly config: AlchemyConfig) {}\n\n  /**\n   * Used to send a single transaction to Flashbots. Flashbots will attempt to\n   * send the transaction to miners for the next 25 blocks.\n   *\n   * Returns the transaction hash of the submitted transaction.\n   *\n   * @param signedTransaction The raw, signed transaction as a hash.\n   * @param maxBlockNumber Optional highest block number in which the\n   *   transaction should be included.\n   * @param options Options to configure the request.\n   */\n  async sendPrivateTransaction(\n    signedTransaction: string,\n    maxBlockNumber?: number,\n    options?: SendPrivateTransactionOptions\n  ): Promise<string> {\n    const provider = await this.config.getProvider();\n    const hexBlockNumber = maxBlockNumber ? toHex(maxBlockNumber) : undefined;\n    return provider._send(\n      'eth_sendPrivateTransaction',\n      [\n        {\n          tx: signedTransaction,\n          maxBlockNumber: hexBlockNumber,\n          preferences: options\n        }\n      ],\n      'sendPrivateTransaction'\n    );\n  }\n\n  /**\n   * Stops the provided private transaction from being submitted for future\n   * blocks. A transaction can only be cancelled if the request is signed by the\n   * same key as the {@link sendPrivateTransaction} call submitting the\n   * transaction in first place.\n   *\n   * Please note that fast mode transactions cannot be cancelled using this method.\n   *\n   * Returns a boolean indicating whether the cancellation was successful.\n   *\n   * @param transactionHash Transaction hash of private tx to be cancelled\n   */\n  async cancelPrivateTransaction(transactionHash: string): Promise<boolean> {\n    const provider = await this.config.getProvider();\n    return provider._send(\n      'eth_cancelPrivateTransaction',\n      [\n        {\n          txHash: transactionHash\n        }\n      ],\n      'cancelPrivateTransaction'\n    );\n  }\n\n  /**\n   * Simulates the asset changes resulting from a list of transactions simulated\n   * in sequence.\n   *\n   * Returns a list of asset changes for each transaction during simulation.\n   *\n   * @param transactions Transactions list of max 3 transactions to simulate.\n   * @param blockIdentifier Optional block identifier to simulate the\n   * transaction in.\n   */\n  async simulateAssetChangesBundle(\n    transactions: DebugTransaction[],\n    blockIdentifier?: BlockIdentifier\n  ): Promise<SimulateAssetChangesResponse[]> {\n    const provider = await this.config.getProvider();\n    const params =\n      blockIdentifier !== undefined\n        ? [transactions, blockIdentifier]\n        : [transactions];\n    const res = await provider._send(\n      'alchemy_simulateAssetChangesBundle',\n      params,\n      'simulateAssetChangesBundle'\n    );\n    return nullsToUndefined(res);\n  }\n\n  /**\n   * Simulates the asset changes resulting from a single transaction.\n   *\n   * Returns list of asset changes that occurred during the transaction\n   * simulation. Note that this method does not run the transaction on the\n   * blockchain.\n   *\n   * @param transaction The transaction to simulate.\n   * @param blockIdentifier Optional block identifier to simulate the\n   * transaction in.\n   */\n  async simulateAssetChanges(\n    transaction: DebugTransaction,\n    blockIdentifier?: BlockIdentifier\n  ): Promise<SimulateAssetChangesResponse> {\n    const provider = await this.config.getProvider();\n    const params =\n      blockIdentifier !== undefined\n        ? [transaction, blockIdentifier]\n        : [transaction];\n    const res = await provider._send(\n      'alchemy_simulateAssetChanges',\n      params,\n      'simulateAssetChanges'\n    );\n    return nullsToUndefined(res);\n  }\n\n  /**\n   * Simulates a list of transactions in sequence and returns list of decoded\n   * traces and logs that occurred for each transaction during simulation.\n   *\n   * Note that this method does not run any transactions on the blockchain.\n   *\n   * @param transactions Transactions list of max 3 transactions to simulate.\n   * @param blockIdentifier Optional block identifier to simulate the\n   * transaction in.\n   */\n  async simulateExecutionBundle(\n    transactions: DebugTransaction[],\n    blockIdentifier?: BlockIdentifier\n  ): Promise<SimulateExecutionResponse[]> {\n    const provider = await this.config.getProvider();\n    const params =\n      blockIdentifier !== undefined\n        ? [transactions, blockIdentifier]\n        : [transactions];\n    const res = provider._send(\n      'alchemy_simulateExecutionBundle',\n      params,\n      'simulateExecutionBundle'\n    );\n    return nullsToUndefined(res);\n  }\n\n  /**\n   * Simulates a single transaction and the resulting and returns list of\n   * decoded traces and logs that occurred during the transaction simulation.\n   *\n   * Note that this method does not run the transaction on the blockchain.\n   *\n   * @param transaction The transaction to simulate.\n   * @param blockIdentifier Optional block identifier to simulate the\n   * transaction in.\n   */\n  async simulateExecution(\n    transaction: DebugTransaction,\n    blockIdentifier?: BlockIdentifier\n  ): Promise<SimulateExecutionResponse> {\n    const provider = await this.config.getProvider();\n    const params =\n      blockIdentifier !== undefined\n        ? [transaction, blockIdentifier]\n        : [transaction];\n    const res = provider._send(\n      'alchemy_simulateExecution',\n      params,\n      'simulateExecution'\n    );\n    return nullsToUndefined(res);\n  }\n\n  /**\n   * Returns the transaction with hash or null if the transaction is unknown.\n   *\n   * If a transaction has not been mined, this method will search the\n   * transaction pool. Various backends may have more restrictive transaction\n   * pool access (e.g. if the gas price is too low or the transaction was only\n   * recently sent and not yet indexed) in which case this method may also return null.\n   *\n   * NOTE: This is an alias for {@link CoreNamespace.getTransaction}.\n   *\n   * @param transactionHash The hash of the transaction to get.\n   * @public\n   */\n  async getTransaction(\n    transactionHash: string | Promise<string>\n  ): Promise<TransactionResponse | null> {\n    const provider = await this.config.getProvider();\n    return provider.getTransaction(transactionHash);\n  }\n\n  /**\n   * Submits transaction to the network to be mined. The transaction must be\n   * signed, and be valid (i.e. the nonce is correct and the account has\n   * sufficient balance to pay for the transaction).\n   *\n   * NOTE: This is an alias for {@link CoreNamespace.sendTransaction}.\n   *\n   * @param signedTransaction The signed transaction to send.\n   * @public\n   */\n  async sendTransaction(\n    signedTransaction: string | Promise<string>\n  ): Promise<TransactionResponse> {\n    const provider = await this.config.getProvider();\n    return provider.sendTransaction(signedTransaction);\n  }\n\n  /**\n   * Returns an estimate of the amount of gas that would be required to submit\n   * transaction to the network.\n   *\n   * An estimate may not be accurate since there could be another transaction on\n   * the network that was not accounted for, but after being mined affects the\n   * relevant state.\n   *\n   * This is an alias for {@link CoreNamespace.estimateGas}.\n   *\n   * @param transaction The transaction to estimate gas for.\n   * @public\n   */\n  async estimateGas(\n    transaction: Deferrable<TransactionRequest>\n  ): Promise<BigNumber> {\n    const provider = await this.config.getProvider();\n    return provider.estimateGas(transaction);\n  }\n\n  /**\n   * Returns a fee per gas (in wei) that is an estimate of how much you can pay\n   * as a priority fee, or \"tip\", to get a transaction included in the current block.\n   *\n   * This number is generally used to set the `maxPriorityFeePerGas` field in a\n   * transaction request.\n   *\n   * @public\n   */\n  async getMaxPriorityFeePerGas(): Promise<number> {\n    const provider = await this.config.getProvider();\n    const feeHex = await provider._send(\n      'eth_maxPriorityFeePerGas',\n      [],\n      'getMaxPriorityFeePerGas'\n    );\n    return fromHex(feeHex);\n  }\n\n  /**\n   * Returns a promise which will not resolve until specified transaction hash is mined.\n   *\n   * If {@link confirmations} is 0, this method is non-blocking and if the\n   * transaction has not been mined returns null. Otherwise, this method will\n   * block until the transaction has confirmed blocks mined on top of the block\n   * in which it was mined.\n   *\n   * NOTE: This is an alias for {@link CoreNamespace.waitForTransaction}.\n   *\n   * @param transactionHash The hash of the transaction to wait for.\n   * @param confirmations The number of blocks to wait for.\n   * @param timeout The maximum time to wait for the transaction to confirm.\n   * @public\n   */\n  async waitForTransaction(\n    transactionHash: string,\n    confirmations?: number,\n    timeout?: number\n  ): Promise<TransactionReceipt | null> {\n    const provider = await this.config.getProvider();\n    return provider.waitForTransaction(transactionHash, confirmations, timeout);\n  }\n\n  /**\n   * Instead of sending a single transaction that might not get mined, this\n   * method allows you to send the same transaction multiple times, with\n   * different gas prices and gas limits. This should result in lower fees paid.\n   *\n   * Alchemy will submit the cheapest transaction, and if it does not get mined,\n   * the next cheapest transaction will be submitted. This process will continue\n   * until one of the transactions is mined, or until all transactions are rejected.\n   *\n   * To have Alchemy automatically generate a fee and gas spread, pass in a\n   * {@link TransactionRequest} object and a {@link Wallet} as a signer.\n   *\n   * This method returns a response object containing the transaction hash for\n   * each of the signed transactions and a transaction job id that can be used\n   * to track the state of the transaction job.\n   *\n   * @param signedTransactions An array of signed transactions to send. Each\n   *   transaction in the array must have the same values, but with different\n   *   gas and fee values.\n   * @internal\n   */\n  // TODO(txjob): Remove internal tag once this feature is released.\n  async sendGasOptimizedTransaction(\n    signedTransactions: string[]\n  ): Promise<GasOptimizedTransactionResponse>;\n\n  /**\n   * Instead of sending a single transaction that might not get mined, this\n   * method will generate a series of five EIP-1559 transactions with different\n   * gas prices in order to minimize the final fees paid.\n   *\n   * Alchemy will submit the cheapest transaction, and if it does not get mined,\n   * the next cheapest transaction will be submitted. This process will continue\n   * until one of the transactions is mined, or until all transactions are rejected.\n   *\n   * To calculate the fee, gas, and gas spread for each transaction, this method\n   * first calculates the base fee from the latest block, estimates the gas for\n   * the transaction, and then calculates the fee and gas spread for the\n   * transaction. The five transactions will have 90%, 100%, 110%, 120%, and\n   * 130% of the max priority fee per gas.\n   *\n   * Note that you can also pass in an array of pre-signed transactions with set\n   * gas levels for more granular control over gas.\n   *\n   * This method returns a response object containing the transaction hash for\n   * each of the signed transactions and a transaction job id that can be used\n   * to track the state of the transaction job.\n   *\n   * @param transaction The raw transaction to send.\n   * @param wallet A wallet to use to sign the transaction.\n   * @internal\n   */\n  // TODO(txjob): Remove internal tag once this feature is released.\n  async sendGasOptimizedTransaction(\n    transaction: TransactionRequest,\n    wallet: Wallet\n  ): Promise<GasOptimizedTransactionResponse>;\n  async sendGasOptimizedTransaction(\n    transactionOrSignedTxs: TransactionRequest | string[],\n    wallet?: Wallet\n  ): Promise<GasOptimizedTransactionResponse> {\n    if (Array.isArray(transactionOrSignedTxs)) {\n      return this._sendGasOptimizedTransaction(\n        transactionOrSignedTxs,\n        'sendGasOptimizedTransactionPreSigned'\n      );\n    }\n\n    let gasLimit;\n    let priorityFee;\n    let baseFee;\n    const provider = await this.config.getProvider();\n    try {\n      gasLimit = await this.estimateGas(transactionOrSignedTxs);\n      priorityFee = await this.getMaxPriorityFeePerGas();\n      const currentBlock = await provider.getBlock('latest');\n      baseFee = currentBlock.baseFeePerGas!.toNumber();\n    } catch (e) {\n      throw new Error(`Failed to estimate gas for transaction: ${e}`);\n    }\n\n    const gasSpreadTransactions = generateGasSpreadTransactions(\n      transactionOrSignedTxs,\n      gasLimit.toNumber(),\n      baseFee,\n      priorityFee\n    );\n    const signedTransactions = await Promise.all(\n      gasSpreadTransactions.map(tx => wallet!.signTransaction(tx))\n    );\n\n    return this._sendGasOptimizedTransaction(\n      signedTransactions,\n      'sendGasOptimizedTransactionGenerated'\n    );\n  }\n\n  /**\n   * Returns the state of the transaction job returned by the\n   * {@link sendGasOptimizedTransaction}.\n   *\n   * @param trackingId The tracking id from the response of the sent gas optimized transaction.\n   * @internal\n   */\n  // TODO(txjob): Remove internal tag once this feature is released.\n  async getGasOptimizedTransactionStatus(\n    trackingId: string\n  ): Promise<GasOptimizedTransactionStatusResponse> {\n    const provider = await this.config.getProvider();\n    return provider._send(\n      'alchemy_getGasOptimizedTransactionStatus',\n      [trackingId],\n      'getGasOptimizedTransactionStatus'\n    );\n  }\n\n  /** @internal */\n  private async _sendGasOptimizedTransaction(\n    signedTransactions: string[],\n    methodName: string\n  ): Promise<GasOptimizedTransactionResponse> {\n    const provider = await this.config.getProvider();\n    return provider._send(\n      'alchemy_sendGasOptimizedTransaction',\n      [\n        {\n          rawTransactions: signedTransactions\n        }\n      ],\n      methodName\n    );\n  }\n}\n\n/**\n * Helper method to generate the raw transaction with the given gas limit and\n * priority fee across a spread of different gas prices.\n *\n * @internal\n */\n// Visible for testing\nexport function generateGasSpreadTransactions(\n  transaction: TransactionRequest,\n  gasLimit: number,\n  baseFee: number,\n  priorityFee: number\n): TransactionRequest[] {\n  return GAS_OPTIMIZED_TX_FEE_MULTIPLES.map(feeMultiplier => {\n    return {\n      ...transaction,\n      gasLimit,\n      maxFeePerGas: Math.round(\n        baseFee * feeMultiplier + priorityFee * feeMultiplier\n      ),\n      maxPriorityFeePerGas: Math.round(feeMultiplier * priorityFee)\n    };\n  });\n}\n","/** This file contains internal types used by the SDK and are not exposed to the end user. */\n\ntype JsonRpcId = string | number | null;\n\n/**\n * Prefix for `alchemy_pendingTransactions` subscriptions when serializing to\n * ethers events.\n *\n * This tag is used internally by ethers to track different event filters.\n */\nexport const ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE =\n  'alchemy-pending-transactions';\n\n/**\n * Prefix for `alchemy_minedTransactions` subscriptions when serializing to ethers events.\n *\n * This tag is used internally by ethers to track different event filters.\n */\nexport const ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE =\n  'alchemy-mined-transactions';\n\n/**\n * Array containing all the custom event tags used internally by ethers to track\n * event filters.\n */\nexport const ALCHEMY_EVENT_TYPES = [\n  ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE,\n  ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE\n];\n\nexport interface JsonRpcRequest {\n  jsonrpc: '2.0';\n  method: string;\n  params?: any[];\n  id?: JsonRpcId;\n}\n\nexport interface JsonRpcResponse<T = any> {\n  jsonrpc: '2.0';\n  result?: T;\n  error?: JsonRpcError;\n  id: JsonRpcId;\n}\n\ninterface JsonRpcError<T = any> {\n  code: number;\n  message: string;\n  data?: T;\n}\n\nexport type WebSocketMessage = SingleOrBatchResponse | SubscriptionEvent;\nexport type SingleOrBatchResponse = JsonRpcResponse | JsonRpcResponse[];\nexport interface SubscriptionEvent<T = any> {\n  jsonrpc: '2.0';\n  method: 'eth_subscription';\n  params: {\n    subscription: string;\n    result: T;\n  };\n}\n","import { EventType, Filter, Listener } from '@ethersproject/abstract-provider';\n\nimport {\n  AlchemyEventFilter,\n  AlchemyEventType,\n  AlchemyMinedTransactionsAddress,\n  AlchemyMinedTransactionsEventFilter,\n  AlchemyPendingTransactionsEventFilter,\n  AlchemySubscription,\n  NonEmptyArray\n} from '../types/types';\nimport {\n  ALCHEMY_EVENT_TYPES,\n  ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE,\n  ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE\n} from './internal-types';\n\n/**\n * DO NOT MODIFY.\n *\n * Event class copied directly over from ethers.js's `BaseProvider` class.\n *\n * This class is used to represent events and their corresponding listeners. The\n * SDK needs to extend this class in order to support Alchemy's custom\n * Subscription API types. The original class is not exported by ethers. Minimal\n * changes have been made in order to get TS to compile.\n */\nclass Event {\n  readonly listener: Listener;\n  readonly once: boolean;\n  readonly tag: string;\n\n  _lastBlockNumber: number;\n  _inflight: boolean;\n\n  constructor(tag: string, listener: Listener, once: boolean) {\n    this.listener = listener;\n    this.tag = tag;\n    this.once = once;\n    this._lastBlockNumber = -2;\n    this._inflight = false;\n  }\n\n  get event(): EventType {\n    switch (this.type) {\n      case 'tx':\n        return this.hash!;\n      case 'filter':\n        return this.filter!;\n      default:\n        return this.tag;\n    }\n  }\n\n  get type(): string {\n    return this.tag.split(':')[0];\n  }\n\n  get hash(): string {\n    const comps = this.tag.split(':');\n    if (comps[0] !== 'tx') {\n      throw new Error('Not a transaction event');\n    }\n    return comps[1];\n  }\n\n  get filter(): Filter {\n    const comps = this.tag.split(':');\n    if (comps[0] !== 'filter') {\n      throw new Error('Not a transaction event');\n    }\n    const address = comps[1];\n\n    const topics = deserializeTopics(comps[2]);\n    const filter: Filter = {};\n\n    if (topics.length > 0) {\n      filter.topics = topics;\n    }\n    if (address && address !== '*') {\n      filter.address = address;\n    }\n\n    return filter;\n  }\n\n  pollable(): boolean {\n    const PollableEvents = ['block', 'network', 'pending', 'poll'];\n    return this.tag.indexOf(':') >= 0 || PollableEvents.indexOf(this.tag) >= 0;\n  }\n}\n\n/**\n * Wrapper class around the ethers `Event` class in order to add support for\n * Alchemy's custom subscriptions types.\n *\n * The serialization and deserialization mechanism requires the order of the\n * fields to be the same across different {@link ALCHEMY_EVENT_TYPES}. Before\n * using a getter on a new event filter, make sure that the position of the\n * field in serialization is correct.\n *\n * The getters on this class deserialize the event tag generated by\n * {@link getAlchemyEventTag} into the original fields passed into the event.\n */\nexport class EthersEvent extends Event {\n  /**\n   * Converts the event tag into the original `fromAddress` field in\n   * {@link AlchemyPendingTransactionsEventFilter}.\n   */\n  get fromAddress(): string | string[] | undefined {\n    const comps = this.tag.split(':');\n    if (comps[0] !== ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n      return undefined;\n    }\n    if (comps[1] && comps[1] !== '*') {\n      return deserializeAddressField(comps[1]);\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * Converts the event tag into the original `toAddress` field in\n   * {@link AlchemyPendingTransactionsEventFilter}.\n   */\n  get toAddress(): string | string[] | undefined {\n    const comps = this.tag.split(':');\n    if (comps[0] !== ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n      return undefined;\n    }\n    if (comps[2] && comps[2] !== '*') {\n      return deserializeAddressField(comps[2]);\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * Converts the event tag into the original `hashesOnly` field in\n   * {@link AlchemyPendingTransactionsEventFilter} and {@link AlchemyMinedTransactionsEventFilter}.\n   */\n  get hashesOnly(): boolean | undefined {\n    const comps = this.tag.split(':');\n    if (!ALCHEMY_EVENT_TYPES.includes(comps[0])) {\n      return undefined;\n    }\n    if (comps[3] && comps[3] !== '*') {\n      return comps[3] === 'true';\n    } else {\n      return undefined;\n    }\n  }\n\n  get includeRemoved(): boolean | undefined {\n    const comps = this.tag.split(':');\n    if (comps[0] !== ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {\n      return undefined;\n    }\n    if (comps[2] && comps[2] !== '*') {\n      return comps[2] === 'true';\n    } else {\n      return undefined;\n    }\n  }\n\n  get addresses(): NonEmptyArray<AlchemyMinedTransactionsAddress> | undefined {\n    const comps = this.tag.split(':');\n    if (comps[0] !== ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {\n      return undefined;\n    }\n    if (comps[1] && comps[1] !== '*') {\n      return deserializeAddressesField(comps[1]);\n    } else {\n      return undefined;\n    }\n  }\n}\n\nexport function isAlchemyEvent(\n  event: AlchemyEventType\n): event is\n  | AlchemyMinedTransactionsEventFilter\n  | AlchemyPendingTransactionsEventFilter {\n  return typeof event === 'object' && 'method' in event;\n}\n\n/**\n * Creates a string representation of an `alchemy_pendingTransaction`\n * subscription filter that is compatible with the ethers implementation of\n * `getEventTag()`. The method is not an exported function in ethers, which is\n * why the SDK has its own implementation.\n *\n * The event tag is then deserialized by the SDK's {@link EthersEvent} getters.\n *\n * @example\n *   ```js\n *   // Returns 'alchemy-pending-transactions:0xABC:0xDEF|0xGHI:true'\n *   const eventTag =  getAlchemyEventTag(\n *   {\n *     \"method\": \"alchemy_pendingTransactions\",\n *     \"fromAddress\": \"0xABC\",\n *     \"toAddress\": [\"0xDEF\", \"0xGHI\"],\n *     \"hashesOnly: true\n *   });\n *   ```;\n *\n * @param event\n * @internal\n */\nexport function getAlchemyEventTag(event: AlchemyEventType): string {\n  if (!isAlchemyEvent(event)) {\n    throw new Error('Event tag requires AlchemyEventType');\n  }\n\n  if (event.method === AlchemySubscription.PENDING_TRANSACTIONS) {\n    return serializePendingTransactionsEvent(event);\n  } else if (event.method === AlchemySubscription.MINED_TRANSACTIONS) {\n    return serializeMinedTransactionsEvent(event);\n  } else {\n    throw new Error(`Unrecognized AlchemyFilterEvent: ${event}`);\n  }\n}\n\nexport function verifyAlchemyEventName(eventName: AlchemyEventFilter): void {\n  if (!Object.values(AlchemySubscription).includes(eventName.method)) {\n    throw new Error(\n      `Invalid method name ${\n        eventName.method\n      }. Accepted method names: ${Object.values(AlchemySubscription)}`\n    );\n  }\n}\n\n/**\n * Serializes the provided {@link AlchemyPendingTransactionsEventFilter} into an ethers\n * compatible event tag.\n *\n * For the example event:\n * ```\n *  {\n *     \"method\": \"alchemy_pendingTransactions\",\n *     \"fromAddress\": \"0xABC\",\n *     \"toAddress\": [\"0xDEF\", \"0xGHI\"],\n *     \"hashesOnly: true\n *   }\n * ```\n *\n * The resulting serialization is:\n * `alchemy_pendingTransactions:0xABC:0xDEF|0xGHI:true`\n *\n * If a field is omitted, it is replaced with a `*`.\n */\nfunction serializePendingTransactionsEvent(\n  event: AlchemyPendingTransactionsEventFilter\n): string {\n  const fromAddress = serializeAddressField(event.fromAddress);\n  const toAddress = serializeAddressField(event.toAddress);\n  const hashesOnly = serializeBooleanField(event.hashesOnly);\n  return (\n    ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE +\n    ':' +\n    fromAddress +\n    ':' +\n    toAddress +\n    ':' +\n    hashesOnly\n  );\n}\n\n/**\n * Serializes the provided {@link AlchemyPendingTransactionsEventFilter} into an ethers\n * compatible event tag.\n *\n * For the example event:\n * ```\n *  {\n *     \"method\": \"alchemy_minedTransactions\",\n *     \"addresses\": [\n *       {\n *         from: \"0xABC\"\n *       },\n *       {\n *         to: \"0xDEF\",\n *         from: \"0x123\"\n *       }\n *     ]\n *     \"includeRemoved\": false\n *     \"hashesOnly: true\n *   }\n * ```\n *\n * The resulting serialization is:\n * `alchemy_minedTransactions:*,0xABC|0xDEF,0x123:false:true`\n *\n * If a field is omitted, it is replaced with a `*`.\n *\n * The `addresses` array is split by the '|' character, and each to/from address\n * pair is separated by a ',' character.\n *\n */\nfunction serializeMinedTransactionsEvent(\n  event: AlchemyMinedTransactionsEventFilter\n): string {\n  const addresses = serializeAddressesField(event.addresses);\n  const includeRemoved = serializeBooleanField(event.includeRemoved);\n  const hashesOnly = serializeBooleanField(event.hashesOnly);\n  return (\n    ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE +\n    ':' +\n    addresses +\n    ':' +\n    includeRemoved +\n    ':' +\n    hashesOnly\n  );\n}\n\nfunction serializeAddressesField(\n  addresses: AlchemyMinedTransactionsAddress[] | undefined\n): string {\n  if (addresses === undefined) {\n    return '*';\n  }\n\n  return addresses\n    .map(\n      filter =>\n        serializeAddressField(filter.to) +\n        ',' +\n        serializeAddressField(filter.from)\n    )\n    .join('|');\n}\n\nfunction serializeAddressField(\n  field: string | Array<string> | undefined\n): string {\n  if (field === undefined) {\n    return '*';\n  } else if (Array.isArray(field)) {\n    return field.join('|');\n  } else {\n    return field;\n  }\n}\n\nfunction serializeBooleanField(field: boolean | undefined): string | undefined {\n  if (field === undefined) {\n    return '*';\n  } else {\n    return field.toString();\n  }\n}\n\nexport function deserializeTopics(data: string): any {\n  if (data === '') {\n    return [];\n  }\n\n  return data.split(/&/g).map(topic => {\n    if (topic === '') {\n      return [];\n    }\n\n    const comps = topic.split('|').map(topic => {\n      return topic === 'null' ? null : topic;\n    });\n\n    return comps.length === 1 ? comps[0] : comps;\n  });\n}\n\nfunction deserializeAddressField(data: string): string | string[] | undefined {\n  if (data === '') {\n    return undefined;\n  }\n\n  const addresses = data.split('|');\n  return addresses.length === 1 ? addresses[0] : addresses;\n}\n\nfunction deserializeAddressesField(\n  data: string\n): NonEmptyArray<AlchemyMinedTransactionsAddress> | undefined {\n  if (data === '') {\n    return undefined;\n  }\n\n  // Perform a cast here since TS doesn't know we're guaranteed a non-empty\n  // array from deserializing.\n  return data\n    .split('|')\n    .map(addressStr => addressStr.split(','))\n    .map(addressPair => ({\n      ...(addressPair[0] !== '*' && { to: addressPair[0] }),\n      ...(addressPair[1] !== '*' && { from: addressPair[1] })\n    })) as NonEmptyArray<AlchemyMinedTransactionsAddress>;\n}\n","import type { Listener } from '@ethersproject/abstract-provider';\n\nimport { isAlchemyEvent } from '../internal/ethers-event';\nimport {\n  AlchemyEventType,\n  AlchemyMinedTransactionsAddress,\n  AlchemySubscription,\n  NonEmptyArray\n} from '../types/types';\nimport { AlchemyConfig } from './alchemy-config';\n\n/**\n * The Websocket namespace contains all subscription related functions that\n * allow you to subscribe to events and receive updates as they occur. The\n * underlying WebSocket provider has additional logic to handle reconnections\n * and automatically backfills missed events.\n *\n * Do not call this constructor directly. Instead, instantiate an Alchemy object\n * with `const alchemy = new Alchemy(config)` and then access the core namespace\n * via `alchemy.ws`.\n */\nexport class WebSocketNamespace {\n  /** @internal */\n  constructor(private readonly config: AlchemyConfig) {}\n\n  /**\n   * Adds a listener to be triggered for each {@link eventName} event. Also\n   * includes Alchemy's Subscription API events. See {@link AlchemyEventType} for\n   * how to use them.\n   *\n   * @param eventName The event to listen for.\n   * @param listener The listener to call when the event is triggered.\n   * @public\n   */\n  on(eventName: AlchemyEventType, listener: Listener): this {\n    void (async () => {\n      const provider = await this.config.getWebSocketProvider();\n      const processedEvent = await this._resolveEnsAlchemyEvent(eventName);\n      provider.on(processedEvent, listener);\n    })();\n    return this;\n  }\n\n  /**\n   * Adds a listener to be triggered for only the next {@link eventName} event,\n   * after which it will be removed. Also includes Alchemy's Subscription API\n   * events. See {@link AlchemyEventType} for how to use them.\n   *\n   * @param eventName The event to listen for.\n   * @param listener The listener to call when the event is triggered.\n   * @public\n   */\n  once(eventName: AlchemyEventType, listener: Listener): this {\n    void (async () => {\n      const provider = await this.config.getWebSocketProvider();\n      const processedEvent = await this._resolveEnsAlchemyEvent(eventName);\n      provider.once(processedEvent, listener);\n    })();\n    return this;\n  }\n\n  /**\n   * Removes the provided {@link listener} for the {@link eventName} event. If no\n   * listener is provided, all listeners for the event will be removed.\n   *\n   * @param eventName The event to unlisten to.\n   * @param listener The listener to remove.\n   * @public\n   */\n  off(eventName: AlchemyEventType, listener?: Listener): this {\n    void (async () => {\n      const provider = await this.config.getWebSocketProvider();\n      const processedEvent = await this._resolveEnsAlchemyEvent(eventName);\n      return provider.off(processedEvent, listener);\n    })();\n    return this;\n  }\n\n  /**\n   * Remove all listeners for the provided {@link eventName} event. If no event\n   * is provided, all events and their listeners are removed.\n   *\n   * @param eventName The event to remove all listeners for.\n   * @public\n   */\n  removeAllListeners(eventName?: AlchemyEventType): this {\n    void (async () => {\n      const provider = await this.config.getWebSocketProvider();\n      const processedEvent = eventName\n        ? await this._resolveEnsAlchemyEvent(eventName)\n        : undefined;\n      provider.removeAllListeners(processedEvent);\n    })();\n    return this;\n  }\n\n  /**\n   * Returns the number of listeners for the provided {@link eventName} event. If\n   * no event is provided, the total number of listeners for all events is returned.\n   *\n   * @param eventName The event to get the number of listeners for.\n   * @public\n   */\n  async listenerCount(eventName?: AlchemyEventType): Promise<number> {\n    const provider = await this.config.getWebSocketProvider();\n    const processedEvent = eventName\n      ? await this._resolveEnsAlchemyEvent(eventName)\n      : undefined;\n    return provider.listenerCount(processedEvent);\n  }\n\n  /**\n   * Returns an array of listeners for the provided {@link eventName} event. If\n   * no event is provided, all listeners will be included.\n   *\n   * @param eventName The event to get the listeners for.\n   */\n  async listeners(eventName?: AlchemyEventType): Promise<Listener[]> {\n    const provider = await this.config.getWebSocketProvider();\n    const processedEvent = eventName\n      ? await this._resolveEnsAlchemyEvent(eventName)\n      : undefined;\n    return provider.listeners(processedEvent);\n  }\n\n  /**\n   * Converts ENS addresses in an Alchemy Event to the underlying resolved\n   * address.\n   *\n   * VISIBLE ONLY FOR TESTING.\n   *\n   * @internal\n   */\n  async _resolveEnsAlchemyEvent(\n    eventName: AlchemyEventType\n  ): Promise<AlchemyEventType> {\n    if (!isAlchemyEvent(eventName)) {\n      return eventName;\n    }\n\n    if (\n      eventName.method === AlchemySubscription.MINED_TRANSACTIONS &&\n      eventName.addresses\n    ) {\n      const processedAddresses: AlchemyMinedTransactionsAddress[] = [];\n      for (const address of eventName.addresses) {\n        if (address.to) {\n          address.to = await this._resolveNameOrError(address.to);\n        }\n        if (address.from) {\n          address.from = await this._resolveNameOrError(address.from);\n        }\n        processedAddresses.push(address);\n      }\n      eventName.addresses =\n        processedAddresses as NonEmptyArray<AlchemyMinedTransactionsAddress>;\n    } else if (eventName.method === AlchemySubscription.PENDING_TRANSACTIONS) {\n      if (eventName.fromAddress) {\n        if (typeof eventName.fromAddress === 'string') {\n          eventName.fromAddress = await this._resolveNameOrError(\n            eventName.fromAddress\n          );\n        } else {\n          eventName.fromAddress = await Promise.all(\n            eventName.fromAddress.map(address =>\n              this._resolveNameOrError(address)\n            )\n          );\n        }\n      }\n      if (eventName.toAddress) {\n        if (typeof eventName.toAddress === 'string') {\n          eventName.toAddress = await this._resolveNameOrError(\n            eventName.toAddress\n          );\n        } else {\n          eventName.toAddress = await Promise.all(\n            eventName.toAddress.map(address =>\n              this._resolveNameOrError(address)\n            )\n          );\n        }\n      }\n    }\n\n    return eventName;\n  }\n\n  /**\n   * Converts the provided ENS address or throws an error. This improves code\n   * readability and type safety in other methods.\n   *\n   * VISIBLE ONLY FOR TESTING.\n   *\n   * @internal\n   */\n  async _resolveNameOrError(name: string): Promise<string> {\n    const provider = await this.config.getProvider();\n    const resolved = await provider.resolveName(name);\n    if (resolved === null) {\n      throw new Error(`Unable to resolve the ENS address: ${name}`);\n    }\n    return resolved;\n  }\n}\n","import { AlchemySettings } from '../types/types';\nimport { AlchemyConfig } from './alchemy-config';\nimport { CoreNamespace } from './core-namespace';\nimport { DebugNamespace } from './debug-namespace';\nimport { NftNamespace } from './nft-namespace';\nimport { NotifyNamespace } from './notify-namespace';\nimport { TransactNamespace } from './transact-namespace';\nimport { WebSocketNamespace } from './websocket-namespace';\n\n/**\n * The Alchemy SDK client. This class is the main entry point into Alchemy's\n * APIs and separates functionality into different namespaces.\n *\n * Each SDK instance is associated with a specific network and API key. To use a\n * different network or API key, create a new instance of {@link Alchemy}.\n *\n * @public\n */\nexport class Alchemy {\n  /**\n   * The `core` namespace contains the core eth json-rpc calls and Alchemy's\n   * Enhanced APIs.\n   */\n  readonly core: CoreNamespace;\n\n  /** The `nft` namespace contains methods for Alchemy's NFT API. */\n  readonly nft: NftNamespace;\n\n  /** The `ws` namespace contains methods for using WebSockets and creating subscriptions. */\n  readonly ws: WebSocketNamespace;\n\n  /**\n   * The `transact` namespace contains methods for sending transactions and\n   * checking on the state of submitted transasctions.\n   */\n  readonly transact: TransactNamespace;\n\n  /**\n   * Holds the setting information for the instance of the Alchemy SDK client\n   * and allows access to the underlying providers.\n   */\n  readonly config: AlchemyConfig;\n\n  /**\n   * The `notify` namespace contains methods for creating and managing webhooks\n   * as part of the Notify API.\n   */\n  readonly notify: NotifyNamespace;\n\n  /**\n   * The `debug` namespace contains methods for inspecting and debugging\n   * transactions.\n   */\n  readonly debug: DebugNamespace;\n\n  /**\n   * @param {string} [settings.apiKey] - The API key to use for Alchemy\n   * @param {Network} [settings.network] - The network to use for Alchemy\n   * @param {number} [settings.maxRetries] - The maximum number of retries to attempt\n   * @param {number} [settings.requestTimeout] - The timeout after which request should fail\n   * @public\n   */\n  constructor(settings?: AlchemySettings) {\n    this.config = new AlchemyConfig(settings);\n\n    this.core = new CoreNamespace(this.config);\n    this.nft = new NftNamespace(this.config);\n    this.ws = new WebSocketNamespace(this.config);\n    this.transact = new TransactNamespace(this.config);\n    this.notify = new NotifyNamespace(this.config);\n    this.debug = new DebugNamespace(this.config);\n  }\n}\n","import {\n  BlockTag,\n  FeeData,\n  Provider,\n  TransactionRequest,\n  TransactionResponse\n} from '@ethersproject/abstract-provider';\nimport { ExternallyOwnedAccount } from '@ethersproject/abstract-signer';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport { BytesLike } from '@ethersproject/bytes';\nimport { Deferrable } from '@ethersproject/properties';\nimport { SigningKey } from '@ethersproject/signing-key';\nimport { Wallet as EthersWallet } from '@ethersproject/wallet';\n\nimport { Alchemy } from './alchemy';\n\n/**\n * The Wallet class inherits Signer and can sign transactions and messages using\n * a private key as a standard Externally Owned Account (EOA).\n *\n * SDK's custom implementation of Ethers.js's 'Wallet'.\n *\n * Primary difference from Ethers.js 'Wallet' is that you can pass in either a\n * Provider or an Alchemy object. This implementation will intelligently detect\n * the format and set the provider accordingly.\n *\n * @public\n * @override\n */\nexport class Wallet extends EthersWallet {\n  private alchemyProviderPromise?: Promise<Provider>;\n\n  /**\n   * Overload permits users to pass in either a standard Provider or an Alchemy\n   * object. The constructor will detect the object type and handle appropriately.\n   *\n   * @override\n   */\n  constructor(\n    privateKey: BytesLike | ExternallyOwnedAccount | SigningKey,\n    alchemyOrProvider?: Alchemy | Provider\n  ) {\n    // If object passed in is a provider, send to super\n    let superProvider: Provider | undefined;\n    if (alchemyOrProvider && Provider.isProvider(alchemyOrProvider)) {\n      superProvider = alchemyOrProvider;\n    }\n    super(privateKey, superProvider);\n\n    // If object passed in is an Alchemy object, just set Alchemy\n    if (alchemyOrProvider && !Provider.isProvider(alchemyOrProvider)) {\n      this.alchemyProviderPromise = alchemyOrProvider.config.getProvider();\n    }\n  }\n\n  //////////////////////////////////////////////////////////////////\n  // Set of overrides from Signer to handle async provider retrieval.\n  //////////////////////////////////////////////////////////////////\n\n  /**\n   * Returns the balance of this wallet at blockTag.\n   *\n   * @param blockTag The block to check the balance of\n   * @override\n   */\n  getBalance(blockTag?: BlockTag): Promise<BigNumber> {\n    return this.getWallet().then(wallet => wallet.getBalance(blockTag));\n  }\n\n  /**\n   * Returns the number of transactions this account has ever sent. This is the\n   * value required to be included in transactions as the nonce.\n   *\n   * @param blockTag The block to check the transaction count on\n   * @override\n   */\n  getTransactionCount(blockTag?: BlockTag): Promise<number> {\n    return this.getWallet().then(wallet =>\n      wallet.getTransactionCount(blockTag)\n    );\n  }\n\n  /**\n   * Returns the result of estimating the cost to send the transactionRequest,\n   * with this account address being used as the from field.\n   *\n   * @param transaction Transaction to estimate the gas on\n   * @override\n   */\n  estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber> {\n    return this.getWallet().then(wallet => wallet.estimateGas(transaction));\n  }\n\n  /**\n   * Returns the result of calling using the transactionRequest, with this\n   * account address being used as the from field.\n   *\n   * @param transaction To make a call on\n   * @param blockTag The block to make the call on\n   * @override\n   */\n  call(\n    transaction: Deferrable<TransactionRequest>,\n    blockTag?: BlockTag\n  ): Promise<string> {\n    return this.getWallet().then(wallet => wallet.call(transaction, blockTag));\n  }\n\n  /**\n   * Populates ALL keys for a transaction and checks that `from` matches this\n   * `Signer`. Resolves ENS names and populates fields like `gasPrice`, `gasLimit`,\n   * `nonce`, and `chainId` if they are not provided.\n   *\n   * @param transaction The transaction to populate.\n   * @override\n   */\n  populateTransaction(\n    transaction: Deferrable<TransactionRequest>\n  ): Promise<TransactionRequest> {\n    return this.getWallet().then(wallet =>\n      wallet.populateTransaction(transaction)\n    );\n  }\n\n  /**\n   * Populates all fields in a transaction, signs it and sends it to the network\n   *\n   * @param transaction The transaction to send.\n   * @override\n   */\n  sendTransaction(\n    transaction: Deferrable<TransactionRequest>\n  ): Promise<TransactionResponse> {\n    return this.getWallet().then(wallet => wallet.sendTransaction(transaction));\n  }\n\n  /**\n   * Returns the chain ID this wallet is connected to.\n   *\n   * @override\n   */\n  getChainId(): Promise<number> {\n    return this.getWallet().then(wallet => wallet.getChainId());\n  }\n\n  /**\n   * Returns the current gas price.\n   *\n   * @override\n   */\n  getGasPrice(): Promise<BigNumber> {\n    return this.getWallet().then(wallet => wallet.getGasPrice());\n  }\n\n  /**\n   * Returns the current recommended FeeData to use in a transaction.\n   *\n   * For an EIP-1559 transaction, the maxFeePerGas and maxPriorityFeePerGas\n   * should be used.\n   *\n   * For legacy transactions and networks which do not support EIP-1559, the\n   * gasPrice should be used.\n   *\n   * @override\n   */\n  getFeeData(): Promise<FeeData> {\n    return this.getWallet().then(wallet => wallet.getFeeData());\n  }\n\n  /**\n   * Looks up the address of name. If the name is not owned, or does not have a\n   * Resolver configured, or the Resolver does not have an address configured,\n   * null is returned.\n   *\n   * @param name Name of the ENS address\n   * @override\n   */\n  resolveName(name: string): Promise<string> {\n    return this.getWallet().then(wallet => wallet.resolveName(name));\n  }\n\n  private async getWallet() {\n    if (!this.alchemyProviderPromise) {\n      return this.connect(this.provider);\n    }\n    return this.connect(await this.alchemyProviderPromise);\n  }\n}\n","import {\n  Contract as EthersContract,\n  ContractFactory as EthersContractFactory\n} from '@ethersproject/contracts';\n\n/**\n * The Contract class is a wrapper around the Contract class from ethers.js and\n * is exported here for convenience.\n *\n * @public\n */\n// TODO: support passing in Alchemy instance into the contract.\nexport class Contract extends EthersContract {}\n\n/**\n * The ContractFactory class is a wrapper around the ContractFactory class from\n * ethers.js and is exported here for convenience.\n *\n * @public\n */\nexport class ContractFactory extends EthersContractFactory {}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}