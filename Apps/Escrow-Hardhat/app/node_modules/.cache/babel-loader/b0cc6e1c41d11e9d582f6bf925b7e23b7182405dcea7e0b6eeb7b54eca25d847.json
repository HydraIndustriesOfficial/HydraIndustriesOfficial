{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/kbookout/escrow-hardhat/app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _assertThisInitialized from \"/Users/kbookout/escrow-hardhat/app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"/Users/kbookout/escrow-hardhat/app/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/kbookout/escrow-hardhat/app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/kbookout/escrow-hardhat/app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/kbookout/escrow-hardhat/app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _regeneratorRuntime from \"/Users/kbookout/escrow-hardhat/app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _toConsumableArray from \"/Users/kbookout/escrow-hardhat/app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/kbookout/escrow-hardhat/app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/kbookout/escrow-hardhat/app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { _ as __awaiter, f as fromHex, t as toHex, n as noop, C as CustomNetworks, i as isAlchemyEvent, v as verifyAlchemyEventName, c as EthersEvent, e as getAlchemyEventTag, D as DEFAULT_ALCHEMY_API_KEY, A as ALCHEMY_EVENT_TYPES, h as ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE, j as AlchemySubscription, k as ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE, V as VERSION, E as EthersNetwork } from './index-fd7838ce.js';\nimport SturdyWebSocket from 'sturdy-websocket';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport { getNetwork as _getNetwork } from '@ethersproject/networks';\nimport { WebSocketProvider } from '@ethersproject/providers';\nimport { AlchemyProvider } from './alchemy-provider-180365c7.js';\nimport './api/utils';\nimport 'axios';\nimport '@ethersproject/abstract-provider';\nimport '@ethersproject/wallet';\nimport '@ethersproject/contracts';\nimport '@ethersproject/web';\n\n/**\r\n * The maximum number of blocks to backfill. If more than this many blocks have\r\n * been missed, then we'll sadly miss data, but we want to make sure we don't\r\n * end up requesting thousands of blocks if somebody left their laptop closed for a week.\r\n */\nvar MAX_BACKFILL_BLOCKS = 120;\n/**\r\n * The WebsocketBackfiller fetches events that were sent since a provided block\r\n * number. This is used in the {@link AlchemyWebSocketProvider} to backfill\r\n * events that were transmitted while the websocket connection was down.\r\n *\r\n * The backfiller backfills two main eth_subscribe events: `logs` and `newHeads`.\r\n *\r\n * @internal\r\n */\nvar WebsocketBackfiller = /*#__PURE__*/function () {\n  function WebsocketBackfiller(provider) {\n    _classCallCheck(this, WebsocketBackfiller);\n    this.provider = provider;\n    // TODO: Use HTTP provider to do backfill.\n    this.maxBackfillBlocks = MAX_BACKFILL_BLOCKS;\n  }\n  /**\r\n   * Runs backfill for `newHeads` events.\r\n   *\r\n   * @param isCancelled Whether the backfill request is cancelled.\r\n   * @param previousHeads Previous head requests that were sent.\r\n   * @param fromBlockNumber The block number to start backfilling from.\r\n   * @returns A list of `newHeads` events that were sent since the last backfill.\r\n   */\n  _createClass(WebsocketBackfiller, [{\n    key: \"getNewHeadsBackfill\",\n    value: function getNewHeadsBackfill(isCancelled, previousHeads, fromBlockNumber) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var toBlockNumber, lastSeenBlockNumber, minBlockNumber, reorgHeads, intermediateHeads;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              throwIfCancelled(isCancelled);\n              _context.next = 3;\n              return this.getBlockNumber();\n            case 3:\n              toBlockNumber = _context.sent;\n              throwIfCancelled(isCancelled);\n              // If there are no previous heads to fetch, return new heads since\n              // `fromBlockNumber`, or up to maxBackfillBlocks from the current head.\n              if (!(previousHeads.length === 0)) {\n                _context.next = 7;\n                break;\n              }\n              return _context.abrupt(\"return\", this.getHeadEventsInRange(Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1));\n            case 7:\n              // If the last emitted event is too far back in the past, there's no need\n              // to backfill for reorgs. Just fetch the last `maxBackfillBlocks` worth of\n              // new heads.\n              lastSeenBlockNumber = fromHex(previousHeads[previousHeads.length - 1].number);\n              minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n              if (!(lastSeenBlockNumber <= minBlockNumber)) {\n                _context.next = 11;\n                break;\n              }\n              return _context.abrupt(\"return\", this.getHeadEventsInRange(minBlockNumber, toBlockNumber + 1));\n            case 11:\n              _context.next = 13;\n              return this.getReorgHeads(isCancelled, previousHeads);\n            case 13:\n              reorgHeads = _context.sent;\n              throwIfCancelled(isCancelled);\n              _context.next = 17;\n              return this.getHeadEventsInRange(lastSeenBlockNumber + 1, toBlockNumber + 1);\n            case 17:\n              intermediateHeads = _context.sent;\n              throwIfCancelled(isCancelled);\n              return _context.abrupt(\"return\", [].concat(_toConsumableArray(reorgHeads), _toConsumableArray(intermediateHeads)));\n            case 20:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\r\n     * Runs backfill for `logs` events.\r\n     *\r\n     * @param isCancelled Whether the backfill request is cancelled.\r\n     * @param filter The filter object that accompanies a logs subscription.\r\n     * @param previousLogs Previous log requests that were sent.\r\n     * @param fromBlockNumber The block number to start backfilling from.\r\n     */\n  }, {\n    key: \"getLogsBackfill\",\n    value: function getLogsBackfill(isCancelled, filter, previousLogs, fromBlockNumber) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var toBlockNumber, lastSeenBlockNumber, minBlockNumber, commonAncestor, removedLogs, fromBlockInclusive, addedLogs;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              throwIfCancelled(isCancelled);\n              _context2.next = 3;\n              return this.getBlockNumber();\n            case 3:\n              toBlockNumber = _context2.sent;\n              throwIfCancelled(isCancelled);\n              // If there are no previous logs to fetch, return new logs since\n              // `fromBlockNumber`, or up to `maxBackfillBlocks` from the current head.\n              if (!(previousLogs.length === 0)) {\n                _context2.next = 7;\n                break;\n              }\n              return _context2.abrupt(\"return\", this.getLogsInRange(filter, Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1));\n            case 7:\n              // If the last emitted log is too far back in the past, there's no need\n              // to backfill for removed logs. Just fetch the last `maxBackfillBlocks`\n              // worth of logs.\n              lastSeenBlockNumber = fromHex(previousLogs[previousLogs.length - 1].blockNumber);\n              minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n              if (!(lastSeenBlockNumber < minBlockNumber)) {\n                _context2.next = 11;\n                break;\n              }\n              return _context2.abrupt(\"return\", this.getLogsInRange(filter, minBlockNumber, toBlockNumber + 1));\n            case 11:\n              _context2.next = 13;\n              return this.getCommonAncestor(isCancelled, previousLogs);\n            case 13:\n              commonAncestor = _context2.sent;\n              throwIfCancelled(isCancelled);\n              // All previous logs with a block number greater than the common ancestor\n              // were part of a re-org, so mark them as such.\n              removedLogs = previousLogs.filter(function (log) {\n                return fromHex(log.blockNumber) > commonAncestor.blockNumber;\n              }).map(function (log) {\n                return Object.assign(Object.assign({}, log), {\n                  removed: true\n                });\n              }); // If no common ancestor was found, start backfill from the oldest log's\n              // block number.\n              fromBlockInclusive = commonAncestor.blockNumber === Number.NEGATIVE_INFINITY ? fromHex(previousLogs[0].blockNumber) : commonAncestor.blockNumber;\n              _context2.next = 19;\n              return this.getLogsInRange(filter, fromBlockInclusive, toBlockNumber + 1);\n            case 19:\n              addedLogs = _context2.sent;\n              // De-dupe any logs that were already emitted.\n              addedLogs = addedLogs.filter(function (log) {\n                return log && (fromHex(log.blockNumber) > commonAncestor.blockNumber || fromHex(log.logIndex) > commonAncestor.logIndex);\n              });\n              throwIfCancelled(isCancelled);\n              return _context2.abrupt(\"return\", [].concat(_toConsumableArray(removedLogs), _toConsumableArray(addedLogs)));\n            case 23:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\r\n     * Sets a new max backfill blocks. VISIBLE ONLY FOR TESTING.\r\n     *\r\n     * @internal\r\n     */\n  }, {\n    key: \"setMaxBackfillBlock\",\n    value: function setMaxBackfillBlock(newMax) {\n      this.maxBackfillBlocks = newMax;\n    }\n    /**\r\n     * Gets the current block number as a number.\r\n     *\r\n     * @private\r\n     */\n  }, {\n    key: \"getBlockNumber\",\n    value: function getBlockNumber() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var blockNumberHex;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return this.provider.send('eth_blockNumber');\n            case 2:\n              blockNumberHex = _context3.sent;\n              return _context3.abrupt(\"return\", fromHex(blockNumberHex));\n            case 4:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n    }\n    /**\r\n     * Gets all `newHead` events in the provided range. Note that the returned\r\n     * heads do not include re-orged heads. Use {@link getReorgHeads} to find heads\r\n     * that were part of a re-org.\r\n     *\r\n     * @private\r\n     */\n  }, {\n    key: \"getHeadEventsInRange\",\n    value: function getHeadEventsInRange(fromBlockInclusive, toBlockExclusive) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var batchParts, i, blockHeads;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              if (!(fromBlockInclusive >= toBlockExclusive)) {\n                _context4.next = 2;\n                break;\n              }\n              return _context4.abrupt(\"return\", []);\n            case 2:\n              batchParts = [];\n              for (i = fromBlockInclusive; i < toBlockExclusive; i++) {\n                batchParts.push({\n                  method: 'eth_getBlockByNumber',\n                  params: [toHex(i), false]\n                });\n              }\n              // TODO: handle errors\n              _context4.next = 6;\n              return this.provider.sendBatch(batchParts);\n            case 6:\n              blockHeads = _context4.sent;\n              return _context4.abrupt(\"return\", blockHeads.map(toNewHeadsEvent));\n            case 8:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n    }\n    /**\r\n     * Returns all heads that were part of a reorg event.\r\n     *\r\n     * @private\r\n     */\n  }, {\n    key: \"getReorgHeads\",\n    value: function getReorgHeads(isCancelled, previousHeads) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var result, i, oldEvent, blockHead;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              result = []; // Iterate from the most recent head backwards in order to find the first\n              // block that was part of a re-org.\n              i = previousHeads.length - 1;\n            case 2:\n              if (!(i >= 0)) {\n                _context5.next = 14;\n                break;\n              }\n              oldEvent = previousHeads[i];\n              _context5.next = 6;\n              return this.getBlockByNumber(fromHex(oldEvent.number));\n            case 6:\n              blockHead = _context5.sent;\n              throwIfCancelled(isCancelled);\n              // If the hashes match, then current head in the iteration was not re-orged.\n              if (!(oldEvent.hash === blockHead.hash)) {\n                _context5.next = 10;\n                break;\n              }\n              return _context5.abrupt(\"break\", 14);\n            case 10:\n              result.push(toNewHeadsEvent(blockHead));\n            case 11:\n              i--;\n              _context5.next = 2;\n              break;\n            case 14:\n              return _context5.abrupt(\"return\", result.reverse());\n            case 15:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n    }\n    /**\r\n     * Simple wrapper around `eth_getBlockByNumber` that returns the complete\r\n     * block information for the provided block number.\r\n     *\r\n     * @private\r\n     */\n  }, {\n    key: \"getBlockByNumber\",\n    value: function getBlockByNumber(blockNumber) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              return _context6.abrupt(\"return\", this.provider.send('eth_getBlockByNumber', [toHex(blockNumber), false]));\n            case 1:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n    }\n    /**\r\n     * Given a list of previous log events, finds the common block number from the\r\n     * logs that matches the block head.\r\n     *\r\n     * This can be used to identify which logs are part of a re-org.\r\n     *\r\n     * Returns 1 less than the oldest log's block number if no common ancestor was found.\r\n     *\r\n     * @private\r\n     */\n  }, {\n    key: \"getCommonAncestor\",\n    value: function getCommonAncestor(isCancelled, previousLogs) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var blockHead, i, oldLog;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              _context7.next = 2;\n              return this.getBlockByNumber(fromHex(previousLogs[previousLogs.length - 1].blockNumber));\n            case 2:\n              blockHead = _context7.sent;\n              throwIfCancelled(isCancelled);\n              i = previousLogs.length - 1;\n            case 5:\n              if (!(i >= 0)) {\n                _context7.next = 16;\n                break;\n              }\n              oldLog = previousLogs[i]; // Ensure that updated blocks are fetched every time the log's block number\n              // changes.\n              if (!(oldLog.blockNumber !== blockHead.number)) {\n                _context7.next = 11;\n                break;\n              }\n              _context7.next = 10;\n              return this.getBlockByNumber(fromHex(oldLog.blockNumber));\n            case 10:\n              blockHead = _context7.sent;\n            case 11:\n              if (!(oldLog.blockHash === blockHead.hash)) {\n                _context7.next = 13;\n                break;\n              }\n              return _context7.abrupt(\"return\", {\n                blockNumber: fromHex(oldLog.blockNumber),\n                logIndex: fromHex(oldLog.logIndex)\n              });\n            case 13:\n              i--;\n              _context7.next = 5;\n              break;\n            case 16:\n              return _context7.abrupt(\"return\", {\n                blockNumber: Number.NEGATIVE_INFINITY,\n                logIndex: Number.NEGATIVE_INFINITY\n              });\n            case 17:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n    }\n    /**\r\n     * Gets all `logs` events in the provided range. Note that the returned logs\r\n     * do not include removed logs.\r\n     *\r\n     * @private\r\n     */\n  }, {\n    key: \"getLogsInRange\",\n    value: function getLogsInRange(filter, fromBlockInclusive, toBlockExclusive) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var rangeFilter;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              if (!(fromBlockInclusive >= toBlockExclusive)) {\n                _context8.next = 2;\n                break;\n              }\n              return _context8.abrupt(\"return\", []);\n            case 2:\n              rangeFilter = Object.assign(Object.assign({}, filter), {\n                fromBlock: toHex(fromBlockInclusive),\n                toBlock: toHex(toBlockExclusive - 1)\n              });\n              return _context8.abrupt(\"return\", this.provider.send('eth_getLogs', [rangeFilter]));\n            case 4:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this);\n      }));\n    }\n  }]);\n  return WebsocketBackfiller;\n}();\nfunction toNewHeadsEvent(head) {\n  var result = Object.assign({}, head);\n  delete result.totalDifficulty;\n  delete result.transactions;\n  delete result.uncles;\n  return result;\n}\nfunction dedupeNewHeads(events) {\n  return dedupe(events, function (event) {\n    return event.hash;\n  });\n}\nfunction dedupeLogs(events) {\n  return dedupe(events, function (event) {\n    return \"\".concat(event.blockHash, \"/\").concat(event.logIndex);\n  });\n}\nfunction dedupe(items, getKey) {\n  var keysSeen = new Set();\n  var result = [];\n  items.forEach(function (item) {\n    var key = getKey(item);\n    if (!keysSeen.has(key)) {\n      keysSeen.add(key);\n      result.push(item);\n    }\n  });\n  return result;\n}\nvar CANCELLED = new Error('Cancelled');\nfunction throwIfCancelled(isCancelled) {\n  if (isCancelled()) {\n    throw CANCELLED;\n  }\n}\nvar HEARTBEAT_INTERVAL = 30000;\nvar HEARTBEAT_WAIT_TIME = 10000;\nvar BACKFILL_TIMEOUT = 60000;\nvar BACKFILL_RETRIES = 5;\n/**\r\n * Subscriptions have a memory of recent events they have sent so that in the\r\n * event that they disconnect and need to backfill, they can detect re-orgs.\r\n * Keep a buffer that goes back at least these many blocks, the maximum amount\r\n * at which we might conceivably see a re-org.\r\n *\r\n * Note that while our buffer goes back this many blocks, it may contain more\r\n * than this many elements, since in the case of logs subscriptions more than\r\n * one event may be emitted for a block.\r\n */\nvar RETAINED_EVENT_BLOCK_COUNT = 10;\n/**\r\n * SDK's custom implementation fo the ethers.js's 'AlchemyWebSocketProvider'.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an instance of\r\n * {@link Alchemy} and call {@link Alchemy.config.getWebSocketProvider()}.\r\n *\r\n * @public\r\n */\nvar AlchemyWebSocketProvider = /*#__PURE__*/function (_WebSocketProvider) {\n  _inherits(AlchemyWebSocketProvider, _WebSocketProvider);\n  var _super = _createSuper(AlchemyWebSocketProvider);\n  /** @internal */\n  function AlchemyWebSocketProvider(config, wsConstructor) {\n    var _this;\n    _classCallCheck(this, AlchemyWebSocketProvider);\n    var _a;\n    // Normalize the API Key to a string.\n    var apiKey = AlchemyProvider.getApiKey(config.apiKey);\n    // Generate our own connection info with the correct endpoint URLs.\n    var alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\n    var connection = AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, 'wss');\n    var protocol = \"alchemy-sdk-\".concat(VERSION);\n    // Use the provided config URL override if it exists, otherwise use the created one.\n    var ws = new SturdyWebSocket((_a = config.url) !== null && _a !== void 0 ? _a : connection.url, protocol, {\n      wsConstructor: wsConstructor !== null && wsConstructor !== void 0 ? wsConstructor : getWebsocketConstructor()\n    });\n    // Normalize the Alchemy named network input to the network names used by\n    // ethers. This allows the parent super constructor in JsonRpcProvider to\n    // correctly set the network.\n    var ethersNetwork = EthersNetwork[alchemyNetwork];\n    _this = _super.call(this, ws, ethersNetwork);\n    _this._events = [];\n    // In the case of a WebSocket reconnection, all subscriptions are lost and we\n    // create new ones to replace them, but we want to create the illusion that\n    // the original subscriptions persist. Thus, maintain a mapping from the\n    // \"virtual\" subscription ids which are visible to the consumer to the\n    // \"physical\" subscription ids of the actual connections. This terminology is\n    // borrowed from virtual and physical memory, which has a similar mapping.\n    /** @internal */\n    _this.virtualSubscriptionsById = new Map();\n    /** @internal */\n    _this.virtualIdsByPhysicalId = new Map();\n    /**\r\n     * The underlying ethers {@link WebSocketProvider} already handles and emits\r\n     * messages. To allow backfilling, track all messages that are emitted.\r\n     *\r\n     * This is a field arrow function in order to preserve `this` context when\r\n     * passing the method as an event listener.\r\n     *\r\n     * @internal\r\n     */\n    _this.handleMessage = function (event) {\n      var message = JSON.parse(event.data);\n      if (!isSubscriptionEvent(message)) {\n        return;\n      }\n      var physicalId = message.params.subscription;\n      var virtualId = _this.virtualIdsByPhysicalId.get(physicalId);\n      if (!virtualId) {\n        return;\n      }\n      var subscription = _this.virtualSubscriptionsById.get(virtualId);\n      if (subscription.method !== 'eth_subscribe') {\n        return;\n      }\n      switch (subscription.params[0]) {\n        case 'newHeads':\n          {\n            var newHeadsSubscription = subscription;\n            var newHeadsMessage = message;\n            var isBackfilling = newHeadsSubscription.isBackfilling,\n              backfillBuffer = newHeadsSubscription.backfillBuffer;\n            var result = newHeadsMessage.params.result;\n            if (isBackfilling) {\n              addToNewHeadsEventsBuffer(backfillBuffer, result);\n            } else if (physicalId !== virtualId) {\n              // In the case of a re-opened subscription, ethers will not emit the\n              // event, so the SDK has to.\n              _this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n            } else {\n              // Ethers subscription mapping will emit the event, just store it.\n              _this.rememberEvent(virtualId, result, getNewHeadsBlockNumber);\n            }\n            break;\n          }\n        case 'logs':\n          {\n            var logsSubscription = subscription;\n            var logsMessage = message;\n            var _isBackfilling = logsSubscription.isBackfilling,\n              _backfillBuffer = logsSubscription.backfillBuffer;\n            var _result = logsMessage.params.result;\n            if (_isBackfilling) {\n              addToLogsEventsBuffer(_backfillBuffer, _result);\n            } else if (virtualId !== physicalId) {\n              _this.emitAndRememberEvent(virtualId, _result, getLogsBlockNumber);\n            } else {\n              _this.rememberEvent(virtualId, _result, getLogsBlockNumber);\n            }\n            break;\n          }\n        default:\n          if (physicalId !== virtualId) {\n            // In the case of a re-opened subscription, ethers will not emit the\n            // event, so the SDK has to.\n            var _result2 = message.params.result;\n            _this.emitEvent(virtualId, _result2);\n          }\n      }\n    };\n    /**\r\n     * When the websocket connection reopens:\r\n     *\r\n     * 1. Resubscribe to all existing subscriptions and start backfilling\r\n     * 2. Restart heart beat.\r\n     *\r\n     * This is a field arrow function in order to preserve `this` context when\r\n     * passing the method as an event listener.\r\n     *\r\n     * @internal\r\n     */\n    _this.handleReopen = function () {\n      _this.virtualIdsByPhysicalId.clear();\n      var _makeCancelToken = makeCancelToken(),\n        cancel = _makeCancelToken.cancel,\n        isCancelled = _makeCancelToken.isCancelled;\n      _this.cancelBackfill = cancel;\n      var _iterator = _createForOfIteratorHelper(_this.virtualSubscriptionsById.values()),\n        _step;\n      try {\n        var _loop = function _loop() {\n          var subscription = _step.value;\n          void function () {\n            return __awaiter(_assertThisInitialized(_this), void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n              return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n                while (1) switch (_context9.prev = _context9.next) {\n                  case 0:\n                    _context9.prev = 0;\n                    _context9.next = 3;\n                    return this.resubscribeAndBackfill(isCancelled, subscription);\n                  case 3:\n                    _context9.next = 8;\n                    break;\n                  case 5:\n                    _context9.prev = 5;\n                    _context9.t0 = _context9[\"catch\"](0);\n                    if (!isCancelled()) {\n                      console.error(\"Error while backfilling \\\"\".concat(subscription.params[0], \"\\\" subscription. Some events may be missing.\"), _context9.t0);\n                    }\n                  case 8:\n                  case \"end\":\n                    return _context9.stop();\n                }\n              }, _callee9, this, [[0, 5]]);\n            }));\n          }();\n        };\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      _this.startHeartbeat();\n    };\n    /**\r\n     * Cancels the heartbeat and any pending backfills being performed. This is\r\n     * called when the websocket connection goes down or is disconnected.\r\n     *\r\n     * This is a field arrow function in order to preserve `this` context when\r\n     * passing the method as an event listener.\r\n     *\r\n     * @internal\r\n     */\n    _this.stopHeartbeatAndBackfill = function () {\n      if (_this.heartbeatIntervalId != null) {\n        clearInterval(_this.heartbeatIntervalId);\n        _this.heartbeatIntervalId = undefined;\n      }\n      _this.cancelBackfill();\n    };\n    _this.apiKey = apiKey;\n    // Start heartbeat and backfiller for the websocket connection.\n    _this.backfiller = new WebsocketBackfiller(_assertThisInitialized(_this));\n    _this.addSocketListeners();\n    _this.startHeartbeat();\n    _this.cancelBackfill = noop;\n    return _this;\n  }\n  /**\r\n   * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\r\n   *\r\n   * This override allows the SDK to set the provider's network to values not\r\n   * yet supported by ethers.js.\r\n   *\r\n   * @internal\r\n   * @override\r\n   */\n  _createClass(AlchemyWebSocketProvider, [{\n    key: \"on\",\n    value:\n    /**\r\n     * Overridden implementation of ethers that includes Alchemy based subscriptions.\r\n     *\r\n     * @param eventName Event to subscribe to\r\n     * @param listener The listener function to call when the event is triggered.\r\n     * @override\r\n     * @public\r\n     */\n    // TODO: Override `Listener` type to get type autocompletions.\n    function on(eventName, listener) {\n      return this._addEventListener(eventName, listener, false);\n    }\n    /**\r\n     * Overridden implementation of ethers that includes Alchemy based\r\n     * subscriptions. Adds a listener to the triggered for only the next\r\n     * {@link eventName} event, after which it will be removed.\r\n     *\r\n     * @param eventName Event to subscribe to\r\n     * @param listener The listener function to call when the event is triggered.\r\n     * @override\r\n     * @public\r\n     */\n    // TODO: Override `Listener` type to get type autocompletions.\n  }, {\n    key: \"once\",\n    value: function once(eventName, listener) {\n      return this._addEventListener(eventName, listener, true);\n    }\n    /**\r\n     * Removes the provided {@link listener} for the {@link eventName} event. If no\r\n     * listener is provided, all listeners for the event will be removed.\r\n     *\r\n     * @param eventName Event to unlisten to.\r\n     * @param listener The listener function to remove.\r\n     * @override\r\n     * @public\r\n     */\n  }, {\n    key: \"off\",\n    value: function off(eventName, listener) {\n      if (isAlchemyEvent(eventName)) {\n        return this._off(eventName, listener);\n      } else {\n        return _get(_getPrototypeOf(AlchemyWebSocketProvider.prototype), \"off\", this).call(this, eventName, listener);\n      }\n    }\n    /**\r\n     * Remove all listeners for the provided {@link eventName} event. If no event\r\n     * is provided, all events and their listeners are removed.\r\n     *\r\n     * @param eventName The event to remove all listeners for.\r\n     * @override\r\n     * @public\r\n     */\n  }, {\n    key: \"removeAllListeners\",\n    value: function removeAllListeners(eventName) {\n      if (eventName !== undefined && isAlchemyEvent(eventName)) {\n        return this._removeAllListeners(eventName);\n      } else {\n        return _get(_getPrototypeOf(AlchemyWebSocketProvider.prototype), \"removeAllListeners\", this).call(this, eventName);\n      }\n    }\n    /**\r\n     * Returns the number of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, the total number of listeners for all events is returned.\r\n     *\r\n     * @param eventName The event to get the number of listeners for.\r\n     * @public\r\n     * @override\r\n     */\n  }, {\n    key: \"listenerCount\",\n    value: function listenerCount(eventName) {\n      if (eventName !== undefined && isAlchemyEvent(eventName)) {\n        return this._listenerCount(eventName);\n      } else {\n        return _get(_getPrototypeOf(AlchemyWebSocketProvider.prototype), \"listenerCount\", this).call(this, eventName);\n      }\n    }\n    /**\r\n     * Returns an array of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, all listeners will be included.\r\n     *\r\n     * @param eventName The event to get the listeners for.\r\n     * @public\r\n     * @override\r\n     */\n  }, {\n    key: \"listeners\",\n    value: function listeners(eventName) {\n      if (eventName !== undefined && isAlchemyEvent(eventName)) {\n        return this._listeners(eventName);\n      } else {\n        return _get(_getPrototypeOf(AlchemyWebSocketProvider.prototype), \"listeners\", this).call(this, eventName);\n      }\n    }\n    /**\r\n     * Overrides the method in `BaseProvider` in order to properly format the\r\n     * Alchemy subscription events.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\n  }, {\n    key: \"_addEventListener\",\n    value: function _addEventListener(eventName, listener, once) {\n      if (isAlchemyEvent(eventName)) {\n        verifyAlchemyEventName(eventName);\n        var event = new EthersEvent(getAlchemyEventTag(eventName), listener, once);\n        this._events.push(event);\n        this._startEvent(event);\n        return this;\n      } else {\n        return _get(_getPrototypeOf(AlchemyWebSocketProvider.prototype), \"_addEventListener\", this).call(this, eventName, listener, once);\n      }\n    }\n    /**\r\n     * Overrides the `_startEvent()` method in ethers.js's\r\n     * {@link WebSocketProvider} to include additional alchemy methods.\r\n     *\r\n     * @param event\r\n     * @override\r\n     * @internal\r\n     */\n  }, {\n    key: \"_startEvent\",\n    value: function _startEvent(event) {\n      // Check if the event type is a custom Alchemy subscription.\n      var customLogicTypes = [].concat(_toConsumableArray(ALCHEMY_EVENT_TYPES), ['block', 'filter']);\n      if (customLogicTypes.includes(event.type)) {\n        this.customStartEvent(event);\n      } else {\n        _get(_getPrototypeOf(AlchemyWebSocketProvider.prototype), \"_startEvent\", this).call(this, event);\n      }\n    }\n    /**\r\n     * Overridden from ethers.js's {@link WebSocketProvider}\r\n     *\r\n     * Modified in order to add mappings for backfilling.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\n  }, {\n    key: \"_subscribe\",\n    value: function _subscribe(tag, param, processFunc, event) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var _this2 = this;\n        var subIdPromise, startingBlockNumber, subId, resolvedParams;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              subIdPromise = this._subIds[tag]; // BEGIN MODIFIED CODE\n              _context10.next = 3;\n              return this.getBlockNumber();\n            case 3:\n              startingBlockNumber = _context10.sent;\n              // END MODIFIED CODE\n              if (subIdPromise == null) {\n                subIdPromise = Promise.all(param).then(function (param) {\n                  return _this2.send('eth_subscribe', param);\n                });\n                this._subIds[tag] = subIdPromise;\n              }\n              _context10.next = 7;\n              return subIdPromise;\n            case 7:\n              subId = _context10.sent;\n              _context10.next = 10;\n              return Promise.all(param);\n            case 10:\n              resolvedParams = _context10.sent;\n              this.virtualSubscriptionsById.set(subId, {\n                event: event,\n                method: 'eth_subscribe',\n                params: resolvedParams,\n                startingBlockNumber: startingBlockNumber,\n                virtualId: subId,\n                physicalId: subId,\n                sentEvents: [],\n                isBackfilling: false,\n                backfillBuffer: []\n              });\n              this.virtualIdsByPhysicalId.set(subId, subId);\n              // END MODIFIED CODE\n              this._subs[subId] = {\n                tag: tag,\n                processFunc: processFunc\n              };\n            case 14:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, this);\n      }));\n    }\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\n  }, {\n    key: \"emit\",\n    value: function emit(eventName) {\n      var _this3 = this;\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      if (isAlchemyEvent(eventName)) {\n        var result = false;\n        var stopped = [];\n        // This line is the only modified line from the original method.\n        var eventTag = getAlchemyEventTag(eventName);\n        this._events = this._events.filter(function (event) {\n          if (event.tag !== eventTag) {\n            return true;\n          }\n          setTimeout(function () {\n            event.listener.apply(_this3, args);\n          }, 0);\n          result = true;\n          if (event.once) {\n            stopped.push(event);\n            return false;\n          }\n          return true;\n        });\n        stopped.forEach(function (event) {\n          _this3._stopEvent(event);\n        });\n        return result;\n      } else {\n        var _get2;\n        return (_get2 = _get(_getPrototypeOf(AlchemyWebSocketProvider.prototype), \"emit\", this)).call.apply(_get2, [this, eventName].concat(args));\n      }\n    }\n    /** @internal */\n  }, {\n    key: \"sendBatch\",\n    value: function sendBatch(parts) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        var nextId, payload;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              nextId = 0;\n              payload = parts.map(function (_ref) {\n                var method = _ref.method,\n                  params = _ref.params;\n                return {\n                  method: method,\n                  params: params,\n                  jsonrpc: '2.0',\n                  id: \"alchemy-sdk:\".concat(nextId++)\n                };\n              });\n              return _context11.abrupt(\"return\", this.sendBatchConcurrently(payload));\n            case 3:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11, this);\n      }));\n    }\n    /** @override */\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.removeSocketListeners();\n      this.stopHeartbeatAndBackfill();\n      return _get(_getPrototypeOf(AlchemyWebSocketProvider.prototype), \"destroy\", this).call(this);\n    }\n    /**\r\n     * Overrides the ether's `isCommunityResource()` method. Returns true if the\r\n     * current api key is the default key.\r\n     *\r\n     * @override\r\n     */\n  }, {\n    key: \"isCommunityResource\",\n    value: function isCommunityResource() {\n      return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\n    }\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `WebSocketProvider._stopEvent()`.\r\n     *\r\n     * This method is copied over directly in order to support Alchemy's\r\n     * subscription type by allowing the provider to properly stop Alchemy's\r\n     * subscription events.\r\n     *\r\n     * @internal\r\n     */\n  }, {\n    key: \"_stopEvent\",\n    value: function _stopEvent(event) {\n      var _this4 = this;\n      var tag = event.tag;\n      // START MODIFIED CODE\n      if (ALCHEMY_EVENT_TYPES.includes(event.type)) {\n        // There are remaining pending transaction listeners.\n        if (this._events.filter(function (e) {\n          return ALCHEMY_EVENT_TYPES.includes(e.type);\n        }).length) {\n          return;\n        }\n        // END MODIFIED CODE\n      } else if (event.type === 'tx') {\n        // There are remaining transaction event listeners\n        if (this._events.filter(function (e) {\n          return e.type === 'tx';\n        }).length) {\n          return;\n        }\n        tag = 'tx';\n      } else if (this.listenerCount(event.event)) {\n        // There are remaining event listeners\n        return;\n      }\n      var subId = this._subIds[tag];\n      if (!subId) {\n        return;\n      }\n      delete this._subIds[tag];\n      void subId.then(function (subId) {\n        if (!_this4._subs[subId]) {\n          return;\n        }\n        delete _this4._subs[subId];\n        void _this4.send('eth_unsubscribe', [subId]);\n      });\n    }\n    /** @internal */\n  }, {\n    key: \"addSocketListeners\",\n    value: function addSocketListeners() {\n      this._websocket.addEventListener('message', this.handleMessage);\n      this._websocket.addEventListener('reopen', this.handleReopen);\n      this._websocket.addEventListener('down', this.stopHeartbeatAndBackfill);\n    }\n    /** @internal */\n  }, {\n    key: \"removeSocketListeners\",\n    value: function removeSocketListeners() {\n      this._websocket.removeEventListener('message', this.handleMessage);\n      this._websocket.removeEventListener('reopen', this.handleReopen);\n      this._websocket.removeEventListener('down', this.stopHeartbeatAndBackfill);\n    }\n    /**\r\n     * Reopens the backfill based on\r\n     *\r\n     * @param isCancelled\r\n     * @param subscription\r\n     * @internal\r\n     */\n  }, {\n    key: \"resubscribeAndBackfill\",\n    value: function resubscribeAndBackfill(isCancelled, subscription) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n        var _this5 = this;\n        var virtualId, method, params, sentEvents, backfillBuffer, startingBlockNumber, physicalId, backfillEvents, events, filter, _backfillEvents, _events;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              virtualId = subscription.virtualId, method = subscription.method, params = subscription.params, sentEvents = subscription.sentEvents, backfillBuffer = subscription.backfillBuffer, startingBlockNumber = subscription.startingBlockNumber;\n              subscription.isBackfilling = true;\n              backfillBuffer.length = 0;\n              _context12.prev = 3;\n              _context12.next = 6;\n              return this.send(method, params);\n            case 6:\n              physicalId = _context12.sent;\n              throwIfCancelled(isCancelled);\n              subscription.physicalId = physicalId;\n              this.virtualIdsByPhysicalId.set(physicalId, virtualId);\n              _context12.t0 = params[0];\n              _context12.next = _context12.t0 === 'newHeads' ? 13 : _context12.t0 === 'logs' ? 20 : 28;\n              break;\n            case 13:\n              _context12.next = 15;\n              return withBackoffRetries(function () {\n                return withTimeout(_this5.backfiller.getNewHeadsBackfill(isCancelled, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT);\n              }, BACKFILL_RETRIES, function () {\n                return !isCancelled();\n              });\n            case 15:\n              backfillEvents = _context12.sent;\n              throwIfCancelled(isCancelled);\n              events = dedupeNewHeads([].concat(_toConsumableArray(backfillEvents), _toConsumableArray(backfillBuffer)));\n              events.forEach(function (event) {\n                return _this5.emitNewHeadsEvent(virtualId, event);\n              });\n              return _context12.abrupt(\"break\", 29);\n            case 20:\n              filter = params[1] || {};\n              _context12.next = 23;\n              return withBackoffRetries(function () {\n                return withTimeout(_this5.backfiller.getLogsBackfill(isCancelled, filter, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT);\n              }, BACKFILL_RETRIES, function () {\n                return !isCancelled();\n              });\n            case 23:\n              _backfillEvents = _context12.sent;\n              throwIfCancelled(isCancelled);\n              _events = dedupeLogs([].concat(_toConsumableArray(_backfillEvents), _toConsumableArray(backfillBuffer)));\n              _events.forEach(function (event) {\n                return _this5.emitLogsEvent(virtualId, event);\n              });\n              return _context12.abrupt(\"break\", 29);\n            case 28:\n              return _context12.abrupt(\"break\", 29);\n            case 29:\n              _context12.prev = 29;\n              subscription.isBackfilling = false;\n              backfillBuffer.length = 0;\n              return _context12.finish(29);\n            case 33:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee12, this, [[3,, 29, 33]]);\n      }));\n    }\n    /** @internal */\n  }, {\n    key: \"emitNewHeadsEvent\",\n    value: function emitNewHeadsEvent(virtualId, result) {\n      this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n    }\n    /** @internal */\n  }, {\n    key: \"emitLogsEvent\",\n    value: function emitLogsEvent(virtualId, result) {\n      this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n    }\n    /**\r\n     * Emits an event to consumers, but also remembers it in its subscriptions's\r\n     * `sentEvents` buffer so that we can detect re-orgs if the connection drops\r\n     * and needs to be reconnected.\r\n     *\r\n     * @internal\r\n     */\n  }, {\n    key: \"emitAndRememberEvent\",\n    value: function emitAndRememberEvent(virtualId, result, getBlockNumber) {\n      this.rememberEvent(virtualId, result, getBlockNumber);\n      this.emitEvent(virtualId, result);\n    }\n  }, {\n    key: \"emitEvent\",\n    value: function emitEvent(virtualId, result) {\n      var subscription = this.virtualSubscriptionsById.get(virtualId);\n      if (!subscription) {\n        return;\n      }\n      this.emitGenericEvent(subscription, result);\n    }\n    /** @internal */\n  }, {\n    key: \"rememberEvent\",\n    value: function rememberEvent(virtualId, result, getBlockNumber) {\n      var subscription = this.virtualSubscriptionsById.get(virtualId);\n      if (!subscription) {\n        return;\n      }\n      // Web3 modifies these event objects once we pass them on (changing hex\n      // numbers to numbers). We want the original event, so make a defensive\n      // copy.\n      addToPastEventsBuffer(subscription.sentEvents, Object.assign({}, result), getBlockNumber);\n    }\n    /** @internal */\n  }, {\n    key: \"emitGenericEvent\",\n    value: function emitGenericEvent(subscription, result) {\n      var emitFunction = this.emitProcessFn(subscription.event);\n      emitFunction(result);\n    }\n    /**\r\n     * Starts a heartbeat that pings the websocket server periodically to ensure\r\n     * that the connection stays open.\r\n     *\r\n     * @internal\r\n     */\n  }, {\n    key: \"startHeartbeat\",\n    value: function startHeartbeat() {\n      var _this6 = this;\n      if (this.heartbeatIntervalId != null) {\n        return;\n      }\n      this.heartbeatIntervalId = setInterval(function () {\n        return __awaiter(_this6, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {\n          return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n            while (1) switch (_context13.prev = _context13.next) {\n              case 0:\n                _context13.prev = 0;\n                _context13.next = 3;\n                return withTimeout(this.send('net_version'), HEARTBEAT_WAIT_TIME);\n              case 3:\n                _context13.next = 8;\n                break;\n              case 5:\n                _context13.prev = 5;\n                _context13.t0 = _context13[\"catch\"](0);\n                this._websocket.reconnect();\n              case 8:\n              case \"end\":\n                return _context13.stop();\n            }\n          }, _callee13, this, [[0, 5]]);\n        }));\n      }, HEARTBEAT_INTERVAL);\n    }\n    /**\r\n     * This method sends the batch concurrently as individual requests rather than\r\n     * as a batch, which was the original implementation. The original batch logic\r\n     * is preserved in this implementation in order for faster porting.\r\n     *\r\n     * @param payload\r\n     * @internal\r\n     */\n    // TODO(cleanup): Refactor and remove usages of `sendBatch()`.\n    // TODO(errors): Use allSettled() once we have more error handling.\n  }, {\n    key: \"sendBatchConcurrently\",\n    value: function sendBatchConcurrently(payload) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {\n        var _this7 = this;\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) switch (_context14.prev = _context14.next) {\n            case 0:\n              return _context14.abrupt(\"return\", Promise.all(payload.map(function (req) {\n                return _this7.send(req.method, req.params);\n              })));\n            case 1:\n            case \"end\":\n              return _context14.stop();\n          }\n        }, _callee14);\n      }));\n    }\n    /** @internal */\n  }, {\n    key: \"customStartEvent\",\n    value: function customStartEvent(event) {\n      if (event.type === ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n        var fromAddress = event.fromAddress,\n          toAddress = event.toAddress,\n          hashesOnly = event.hashesOnly;\n        void this._subscribe(event.tag, [AlchemySubscription.PENDING_TRANSACTIONS, {\n          fromAddress: fromAddress,\n          toAddress: toAddress,\n          hashesOnly: hashesOnly\n        }], this.emitProcessFn(event), event);\n      } else if (event.type === ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {\n        var addresses = event.addresses,\n          includeRemoved = event.includeRemoved,\n          _hashesOnly = event.hashesOnly;\n        void this._subscribe(event.tag, [AlchemySubscription.MINED_TRANSACTIONS, {\n          addresses: addresses,\n          includeRemoved: includeRemoved,\n          hashesOnly: _hashesOnly\n        }], this.emitProcessFn(event), event);\n      } else if (event.type === 'block') {\n        void this._subscribe('block', ['newHeads'], this.emitProcessFn(event), event);\n      } else if (event.type === 'filter') {\n        void this._subscribe(event.tag, ['logs', this._getFilter(event.filter)], this.emitProcessFn(event), event);\n      }\n    }\n    /** @internal */\n  }, {\n    key: \"emitProcessFn\",\n    value: function emitProcessFn(event) {\n      var _this8 = this;\n      switch (event.type) {\n        case ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE:\n          return function (result) {\n            return _this8.emit({\n              method: AlchemySubscription.PENDING_TRANSACTIONS,\n              fromAddress: event.fromAddress,\n              toAddress: event.toAddress,\n              hashesOnly: event.hashesOnly\n            }, result);\n          };\n        case ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE:\n          return function (result) {\n            return _this8.emit({\n              method: AlchemySubscription.MINED_TRANSACTIONS,\n              addresses: event.addresses,\n              includeRemoved: event.includeRemoved,\n              hashesOnly: event.hashesOnly\n            }, result);\n          };\n        case 'block':\n          return function (result) {\n            var blockNumber = BigNumber.from(result.number).toNumber();\n            _this8._emitted.block = blockNumber;\n            _this8.emit('block', blockNumber);\n          };\n        case 'filter':\n          return function (result) {\n            if (result.removed == null) {\n              result.removed = false;\n            }\n            _this8.emit(event.filter, _this8.formatter.filterLog(result));\n          };\n        default:\n          throw new Error('Invalid event type to `emitProcessFn()`');\n      }\n    }\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.off()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\n  }, {\n    key: \"_off\",\n    value: function _off(eventName, listener) {\n      var _this9 = this;\n      if (listener == null) {\n        return this.removeAllListeners(eventName);\n      }\n      var stopped = [];\n      var found = false;\n      var eventTag = getAlchemyEventTag(eventName);\n      this._events = this._events.filter(function (event) {\n        if (event.tag !== eventTag || event.listener != listener) {\n          return true;\n        }\n        if (found) {\n          return true;\n        }\n        found = true;\n        stopped.push(event);\n        return false;\n      });\n      stopped.forEach(function (event) {\n        _this9._stopEvent(event);\n      });\n      return this;\n    }\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.removeAllListeners()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\n  }, {\n    key: \"_removeAllListeners\",\n    value: function _removeAllListeners(eventName) {\n      var _this10 = this;\n      var stopped = [];\n      if (eventName == null) {\n        stopped = this._events;\n        this._events = [];\n      } else {\n        var eventTag = getAlchemyEventTag(eventName);\n        this._events = this._events.filter(function (event) {\n          if (event.tag !== eventTag) {\n            return true;\n          }\n          stopped.push(event);\n          return false;\n        });\n      }\n      stopped.forEach(function (event) {\n        _this10._stopEvent(event);\n      });\n      return this;\n    }\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.listenerCount()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\n  }, {\n    key: \"_listenerCount\",\n    value: function _listenerCount(eventName) {\n      if (!eventName) {\n        return this._events.length;\n      }\n      var eventTag = getAlchemyEventTag(eventName);\n      return this._events.filter(function (event) {\n        return event.tag === eventTag;\n      }).length;\n    }\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.listeners()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\n  }, {\n    key: \"_listeners\",\n    value: function _listeners(eventName) {\n      if (eventName == null) {\n        return this._events.map(function (event) {\n          return event.listener;\n        });\n      }\n      var eventTag = getAlchemyEventTag(eventName);\n      return this._events.filter(function (event) {\n        return event.tag === eventTag;\n      }).map(function (event) {\n        return event.listener;\n      });\n    }\n  }], [{\n    key: \"getNetwork\",\n    value: function getNetwork(network) {\n      if (typeof network === 'string' && network in CustomNetworks) {\n        return CustomNetworks[network];\n      }\n      // Call the standard ethers.js getNetwork method for other networks.\n      return _getNetwork(network);\n    }\n  }]);\n  return AlchemyWebSocketProvider;\n}(WebSocketProvider);\nfunction getWebsocketConstructor() {\n  return isNodeEnvironment() ? require('websocket').w3cwebsocket : WebSocket;\n}\nfunction isNodeEnvironment() {\n  return typeof process !== 'undefined' && process != null && process.versions != null && process.versions.node != null;\n}\n// TODO(cleanup): Use class variable rather than passing `isCancelled` everywhere.\nfunction makeCancelToken() {\n  var cancelled = false;\n  return {\n    cancel: function cancel() {\n      return cancelled = true;\n    },\n    isCancelled: function isCancelled() {\n      return cancelled;\n    }\n  };\n}\n// TODO(cleanup): replace with SDK's backoff implementation\nvar MIN_RETRY_DELAY = 1000;\nvar RETRY_BACKOFF_FACTOR = 2;\nvar MAX_RETRY_DELAY = 30000;\nfunction withBackoffRetries(f, retryCount) {\n  var shouldRetry = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {\n    return true;\n  };\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {\n    var nextWaitTime, i;\n    return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n      while (1) switch (_context15.prev = _context15.next) {\n        case 0:\n          nextWaitTime = 0;\n          i = 0;\n        case 2:\n          if (!true) {\n            _context15.next = 21;\n            break;\n          }\n          _context15.prev = 3;\n          _context15.next = 6;\n          return f();\n        case 6:\n          return _context15.abrupt(\"return\", _context15.sent);\n        case 9:\n          _context15.prev = 9;\n          _context15.t0 = _context15[\"catch\"](3);\n          i++;\n          if (!(i >= retryCount || !shouldRetry(_context15.t0))) {\n            _context15.next = 14;\n            break;\n          }\n          throw _context15.t0;\n        case 14:\n          _context15.next = 16;\n          return delay(nextWaitTime);\n        case 16:\n          if (shouldRetry(_context15.t0)) {\n            _context15.next = 18;\n            break;\n          }\n          throw _context15.t0;\n        case 18:\n          nextWaitTime = nextWaitTime === 0 ? MIN_RETRY_DELAY : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\n        case 19:\n          _context15.next = 2;\n          break;\n        case 21:\n        case \"end\":\n          return _context15.stop();\n      }\n    }, _callee15, null, [[3, 9]]);\n  }));\n}\nfunction delay(ms) {\n  return new Promise(function (resolve) {\n    return setTimeout(resolve, ms);\n  });\n}\nfunction withTimeout(promise, ms) {\n  return Promise.race([promise, new Promise(function (_, reject) {\n    return setTimeout(function () {\n      return reject(new Error('Timeout'));\n    }, ms);\n  })]);\n}\nfunction getNewHeadsBlockNumber(event) {\n  return fromHex(event.number);\n}\nfunction getLogsBlockNumber(event) {\n  return fromHex(event.blockNumber);\n}\nfunction isResponse(message) {\n  return Array.isArray(message) || message.jsonrpc === '2.0' && message.id !== undefined;\n}\nfunction isSubscriptionEvent(message) {\n  return !isResponse(message);\n}\nfunction addToNewHeadsEventsBuffer(pastEvents, event) {\n  addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\n}\nfunction addToLogsEventsBuffer(pastEvents, event) {\n  addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\n}\n/**\r\n * Adds a new event to an array of events, evicting any events which are so old\r\n * that they will no longer feasibly be part of a reorg.\r\n */\nfunction addToPastEventsBuffer(pastEvents, event, getBlockNumber) {\n  var currentBlockNumber = getBlockNumber(event);\n  // Find first index of an event recent enough to retain, then drop everything\n  // at a lower index.\n  var firstGoodIndex = pastEvents.findIndex(function (e) {\n    return getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT;\n  });\n  if (firstGoodIndex === -1) {\n    pastEvents.length = 0;\n  } else {\n    pastEvents.splice(0, firstGoodIndex);\n  }\n  pastEvents.push(event);\n}\nexport { AlchemyWebSocketProvider };","map":{"version":3,"names":["MAX_BACKFILL_BLOCKS","WebsocketBackfiller","provider","_classCallCheck","maxBackfillBlocks","_createClass","key","value","getNewHeadsBackfill","isCancelled","previousHeads","fromBlockNumber","throwIfCancelled","_context","next","getBlockNumber","toBlockNumber","sent","length","abrupt","getHeadEventsInRange","Math","max","lastSeenBlockNumber","fromHex","number","minBlockNumber","getReorgHeads","reorgHeads","intermediateHeads","concat","_toConsumableArray","stop","_callee","getLogsBackfill","filter","previousLogs","_context2","getLogsInRange","blockNumber","getCommonAncestor","commonAncestor","removedLogs","log","map","Object","assign","removed","fromBlockInclusive","Number","NEGATIVE_INFINITY","addedLogs","logIndex","_callee2","setMaxBackfillBlock","newMax","send","blockNumberHex","_context3","_callee3","toBlockExclusive","_context4","batchParts","i","push","method","params","toHex","sendBatch","blockHeads","toNewHeadsEvent","_callee4","result","_context5","oldEvent","getBlockByNumber","blockHead","hash","reverse","_callee5","_context6","_callee6","_context7","oldLog","blockHash","_callee7","_context8","rangeFilter","fromBlock","toBlock","_callee8","head","totalDifficulty","transactions","uncles","dedupeNewHeads","events","dedupe","event","dedupeLogs","items","getKey","keysSeen","Set","forEach","item","has","add","CANCELLED","Error","HEARTBEAT_INTERVAL","HEARTBEAT_WAIT_TIME","BACKFILL_TIMEOUT","BACKFILL_RETRIES","RETAINED_EVENT_BLOCK_COUNT","AlchemyWebSocketProvider","_WebSocketProvider","_inherits","_super","_createSuper","config","wsConstructor","_this","apiKey","AlchemyProvider","getApiKey","alchemyNetwork","getAlchemyNetwork","network","connection","getAlchemyConnectionInfo","protocol","VERSION","ws","SturdyWebSocket","_a","url","getWebsocketConstructor","ethersNetwork","EthersNetwork","call","_events","virtualSubscriptionsById","Map","virtualIdsByPhysicalId","handleMessage","message","JSON","parse","data","isSubscriptionEvent","physicalId","subscription","virtualId","get","newHeadsSubscription","newHeadsMessage","isBackfilling","backfillBuffer","addToNewHeadsEventsBuffer","emitAndRememberEvent","getNewHeadsBlockNumber","rememberEvent","logsSubscription","logsMessage","addToLogsEventsBuffer","getLogsBlockNumber","emitEvent","handleReopen","clear","_makeCancelToken","makeCancelToken","cancel","cancelBackfill","_iterator","_createForOfIteratorHelper","values","_step","_loop","__awaiter","_assertThisInitialized","_regeneratorRuntime","mark","_callee9","wrap","_callee9$","_context9","prev","resubscribeAndBackfill","t0","console","error","s","n","done","err","e","f","startHeartbeat","stopHeartbeatAndBackfill","heartbeatIntervalId","clearInterval","undefined","backfiller","addSocketListeners","noop","on","eventName","listener","_addEventListener","once","off","isAlchemyEvent","_off","_get","_getPrototypeOf","prototype","removeAllListeners","_removeAllListeners","listenerCount","_listenerCount","listeners","_listeners","verifyAlchemyEventName","EthersEvent","getAlchemyEventTag","_startEvent","customLogicTypes","ALCHEMY_EVENT_TYPES","includes","type","customStartEvent","_subscribe","tag","param","processFunc","subIdPromise","_subIds","startingBlockNumber","_context10","Promise","all","then","_this2","subId","resolvedParams","set","sentEvents","_subs","_callee10","emit","_this3","_len","arguments","args","Array","_key","stopped","eventTag","setTimeout","apply","_stopEvent","_get2","parts","nextId","payload","_ref","jsonrpc","id","_context11","sendBatchConcurrently","_callee11","destroy","removeSocketListeners","isCommunityResource","DEFAULT_ALCHEMY_API_KEY","_this4","_websocket","addEventListener","removeEventListener","_context12","withBackoffRetries","withTimeout","_this5","backfillEvents","emitNewHeadsEvent","emitLogsEvent","finish","_callee12","emitGenericEvent","addToPastEventsBuffer","emitFunction","emitProcessFn","_this6","setInterval","_callee13","_callee13$","_context13","reconnect","req","_this7","_context14","_callee14","ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE","fromAddress","toAddress","hashesOnly","AlchemySubscription","PENDING_TRANSACTIONS","ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE","addresses","includeRemoved","MINED_TRANSACTIONS","_getFilter","_this8","BigNumber","from","toNumber","_emitted","block","formatter","filterLog","_this9","found","_this10","getNetwork","CustomNetworks","WebSocketProvider","isNodeEnvironment","require","w3cwebsocket","WebSocket","process","versions","node","cancelled","MIN_RETRY_DELAY","RETRY_BACKOFF_FACTOR","MAX_RETRY_DELAY","retryCount","shouldRetry","nextWaitTime","_context15","delay","min","_callee15","ms","resolve","promise","race","_","reject","isResponse","isArray","pastEvents","currentBlockNumber","firstGoodIndex","findIndex","splice"],"sources":["/Users/kbookout/escrow-hardhat/app/node_modules/alchemy-sdk/src/internal/websocket-backfiller.ts","/Users/kbookout/escrow-hardhat/app/node_modules/alchemy-sdk/src/api/alchemy-websocket-provider.ts"],"sourcesContent":["import { AlchemyWebSocketProvider } from '../api/alchemy-websocket-provider';\nimport { fromHex, toHex } from '../api/util';\n\nexport interface BatchPart {\n  method: string;\n  params?: any;\n}\n\nexport interface NewHeadsEvent {\n  author: string;\n  difficulty: string;\n  extraData: string;\n  gasLimit: string;\n  gasUsed: string;\n  hash: string;\n  logsBloom: string;\n  miner: string;\n  mixHash: string;\n  nonce: string;\n  number: string;\n  parentHash: string;\n  receiptsRoot: string;\n  sealFields: string[];\n  sha3Uncles: string;\n  size: string;\n  stateRoot: string;\n  timestamp: string;\n  transactionsRoot: string;\n}\n\n/** The return type of eth_getBlocksByHash. */\nexport interface BlockHead extends NewHeadsEvent {\n  totalDifficulty: string;\n  transactions: any[];\n  uncles: string[];\n}\n\nexport interface LogsEvent {\n  address: string;\n  blockHash: string;\n  blockNumber: string;\n  data: string;\n  logIndex: string;\n  topics: string[];\n  transactionHash: string;\n  transactionIndex: string;\n  removed?: boolean;\n}\n\nexport interface LogsSubscriptionFilter {\n  address?: string | string[];\n  topics?: Array<string | string[] | null>;\n}\n\nexport interface GetLogsOptions extends LogsSubscriptionFilter {\n  fromBlock?: string;\n  toBlock?: string;\n}\n\ninterface CommonAncestor {\n  blockNumber: number;\n  logIndex: number;\n}\n\n/**\n * The maximum number of blocks to backfill. If more than this many blocks have\n * been missed, then we'll sadly miss data, but we want to make sure we don't\n * end up requesting thousands of blocks if somebody left their laptop closed for a week.\n */\nconst MAX_BACKFILL_BLOCKS = 120;\n\n/**\n * The WebsocketBackfiller fetches events that were sent since a provided block\n * number. This is used in the {@link AlchemyWebSocketProvider} to backfill\n * events that were transmitted while the websocket connection was down.\n *\n * The backfiller backfills two main eth_subscribe events: `logs` and `newHeads`.\n *\n * @internal\n */\nexport class WebsocketBackfiller {\n  // TODO: Use HTTP provider to do backfill.\n  private maxBackfillBlocks = MAX_BACKFILL_BLOCKS;\n  constructor(private readonly provider: AlchemyWebSocketProvider) {}\n\n  /**\n   * Runs backfill for `newHeads` events.\n   *\n   * @param isCancelled Whether the backfill request is cancelled.\n   * @param previousHeads Previous head requests that were sent.\n   * @param fromBlockNumber The block number to start backfilling from.\n   * @returns A list of `newHeads` events that were sent since the last backfill.\n   */\n  async getNewHeadsBackfill(\n    isCancelled: () => boolean,\n    previousHeads: NewHeadsEvent[],\n    fromBlockNumber: number\n  ): Promise<NewHeadsEvent[]> {\n    throwIfCancelled(isCancelled);\n    const toBlockNumber = await this.getBlockNumber();\n    throwIfCancelled(isCancelled);\n\n    // If there are no previous heads to fetch, return new heads since\n    // `fromBlockNumber`, or up to maxBackfillBlocks from the current head.\n    if (previousHeads.length === 0) {\n      return this.getHeadEventsInRange(\n        Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1,\n        toBlockNumber + 1\n      );\n    }\n\n    // If the last emitted event is too far back in the past, there's no need\n    // to backfill for reorgs. Just fetch the last `maxBackfillBlocks` worth of\n    // new heads.\n    const lastSeenBlockNumber = fromHex(\n      previousHeads[previousHeads.length - 1].number\n    );\n    const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n    if (lastSeenBlockNumber <= minBlockNumber) {\n      return this.getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);\n    }\n\n    // To capture all `newHeads` events, return all head events from the last\n    // seen block number to current + any of the previous heads that were re-orged.\n    const reorgHeads: NewHeadsEvent[] = await this.getReorgHeads(\n      isCancelled,\n      previousHeads\n    );\n    throwIfCancelled(isCancelled);\n    const intermediateHeads: NewHeadsEvent[] = await this.getHeadEventsInRange(\n      lastSeenBlockNumber + 1,\n      toBlockNumber + 1\n    );\n    throwIfCancelled(isCancelled);\n    return [...reorgHeads, ...intermediateHeads];\n  }\n\n  /**\n   * Runs backfill for `logs` events.\n   *\n   * @param isCancelled Whether the backfill request is cancelled.\n   * @param filter The filter object that accompanies a logs subscription.\n   * @param previousLogs Previous log requests that were sent.\n   * @param fromBlockNumber The block number to start backfilling from.\n   */\n  async getLogsBackfill(\n    isCancelled: () => boolean,\n    filter: LogsSubscriptionFilter,\n    previousLogs: LogsEvent[],\n    fromBlockNumber: number\n  ): Promise<LogsEvent[]> {\n    throwIfCancelled(isCancelled);\n    const toBlockNumber = await this.getBlockNumber();\n    throwIfCancelled(isCancelled);\n\n    // If there are no previous logs to fetch, return new logs since\n    // `fromBlockNumber`, or up to `maxBackfillBlocks` from the current head.\n    if (previousLogs.length === 0) {\n      return this.getLogsInRange(\n        filter,\n        Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1,\n        toBlockNumber + 1\n      );\n    }\n\n    // If the last emitted log is too far back in the past, there's no need\n    // to backfill for removed logs. Just fetch the last `maxBackfillBlocks`\n    // worth of logs.\n    const lastSeenBlockNumber = fromHex(\n      previousLogs[previousLogs.length - 1].blockNumber\n    );\n    const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n    if (lastSeenBlockNumber < minBlockNumber) {\n      return this.getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);\n    }\n\n    // Return all log events that have happened along with log events that have\n    // been removed due to a chain reorg.\n    const commonAncestor = await this.getCommonAncestor(\n      isCancelled,\n      previousLogs\n    );\n    throwIfCancelled(isCancelled);\n\n    // All previous logs with a block number greater than the common ancestor\n    // were part of a re-org, so mark them as such.\n    const removedLogs = previousLogs\n      .filter(log => fromHex(log.blockNumber) > commonAncestor.blockNumber)\n      .map(log => ({ ...log, removed: true }));\n\n    // If no common ancestor was found, start backfill from the oldest log's\n    // block number.\n    const fromBlockInclusive =\n      commonAncestor.blockNumber === Number.NEGATIVE_INFINITY\n        ? fromHex(previousLogs[0].blockNumber)\n        : commonAncestor.blockNumber;\n    let addedLogs = await this.getLogsInRange(\n      filter,\n      fromBlockInclusive,\n      toBlockNumber + 1\n    );\n\n    // De-dupe any logs that were already emitted.\n    addedLogs = addedLogs.filter(\n      log =>\n        log &&\n        (fromHex(log.blockNumber) > commonAncestor.blockNumber ||\n          fromHex(log.logIndex) > commonAncestor.logIndex)\n    );\n\n    throwIfCancelled(isCancelled);\n    return [...removedLogs, ...addedLogs];\n  }\n\n  /**\n   * Sets a new max backfill blocks. VISIBLE ONLY FOR TESTING.\n   *\n   * @internal\n   */\n  setMaxBackfillBlock(newMax: number): void {\n    this.maxBackfillBlocks = newMax;\n  }\n\n  /**\n   * Gets the current block number as a number.\n   *\n   * @private\n   */\n  private async getBlockNumber(): Promise<number> {\n    const blockNumberHex: string = await this.provider.send('eth_blockNumber');\n    return fromHex(blockNumberHex);\n  }\n\n  /**\n   * Gets all `newHead` events in the provided range. Note that the returned\n   * heads do not include re-orged heads. Use {@link getReorgHeads} to find heads\n   * that were part of a re-org.\n   *\n   * @private\n   */\n  private async getHeadEventsInRange(\n    fromBlockInclusive: number,\n    toBlockExclusive: number\n  ): Promise<NewHeadsEvent[]> {\n    if (fromBlockInclusive >= toBlockExclusive) {\n      return [];\n    }\n    const batchParts: BatchPart[] = [];\n    for (let i = fromBlockInclusive; i < toBlockExclusive; i++) {\n      batchParts.push({\n        method: 'eth_getBlockByNumber',\n        params: [toHex(i), false]\n      });\n    }\n\n    // TODO: handle errors\n    const blockHeads = await this.provider.sendBatch(batchParts);\n    return blockHeads.map(toNewHeadsEvent);\n  }\n\n  /**\n   * Returns all heads that were part of a reorg event.\n   *\n   * @private\n   */\n  private async getReorgHeads(\n    isCancelled: () => boolean,\n    previousHeads: NewHeadsEvent[]\n  ): Promise<NewHeadsEvent[]> {\n    const result: NewHeadsEvent[] = [];\n    // Iterate from the most recent head backwards in order to find the first\n    // block that was part of a re-org.\n    for (let i = previousHeads.length - 1; i >= 0; i--) {\n      const oldEvent = previousHeads[i];\n      const blockHead = await this.getBlockByNumber(fromHex(oldEvent.number));\n      throwIfCancelled(isCancelled);\n\n      // If the hashes match, then current head in the iteration was not re-orged.\n      if (oldEvent.hash === blockHead.hash) {\n        break;\n      }\n\n      result.push(toNewHeadsEvent(blockHead));\n    }\n    return result.reverse();\n  }\n\n  /**\n   * Simple wrapper around `eth_getBlockByNumber` that returns the complete\n   * block information for the provided block number.\n   *\n   * @private\n   */\n  private async getBlockByNumber(blockNumber: number): Promise<BlockHead> {\n    return this.provider.send('eth_getBlockByNumber', [\n      toHex(blockNumber),\n      false\n    ]);\n  }\n\n  /**\n   * Given a list of previous log events, finds the common block number from the\n   * logs that matches the block head.\n   *\n   * This can be used to identify which logs are part of a re-org.\n   *\n   * Returns 1 less than the oldest log's block number if no common ancestor was found.\n   *\n   * @private\n   */\n  private async getCommonAncestor(\n    isCancelled: () => boolean,\n    previousLogs: LogsEvent[]\n  ): Promise<CommonAncestor> {\n    // Iterate from the most recent head backwards in order to find the first\n    // block that was part of a re-org.\n    let blockHead = await this.getBlockByNumber(\n      fromHex(previousLogs[previousLogs.length - 1].blockNumber)\n    );\n    throwIfCancelled(isCancelled);\n    for (let i = previousLogs.length - 1; i >= 0; i--) {\n      const oldLog = previousLogs[i];\n\n      // Ensure that updated blocks are fetched every time the log's block number\n      // changes.\n      if (oldLog.blockNumber !== blockHead.number) {\n        blockHead = await this.getBlockByNumber(fromHex(oldLog.blockNumber));\n      }\n\n      // Since logs are ordered in ascending order, the first log that matches\n      // the hash should be the largest logIndex.\n      if (oldLog.blockHash === blockHead.hash) {\n        return {\n          blockNumber: fromHex(oldLog.blockNumber),\n          logIndex: fromHex(oldLog.logIndex)\n        };\n      }\n    }\n    return {\n      blockNumber: Number.NEGATIVE_INFINITY,\n      logIndex: Number.NEGATIVE_INFINITY\n    };\n  }\n\n  /**\n   * Gets all `logs` events in the provided range. Note that the returned logs\n   * do not include removed logs.\n   *\n   * @private\n   */ private async getLogsInRange(\n    filter: LogsSubscriptionFilter,\n    fromBlockInclusive: number,\n    toBlockExclusive: number\n  ): Promise<LogsEvent[]> {\n    if (fromBlockInclusive >= toBlockExclusive) {\n      return [];\n    }\n    const rangeFilter: GetLogsOptions = {\n      ...filter,\n      fromBlock: toHex(fromBlockInclusive),\n      toBlock: toHex(toBlockExclusive - 1)\n    };\n    return this.provider.send('eth_getLogs', [rangeFilter]);\n  }\n}\n\nfunction toNewHeadsEvent(head: BlockHead): NewHeadsEvent {\n  const result: NewHeadsEvent & Partial<BlockHead> = { ...head };\n  delete result.totalDifficulty;\n  delete result.transactions;\n  delete result.uncles;\n  return result;\n}\n\nexport function dedupeNewHeads(events: NewHeadsEvent[]): NewHeadsEvent[] {\n  return dedupe(events, event => event.hash);\n}\n\nexport function dedupeLogs(events: LogsEvent[]): LogsEvent[] {\n  return dedupe(events, event => `${event.blockHash}/${event.logIndex}`);\n}\n\nfunction dedupe<T>(items: T[], getKey: (item: T) => any): T[] {\n  const keysSeen: Set<any> = new Set();\n  const result: T[] = [];\n  items.forEach(item => {\n    const key = getKey(item);\n    if (!keysSeen.has(key)) {\n      keysSeen.add(key);\n      result.push(item);\n    }\n  });\n  return result;\n}\n\nconst CANCELLED = new Error('Cancelled');\nexport function throwIfCancelled(isCancelled: () => boolean): void {\n  if (isCancelled()) {\n    throw CANCELLED;\n  }\n}\n","import SturdyWebSocket from 'sturdy-websocket';\n\nimport { Listener } from '@ethersproject/abstract-provider';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport {\n  Networkish,\n  getNetwork as getNetworkFromEthers\n} from '@ethersproject/networks';\nimport { Network as NetworkFromEthers } from '@ethersproject/networks/lib/types';\nimport {\n  CommunityResourcable,\n  WebSocketProvider\n} from '@ethersproject/providers';\n\nimport {\n  EthersEvent,\n  getAlchemyEventTag,\n  isAlchemyEvent,\n  verifyAlchemyEventName\n} from '../internal/ethers-event';\nimport {\n  ALCHEMY_EVENT_TYPES,\n  ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE,\n  ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  SingleOrBatchResponse,\n  SubscriptionEvent,\n  WebSocketMessage\n} from '../internal/internal-types';\nimport {\n  BatchPart,\n  LogsEvent,\n  LogsSubscriptionFilter,\n  NewHeadsEvent,\n  WebsocketBackfiller,\n  dedupeLogs,\n  dedupeNewHeads,\n  throwIfCancelled\n} from '../internal/websocket-backfiller';\nimport { AlchemyEventType, AlchemySubscription } from '../types/types';\nimport {\n  CustomNetworks,\n  DEFAULT_ALCHEMY_API_KEY,\n  EthersNetwork,\n  noop\n} from '../util/const';\nimport { VERSION } from '../version';\nimport { AlchemyConfig } from './alchemy-config';\nimport { AlchemyProvider } from './alchemy-provider';\nimport { fromHex } from './util';\n\nconst HEARTBEAT_INTERVAL = 30000;\nconst HEARTBEAT_WAIT_TIME = 10000;\nconst BACKFILL_TIMEOUT = 60000;\nconst BACKFILL_RETRIES = 5;\n/**\n * Subscriptions have a memory of recent events they have sent so that in the\n * event that they disconnect and need to backfill, they can detect re-orgs.\n * Keep a buffer that goes back at least these many blocks, the maximum amount\n * at which we might conceivably see a re-org.\n *\n * Note that while our buffer goes back this many blocks, it may contain more\n * than this many elements, since in the case of logs subscriptions more than\n * one event may be emitted for a block.\n */\nconst RETAINED_EVENT_BLOCK_COUNT = 10;\n\n/**\n * SDK's custom implementation fo the ethers.js's 'AlchemyWebSocketProvider'.\n *\n * Do not call this constructor directly. Instead, instantiate an instance of\n * {@link Alchemy} and call {@link Alchemy.config.getWebSocketProvider()}.\n *\n * @public\n */\nexport class AlchemyWebSocketProvider\n  extends WebSocketProvider\n  implements CommunityResourcable\n{\n  _events: Array<EthersEvent> = [];\n  readonly apiKey: string;\n\n  // In the case of a WebSocket reconnection, all subscriptions are lost and we\n  // create new ones to replace them, but we want to create the illusion that\n  // the original subscriptions persist. Thus, maintain a mapping from the\n  // \"virtual\" subscription ids which are visible to the consumer to the\n  // \"physical\" subscription ids of the actual connections. This terminology is\n  // borrowed from virtual and physical memory, which has a similar mapping.\n  /** @internal */\n  private readonly virtualSubscriptionsById: Map<string, VirtualSubscription> =\n    new Map();\n  /** @internal */\n  private readonly virtualIdsByPhysicalId: Map<string, string> = new Map();\n  /** @internal */\n  private readonly backfiller: WebsocketBackfiller;\n  /** @internal */\n  private heartbeatIntervalId?: NodeJS.Timeout;\n  /** @internal */\n  private cancelBackfill: () => void;\n\n  /** @internal */\n  constructor(config: AlchemyConfig, wsConstructor?: any) {\n    // Normalize the API Key to a string.\n    const apiKey = AlchemyProvider.getApiKey(config.apiKey);\n\n    // Generate our own connection info with the correct endpoint URLs.\n    const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\n    const connection = AlchemyProvider.getAlchemyConnectionInfo(\n      alchemyNetwork,\n      apiKey,\n      'wss'\n    );\n\n    const protocol = `alchemy-sdk-${VERSION}`;\n\n    // Use the provided config URL override if it exists, otherwise use the created one.\n    const ws = new SturdyWebSocket(config.url ?? connection.url, protocol, {\n      wsConstructor: wsConstructor ?? getWebsocketConstructor()\n    });\n\n    // Normalize the Alchemy named network input to the network names used by\n    // ethers. This allows the parent super constructor in JsonRpcProvider to\n    // correctly set the network.\n    const ethersNetwork = EthersNetwork[alchemyNetwork];\n    super(ws as any, ethersNetwork);\n    this.apiKey = apiKey;\n\n    // Start heartbeat and backfiller for the websocket connection.\n    this.backfiller = new WebsocketBackfiller(this);\n    this.addSocketListeners();\n    this.startHeartbeat();\n    this.cancelBackfill = noop;\n  }\n\n  /**\n   * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\n   *\n   * This override allows the SDK to set the provider's network to values not\n   * yet supported by ethers.js.\n   *\n   * @internal\n   * @override\n   */\n  static getNetwork(network: Networkish): NetworkFromEthers {\n    if (typeof network === 'string' && network in CustomNetworks) {\n      return CustomNetworks[network];\n    }\n\n    // Call the standard ethers.js getNetwork method for other networks.\n    return getNetworkFromEthers(network);\n  }\n\n  /**\n   * Overridden implementation of ethers that includes Alchemy based subscriptions.\n   *\n   * @param eventName Event to subscribe to\n   * @param listener The listener function to call when the event is triggered.\n   * @override\n   * @public\n   */\n  // TODO: Override `Listener` type to get type autocompletions.\n  on(eventName: AlchemyEventType, listener: Listener): this {\n    return this._addEventListener(eventName, listener, false);\n  }\n\n  /**\n   * Overridden implementation of ethers that includes Alchemy based\n   * subscriptions. Adds a listener to the triggered for only the next\n   * {@link eventName} event, after which it will be removed.\n   *\n   * @param eventName Event to subscribe to\n   * @param listener The listener function to call when the event is triggered.\n   * @override\n   * @public\n   */\n  // TODO: Override `Listener` type to get type autocompletions.\n  once(eventName: AlchemyEventType, listener: Listener): this {\n    return this._addEventListener(eventName, listener, true);\n  }\n\n  /**\n   * Removes the provided {@link listener} for the {@link eventName} event. If no\n   * listener is provided, all listeners for the event will be removed.\n   *\n   * @param eventName Event to unlisten to.\n   * @param listener The listener function to remove.\n   * @override\n   * @public\n   */\n  off(eventName: AlchemyEventType, listener?: Listener): this {\n    if (isAlchemyEvent(eventName)) {\n      return this._off(eventName, listener);\n    } else {\n      return super.off(eventName, listener);\n    }\n  }\n\n  /**\n   * Remove all listeners for the provided {@link eventName} event. If no event\n   * is provided, all events and their listeners are removed.\n   *\n   * @param eventName The event to remove all listeners for.\n   * @override\n   * @public\n   */\n  removeAllListeners(eventName?: AlchemyEventType): this {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._removeAllListeners(eventName);\n    } else {\n      return super.removeAllListeners(eventName);\n    }\n  }\n\n  /**\n   * Returns the number of listeners for the provided {@link eventName} event. If\n   * no event is provided, the total number of listeners for all events is returned.\n   *\n   * @param eventName The event to get the number of listeners for.\n   * @public\n   * @override\n   */\n  listenerCount(eventName?: AlchemyEventType): number {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._listenerCount(eventName);\n    } else {\n      return super.listenerCount(eventName);\n    }\n  }\n\n  /**\n   * Returns an array of listeners for the provided {@link eventName} event. If\n   * no event is provided, all listeners will be included.\n   *\n   * @param eventName The event to get the listeners for.\n   * @public\n   * @override\n   */\n  listeners(eventName?: AlchemyEventType): Array<Listener> {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._listeners(eventName);\n    } else {\n      return super.listeners(eventName);\n    }\n  }\n\n  /**\n   * Overrides the method in `BaseProvider` in order to properly format the\n   * Alchemy subscription events.\n   *\n   * @internal\n   * @override\n   */\n  _addEventListener(\n    eventName: AlchemyEventType,\n    listener: Listener,\n    once: boolean\n  ): this {\n    if (isAlchemyEvent(eventName)) {\n      verifyAlchemyEventName(eventName);\n      const event = new EthersEvent(\n        getAlchemyEventTag(eventName),\n        listener,\n        once\n      );\n      this._events.push(event);\n      this._startEvent(event);\n      return this;\n    } else {\n      return super._addEventListener(eventName, listener, once);\n    }\n  }\n\n  /**\n   * Overrides the `_startEvent()` method in ethers.js's\n   * {@link WebSocketProvider} to include additional alchemy methods.\n   *\n   * @param event\n   * @override\n   * @internal\n   */\n  _startEvent(event: EthersEvent): void {\n    // Check if the event type is a custom Alchemy subscription.\n    const customLogicTypes = [...ALCHEMY_EVENT_TYPES, 'block', 'filter'];\n    if (customLogicTypes.includes(event.type)) {\n      this.customStartEvent(event);\n    } else {\n      super._startEvent(event);\n    }\n  }\n\n  /**\n   * Overridden from ethers.js's {@link WebSocketProvider}\n   *\n   * Modified in order to add mappings for backfilling.\n   *\n   * @internal\n   * @override\n   */\n  async _subscribe(\n    tag: string,\n    param: Array<any>,\n    processFunc: (result: any) => void,\n    event?: EthersEvent\n  ): Promise<void> {\n    let subIdPromise = this._subIds[tag];\n\n    // BEGIN MODIFIED CODE\n    const startingBlockNumber = await this.getBlockNumber();\n    // END MODIFIED CODE\n\n    if (subIdPromise == null) {\n      subIdPromise = Promise.all(param).then(param => {\n        return this.send('eth_subscribe', param);\n      });\n      this._subIds[tag] = subIdPromise;\n    }\n    const subId = await subIdPromise;\n\n    // BEGIN MODIFIED CODE\n    const resolvedParams = await Promise.all(param);\n    this.virtualSubscriptionsById.set(subId, {\n      event: event!,\n      method: 'eth_subscribe',\n      params: resolvedParams,\n      startingBlockNumber,\n      virtualId: subId,\n      physicalId: subId,\n      sentEvents: [],\n      isBackfilling: false,\n      backfillBuffer: []\n    });\n    this.virtualIdsByPhysicalId.set(subId, subId);\n\n    // END MODIFIED CODE\n\n    this._subs[subId] = { tag, processFunc };\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @internal\n   * @override\n   */\n  emit(eventName: AlchemyEventType, ...args: Array<any>): boolean {\n    if (isAlchemyEvent(eventName)) {\n      let result = false;\n\n      const stopped: Array<EthersEvent> = [];\n\n      // This line is the only modified line from the original method.\n      const eventTag = getAlchemyEventTag(eventName);\n\n      this._events = this._events.filter(event => {\n        if (event.tag !== eventTag) {\n          return true;\n        }\n\n        setTimeout(() => {\n          event.listener.apply(this, args);\n        }, 0);\n\n        result = true;\n\n        if (event.once) {\n          stopped.push(event);\n          return false;\n        }\n\n        return true;\n      });\n\n      stopped.forEach(event => {\n        this._stopEvent(event);\n      });\n\n      return result;\n    } else {\n      return super.emit(eventName, ...args);\n    }\n  }\n\n  /** @internal */\n  async sendBatch(parts: BatchPart[]): Promise<any[]> {\n    let nextId = 0;\n    const payload: JsonRpcRequest[] = parts.map(({ method, params }) => {\n      return {\n        method,\n        params,\n        jsonrpc: '2.0',\n        id: `alchemy-sdk:${nextId++}`\n      };\n    });\n\n    return this.sendBatchConcurrently(payload);\n  }\n\n  /** @override */\n  destroy(): Promise<void> {\n    this.removeSocketListeners();\n    this.stopHeartbeatAndBackfill();\n    return super.destroy();\n  }\n\n  /**\n   * Overrides the ether's `isCommunityResource()` method. Returns true if the\n   * current api key is the default key.\n   *\n   * @override\n   */\n  isCommunityResource(): boolean {\n    return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `WebSocketProvider._stopEvent()`.\n   *\n   * This method is copied over directly in order to support Alchemy's\n   * subscription type by allowing the provider to properly stop Alchemy's\n   * subscription events.\n   *\n   * @internal\n   */\n  _stopEvent(event: EthersEvent): void {\n    let tag = event.tag;\n\n    // START MODIFIED CODE\n    if (ALCHEMY_EVENT_TYPES.includes(event.type)) {\n      // There are remaining pending transaction listeners.\n      if (\n        this._events.filter(e => ALCHEMY_EVENT_TYPES.includes(e.type)).length\n      ) {\n        return;\n      }\n      // END MODIFIED CODE\n    } else if (event.type === 'tx') {\n      // There are remaining transaction event listeners\n      if (this._events.filter(e => e.type === 'tx').length) {\n        return;\n      }\n      tag = 'tx';\n    } else if (this.listenerCount(event.event)) {\n      // There are remaining event listeners\n      return;\n    }\n\n    const subId = this._subIds[tag];\n    if (!subId) {\n      return;\n    }\n\n    delete this._subIds[tag];\n    void subId.then(subId => {\n      if (!this._subs[subId]) {\n        return;\n      }\n      delete this._subs[subId];\n      void this.send('eth_unsubscribe', [subId]);\n    });\n  }\n\n  /** @internal */\n  private addSocketListeners(): void {\n    this._websocket.addEventListener('message', this.handleMessage);\n    this._websocket.addEventListener('reopen', this.handleReopen);\n    this._websocket.addEventListener('down', this.stopHeartbeatAndBackfill);\n  }\n\n  /** @internal */\n  private removeSocketListeners(): void {\n    this._websocket.removeEventListener('message', this.handleMessage);\n    this._websocket.removeEventListener('reopen', this.handleReopen);\n    this._websocket.removeEventListener('down', this.stopHeartbeatAndBackfill);\n  }\n\n  /**\n   * The underlying ethers {@link WebSocketProvider} already handles and emits\n   * messages. To allow backfilling, track all messages that are emitted.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private handleMessage = (event: MessageEvent): void => {\n    const message: WebSocketMessage = JSON.parse(event.data);\n    if (!isSubscriptionEvent(message)) {\n      return;\n    }\n    const physicalId = message.params.subscription;\n    const virtualId = this.virtualIdsByPhysicalId.get(physicalId);\n    if (!virtualId) {\n      return;\n    }\n    const subscription = this.virtualSubscriptionsById.get(virtualId)!;\n    if (subscription.method !== 'eth_subscribe') {\n      return;\n    }\n\n    switch (subscription.params[0]) {\n      case 'newHeads': {\n        const newHeadsSubscription = subscription as NewHeadsSubscription;\n        const newHeadsMessage = message as SubscriptionEvent<NewHeadsEvent>;\n        const { isBackfilling, backfillBuffer } = newHeadsSubscription;\n        const { result } = newHeadsMessage.params;\n        if (isBackfilling) {\n          addToNewHeadsEventsBuffer(backfillBuffer, result);\n        } else if (physicalId !== virtualId) {\n          // In the case of a re-opened subscription, ethers will not emit the\n          // event, so the SDK has to.\n          this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n        } else {\n          // Ethers subscription mapping will emit the event, just store it.\n          this.rememberEvent(virtualId, result, getNewHeadsBlockNumber);\n        }\n        break;\n      }\n      case 'logs': {\n        const logsSubscription = subscription as LogsSubscription;\n        const logsMessage = message as SubscriptionEvent<LogsEvent>;\n        const { isBackfilling, backfillBuffer } = logsSubscription;\n        const { result } = logsMessage.params;\n        if (isBackfilling) {\n          addToLogsEventsBuffer(backfillBuffer, result);\n        } else if (virtualId !== physicalId) {\n          this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n        } else {\n          this.rememberEvent(virtualId, result, getLogsBlockNumber);\n        }\n        break;\n      }\n      default:\n        if (physicalId !== virtualId) {\n          // In the case of a re-opened subscription, ethers will not emit the\n          // event, so the SDK has to.\n          const { result } = (message as SubscriptionEvent<unknown>).params;\n          this.emitEvent(virtualId, result);\n        }\n    }\n  };\n\n  /**\n   * When the websocket connection reopens:\n   *\n   * 1. Resubscribe to all existing subscriptions and start backfilling\n   * 2. Restart heart beat.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private handleReopen = () => {\n    this.virtualIdsByPhysicalId.clear();\n    const { cancel, isCancelled } = makeCancelToken();\n    this.cancelBackfill = cancel;\n    for (const subscription of this.virtualSubscriptionsById.values()) {\n      void (async () => {\n        try {\n          await this.resubscribeAndBackfill(isCancelled, subscription);\n        } catch (error) {\n          if (!isCancelled()) {\n            console.error(\n              `Error while backfilling \"${subscription.params[0]}\" subscription. Some events may be missing.`,\n              error\n            );\n          }\n        }\n      })();\n    }\n    this.startHeartbeat();\n  };\n\n  /**\n   * Reopens the backfill based on\n   *\n   * @param isCancelled\n   * @param subscription\n   * @internal\n   */\n  private async resubscribeAndBackfill(\n    isCancelled: () => boolean,\n    subscription: VirtualSubscription\n  ): Promise<void> {\n    const {\n      virtualId,\n      method,\n      params,\n      sentEvents,\n      backfillBuffer,\n      startingBlockNumber\n    } = subscription;\n    subscription.isBackfilling = true;\n    backfillBuffer.length = 0;\n    try {\n      const physicalId = await this.send(method, params);\n      throwIfCancelled(isCancelled);\n      subscription.physicalId = physicalId;\n      this.virtualIdsByPhysicalId.set(physicalId, virtualId);\n      switch (params[0]) {\n        case 'newHeads': {\n          const backfillEvents = await withBackoffRetries(\n            () =>\n              withTimeout(\n                this.backfiller.getNewHeadsBackfill(\n                  isCancelled,\n                  sentEvents,\n                  startingBlockNumber\n                ),\n                BACKFILL_TIMEOUT\n              ),\n            BACKFILL_RETRIES,\n            () => !isCancelled()\n          );\n          throwIfCancelled(isCancelled);\n          const events = dedupeNewHeads([...backfillEvents, ...backfillBuffer]);\n          events.forEach(event => this.emitNewHeadsEvent(virtualId, event));\n          break;\n        }\n        case 'logs': {\n          const filter: LogsSubscriptionFilter = params[1] || {};\n          const backfillEvents = await withBackoffRetries(\n            () =>\n              withTimeout(\n                this.backfiller.getLogsBackfill(\n                  isCancelled,\n                  filter,\n                  sentEvents,\n                  startingBlockNumber\n                ),\n                BACKFILL_TIMEOUT\n              ),\n            BACKFILL_RETRIES,\n            () => !isCancelled()\n          );\n          throwIfCancelled(isCancelled);\n          const events = dedupeLogs([...backfillEvents, ...backfillBuffer]);\n          events.forEach(event => this.emitLogsEvent(virtualId, event));\n          break;\n        }\n        default:\n          break;\n      }\n    } finally {\n      subscription.isBackfilling = false;\n      backfillBuffer.length = 0;\n    }\n  }\n\n  /**\n   * Cancels the heartbeat and any pending backfills being performed. This is\n   * called when the websocket connection goes down or is disconnected.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private stopHeartbeatAndBackfill = () => {\n    if (this.heartbeatIntervalId != null) {\n      clearInterval(this.heartbeatIntervalId);\n      this.heartbeatIntervalId = undefined;\n    }\n    this.cancelBackfill();\n  };\n\n  /** @internal */\n  private emitNewHeadsEvent(virtualId: string, result: NewHeadsEvent): void {\n    this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n  }\n\n  /** @internal */\n  private emitLogsEvent(virtualId: string, result: LogsEvent): void {\n    this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n  }\n\n  /**\n   * Emits an event to consumers, but also remembers it in its subscriptions's\n   * `sentEvents` buffer so that we can detect re-orgs if the connection drops\n   * and needs to be reconnected.\n   *\n   * @internal\n   */\n  private emitAndRememberEvent<T>(\n    virtualId: string,\n    result: T,\n    getBlockNumber: (result: T) => number\n  ): void {\n    this.rememberEvent(virtualId, result, getBlockNumber);\n    this.emitEvent(virtualId, result);\n  }\n\n  private emitEvent<T>(virtualId: string, result: T): void {\n    const subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    this.emitGenericEvent(subscription, result);\n  }\n\n  /** @internal */\n  private rememberEvent<T>(\n    virtualId: string,\n    result: T,\n    getBlockNumber: (result: T) => number\n  ): void {\n    const subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    // Web3 modifies these event objects once we pass them on (changing hex\n    // numbers to numbers). We want the original event, so make a defensive\n    // copy.\n    addToPastEventsBuffer(\n      subscription.sentEvents,\n      { ...result },\n      getBlockNumber\n    );\n  }\n\n  /** @internal */\n  private emitGenericEvent(\n    subscription: VirtualSubscription,\n    result: any\n  ): void {\n    const emitFunction = this.emitProcessFn(subscription.event);\n    emitFunction(result);\n  }\n\n  /**\n   * Starts a heartbeat that pings the websocket server periodically to ensure\n   * that the connection stays open.\n   *\n   * @internal\n   */\n  private startHeartbeat(): void {\n    if (this.heartbeatIntervalId != null) {\n      return;\n    }\n    this.heartbeatIntervalId = setInterval(async () => {\n      try {\n        await withTimeout(this.send('net_version'), HEARTBEAT_WAIT_TIME);\n      } catch {\n        this._websocket.reconnect();\n      }\n    }, HEARTBEAT_INTERVAL);\n  }\n\n  /**\n   * This method sends the batch concurrently as individual requests rather than\n   * as a batch, which was the original implementation. The original batch logic\n   * is preserved in this implementation in order for faster porting.\n   *\n   * @param payload\n   * @internal\n   */\n  // TODO(cleanup): Refactor and remove usages of `sendBatch()`.\n  // TODO(errors): Use allSettled() once we have more error handling.\n  private async sendBatchConcurrently(\n    payload: JsonRpcRequest[]\n  ): Promise<unknown[]> {\n    return Promise.all(payload.map(req => this.send(req.method, req.params)));\n  }\n\n  /** @internal */\n  private customStartEvent(event: EthersEvent): void {\n    if (event.type === ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n      const { fromAddress, toAddress, hashesOnly } = event;\n      void this._subscribe(\n        event.tag,\n        [\n          AlchemySubscription.PENDING_TRANSACTIONS,\n          { fromAddress, toAddress, hashesOnly }\n        ],\n        this.emitProcessFn(event),\n        event\n      );\n    } else if (event.type === ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {\n      const { addresses, includeRemoved, hashesOnly } = event;\n      void this._subscribe(\n        event.tag,\n        [\n          AlchemySubscription.MINED_TRANSACTIONS,\n          { addresses, includeRemoved, hashesOnly }\n        ],\n        this.emitProcessFn(event),\n        event\n      );\n    } else if (event.type === 'block') {\n      void this._subscribe(\n        'block',\n        ['newHeads'],\n        this.emitProcessFn(event),\n        event\n      );\n    } else if (event.type === 'filter') {\n      void this._subscribe(\n        event.tag,\n        ['logs', this._getFilter(event.filter)],\n        this.emitProcessFn(event),\n        event\n      );\n    }\n  }\n\n  /** @internal */\n  private emitProcessFn(event: EthersEvent): (result: any) => void {\n    switch (event.type) {\n      case ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE:\n        return result =>\n          this.emit(\n            {\n              method: AlchemySubscription.PENDING_TRANSACTIONS,\n              fromAddress: event.fromAddress,\n              toAddress: event.toAddress,\n              hashesOnly: event.hashesOnly\n            },\n            result\n          );\n      case ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE:\n        return result =>\n          this.emit(\n            {\n              method: AlchemySubscription.MINED_TRANSACTIONS,\n              addresses: event.addresses,\n              includeRemoved: event.includeRemoved,\n              hashesOnly: event.hashesOnly\n            },\n            result\n          );\n      case 'block':\n        return result => {\n          const blockNumber = BigNumber.from(result.number).toNumber();\n          this._emitted.block = blockNumber;\n          this.emit('block', blockNumber);\n        };\n      case 'filter':\n        return result => {\n          if (result.removed == null) {\n            result.removed = false;\n          }\n          this.emit(event.filter, this.formatter.filterLog(result));\n        };\n      default:\n        throw new Error('Invalid event type to `emitProcessFn()`');\n    }\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.off()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _off(eventName: AlchemyEventType, listener?: Listener): this {\n    if (listener == null) {\n      return this.removeAllListeners(eventName);\n    }\n\n    const stopped: Array<EthersEvent> = [];\n\n    let found = false;\n    const eventTag = getAlchemyEventTag(eventName);\n    this._events = this._events.filter(event => {\n      if (event.tag !== eventTag || event.listener != listener) {\n        return true;\n      }\n      if (found) {\n        return true;\n      }\n      found = true;\n      stopped.push(event);\n      return false;\n    });\n\n    stopped.forEach(event => {\n      this._stopEvent(event);\n    });\n\n    return this;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.removeAllListeners()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _removeAllListeners(eventName: AlchemyEventType): this {\n    let stopped: Array<EthersEvent> = [];\n    if (eventName == null) {\n      stopped = this._events;\n\n      this._events = [];\n    } else {\n      const eventTag = getAlchemyEventTag(eventName);\n      this._events = this._events.filter(event => {\n        if (event.tag !== eventTag) {\n          return true;\n        }\n        stopped.push(event);\n        return false;\n      });\n    }\n\n    stopped.forEach(event => {\n      this._stopEvent(event);\n    });\n\n    return this;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.listenerCount()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _listenerCount(eventName?: AlchemyEventType): number {\n    if (!eventName) {\n      return this._events.length;\n    }\n\n    const eventTag = getAlchemyEventTag(eventName);\n    return this._events.filter(event => {\n      return event.tag === eventTag;\n    }).length;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.listeners()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _listeners(eventName?: AlchemyEventType): Array<Listener> {\n    if (eventName == null) {\n      return this._events.map(event => event.listener);\n    }\n\n    const eventTag = getAlchemyEventTag(eventName);\n    return this._events\n      .filter(event => event.tag === eventTag)\n      .map(event => event.listener);\n  }\n}\n\nfunction getWebsocketConstructor(): any {\n  return isNodeEnvironment() ? require('websocket').w3cwebsocket : WebSocket;\n}\n\nfunction isNodeEnvironment(): boolean {\n  return (\n    typeof process !== 'undefined' &&\n    process != null &&\n    process.versions != null &&\n    process.versions.node != null\n  );\n}\n\n/** @internal */\ninterface CancelToken {\n  cancel(): void;\n  isCancelled(): boolean;\n}\n\ninterface VirtualSubscription {\n  event: EthersEvent;\n  virtualId: string;\n  physicalId: string;\n  method: string;\n  params: any[];\n  isBackfilling: boolean;\n  startingBlockNumber: number;\n  sentEvents: any[];\n  backfillBuffer: any[];\n}\n\ninterface NewHeadsSubscription extends VirtualSubscription {\n  method: 'eth_subscribe';\n  params: ['newHeads'];\n  isBackfilling: boolean;\n  sentEvents: NewHeadsEvent[];\n  backfillBuffer: NewHeadsEvent[];\n}\n\ninterface LogsSubscription extends VirtualSubscription {\n  method: 'eth_subscribe';\n  params: ['logs', LogsSubscriptionFilter?];\n  isBackfilling: boolean;\n  sentEvents: LogsEvent[];\n  backfillBuffer: LogsEvent[];\n}\n\n// TODO(cleanup): Use class variable rather than passing `isCancelled` everywhere.\nfunction makeCancelToken(): CancelToken {\n  let cancelled = false;\n  return { cancel: () => (cancelled = true), isCancelled: () => cancelled };\n}\n\n// TODO(cleanup): replace with SDK's backoff implementation\nconst MIN_RETRY_DELAY = 1000;\nconst RETRY_BACKOFF_FACTOR = 2;\nconst MAX_RETRY_DELAY = 30000;\n\nasync function withBackoffRetries<T>(\n  f: () => Promise<T>,\n  retryCount: number,\n  shouldRetry: (error: unknown) => boolean = () => true\n): Promise<T> {\n  let nextWaitTime = 0;\n  let i = 0;\n  while (true) {\n    try {\n      return await f();\n    } catch (error) {\n      i++;\n      if (i >= retryCount || !shouldRetry(error)) {\n        throw error;\n      }\n      await delay(nextWaitTime);\n      if (!shouldRetry(error)) {\n        throw error;\n      }\n      nextWaitTime =\n        nextWaitTime === 0\n          ? MIN_RETRY_DELAY\n          : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\n    }\n  }\n}\n\nfunction delay(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nfunction withTimeout<T>(promise: Promise<T>, ms: number): Promise<T> {\n  return Promise.race([\n    promise,\n    new Promise<T>((_, reject) =>\n      setTimeout(() => reject(new Error('Timeout')), ms)\n    )\n  ]);\n}\n\nfunction getNewHeadsBlockNumber(event: NewHeadsEvent): number {\n  return fromHex(event.number);\n}\n\nfunction getLogsBlockNumber(event: LogsEvent): number {\n  return fromHex(event.blockNumber);\n}\n\nfunction isResponse(\n  message: WebSocketMessage\n): message is SingleOrBatchResponse {\n  return (\n    Array.isArray(message) ||\n    (message.jsonrpc === '2.0' && (message as JsonRpcResponse).id !== undefined)\n  );\n}\n\nfunction isSubscriptionEvent(\n  message: WebSocketMessage\n): message is SubscriptionEvent {\n  return !isResponse(message);\n}\n\nfunction addToNewHeadsEventsBuffer(\n  pastEvents: NewHeadsEvent[],\n  event: NewHeadsEvent\n): void {\n  addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\n}\n\nfunction addToLogsEventsBuffer(\n  pastEvents: LogsEvent[],\n  event: LogsEvent\n): void {\n  addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\n}\n\n/**\n * Adds a new event to an array of events, evicting any events which are so old\n * that they will no longer feasibly be part of a reorg.\n */\nfunction addToPastEventsBuffer<T>(\n  pastEvents: T[],\n  event: T,\n  getBlockNumber: (event: T) => number\n): void {\n  const currentBlockNumber = getBlockNumber(event);\n  // Find first index of an event recent enough to retain, then drop everything\n  // at a lower index.\n  const firstGoodIndex = pastEvents.findIndex(\n    e => getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT\n  );\n  if (firstGoodIndex === -1) {\n    pastEvents.length = 0;\n  } else {\n    pastEvents.splice(0, firstGoodIndex);\n  }\n  pastEvents.push(event);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}